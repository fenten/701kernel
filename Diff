diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index f607528..54f21a5 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2483,8 +2483,6 @@ and is between 256 and 4096 characters. It is defined in the file
 
 	wdt=		[WDT] Watchdog
 			See Documentation/watchdog/wdt.txt.
-	wdt_stat=        [WDT] Watchdog
-	        Turn off wdt option.
 
 	xd=		[HW,XT] Original XT pre-IDE (RLL encoded) disks.
 	xd_geo=		See header of drivers/block/xd.c.
diff --git a/arch/arm/configs/mapphone_defconfig b/arch/arm/configs/mapphone_defconfig
index 8871da8..00c5ec1 100755
--- a/arch/arm/configs/mapphone_defconfig
+++ b/arch/arm/configs/mapphone_defconfig
@@ -803,7 +803,7 @@ CONFIG_OMAP_MODEM_CONTROL=y
 # CONFIG_ENCLOSURE_SERVICES is not set
 # CONFIG_KERNEL_DEBUGGER_CORE is not set
 # CONFIG_UID_STAT is not set
-# CONFIG_VIB_OMAP_PWM is not set
+CONFIG_VIB_PWM=y
 CONFIG_VIB_GPIO=y
 # CONFIG_SENSORS_AKM8973 is not set
 CONFIG_SENSORS_AKM8973_AKMD=y
@@ -1257,8 +1257,10 @@ CONFIG_VIDEO_OMAP3_HP3A=y
 #
 # CONFIG_VIDEO_OV7670 is not set
 # CONFIG_VIDEO_TCM825X is not set
-CONFIG_VIDEO_MT9P012=y
+#CONFIG_VIDEO_MT9P012 is not set
 CONFIG_VIDEO_OMAP3_HPLENS=y
+CONFIG_VIDEO_OV8810=y
+CONFIG_VIDEO_MIPI_INTERFACE=y
 # CONFIG_VIDEO_IMX046 is not set
 # CONFIG_VIDEO_LV8093 is not set
 # CONFIG_VIDEO_SAA711X is not set
@@ -1672,7 +1674,9 @@ CONFIG_LEDS_CLASS=y
 # CONFIG_LEDS_PCA955X is not set
 CONFIG_LEDS_SHOLES=y
 CONFIG_LEDS_LM3530=y
-CONFIG_LEDS_LM3554=y
+#CONFIG_LEDS_LM3554 is not set
+CONFIG_LEDS_BD7885=y
+CONFIG_LEDS_BU9847=y
 
 #
 # LED Triggers
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index 5ce7d31..d2e8149 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -119,7 +119,7 @@ config MACH_OMAP_ZOOM2
 
 config WIFI_CONTROL_FUNC
         bool "Enable WiFi control function abstraction"
-	depends on MACH_OMAP_ZOOM2 || MACH_SHOLES || MACH_MAPPHONE
+	depends on MACH_OMAP_ZOOM2 || MACH_SHOLES || MACH_MAPPHONE || MACH_SHOLEST
         help
           Enables Power/Reset/Carddetect function abstraction
 
@@ -164,6 +164,10 @@ config MACH_SHOLES_UMTS
         bool "Motorola sholes umts"
         depends on MACH_SHOLES
 
+config MACH_SHOLEST
+        bool "Motorola sholes tablet"
+        depends on ARCH_OMAP3 && ARCH_OMAP34XX
+
 config MACH_MAPPHONE
         bool "Motorola Android Platform phone"
         depends on ARCH_OMAP3 && ARCH_OMAP34XX
@@ -176,6 +180,10 @@ config MACH_OMAP3_PANDORA
 	bool "OMAP3 Pandora"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
 
+config MOT_FEAT_MDTV
+	bool "support MDTV system for motorola"
+	default n
+
 config EMU_UART_DEBUG
 	bool "Provide the option of setting MiniUSB port as UART3 to debug kernel"
 	default n
@@ -191,3 +199,9 @@ config PROC_OMAP_PHONE_ID
 	default n
 	help
 	  Exports the DIE_ID reg value.
+
+config CUP2TOUCH
+	bool "Support touch for CU p2"
+	default n
+	help
+	  CU p2 touch needs special treatment for its differenct IC
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index c4ab2c3..2981dc2 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -85,6 +85,20 @@ obj-$(CONFIG_MACH_SHOLES)		+= board-sholes.o \
 					   board-sholes-keypad.o \
 					   board-sholes-wifi.o \
 					   board-sholes-mmcprobe.o
+obj-$(CONFIG_MACH_SHOLEST)             	+= board-sholest.o \
+					   board-sholest-camera.o \
+					   board-sholest-flash.o \
+					   board-sholest-padconf.o \
+					   board-sholest-panel.o \
+					   board-sholest-spi.o \
+					   board-sholest-sensors.o \
+					   board-sholest-hsmmc.o \
+					   board-sholest-keypad.o \
+					   board-sholest-wifi.o \
+					   board-sholest-gpio.o \
+					   board-sholest-mmcprobe.o \
+					   board-sholest-mdtv.o
+ifeq ($(CONFIG_MACH_SHOLEST),)
 obj-$(CONFIG_MACH_MAPPHONE)		+= board-mapphone.o \
 					   board-mapphone-camera.o \
 					   board-mapphone-flash.o \
@@ -96,7 +110,9 @@ obj-$(CONFIG_MACH_MAPPHONE)		+= board-mapphone.o \
 					   board-mapphone-keypad.o \
 					   board-mapphone-wifi.o \
 					   board-mapphone-gpio.o \
-					   board-mapphone-mmcprobe.o
+					   board-mapphone-mmcprobe.o \
+obj-$(CONFIG_MOT_FEAT_MDTV)             += board-mapphone-mdtv.o
+endif
 obj-$(CONFIG_MACH_OMAP_APOLLON)		+= board-apollon.o \
 					   board-apollon-mmc.o	\
 					   board-apollon-keys.o
diff --git a/arch/arm/mach-omap2/Makefile.boot b/arch/arm/mach-omap2/Makefile.boot
index f3558b3..dd30d9e 100644
--- a/arch/arm/mach-omap2/Makefile.boot
+++ b/arch/arm/mach-omap2/Makefile.boot
@@ -2,9 +2,13 @@
 params_phys-y		:= 0x80000100
 initrd_phys-y		:= 0x80800000
 
-  zreladdr-$(CONFIG_MACH_SHOLES_UMTS)  := 0x80c08000
-params_phys-$(CONFIG_MACH_SHOLES_UMTS) := 0x80c00100
-initrd_phys-$(CONFIG_MACH_SHOLES_UMTS) := 0x81400000
+  zreladdr-$(CONFIG_MACH_SHOLES_UMTS)   := 0x80c08000
+params_phys-$(CONFIG_MACH_SHOLES_UMTS)  := 0x80c00100
+initrd_phys-$(CONFIG_MACH_SHOLES_UMTS)  := 0x81400000
+
+  zreladdr-$(CONFIG_MACH_SHOLEST)       := 0x80c08000
+params_phys-$(CONFIG_MACH_SHOLEST)      := 0x80c00100
+initrd_phys-$(CONFIG_MACH_SHOLEST)      := 0x81400000
 
   zreladdr-$(CONFIG_MACH_MAPPHONE)	:= 0x80c08000
 params_phys-$(CONFIG_MACH_MAPPHONE)	:= 0x80c00100
diff --git a/arch/arm/mach-omap2/board-mapphone-camera.c b/arch/arm/mach-omap2/board-mapphone-camera.c
index 694ffc2..7a016b3 100644
--- a/arch/arm/mach-omap2/board-mapphone-camera.c
+++ b/arch/arm/mach-omap2/board-mapphone-camera.c
@@ -44,10 +44,6 @@
 #define CAM_IOMUX_SAFE_MODE (OMAP343X_PADCONF_PULL_UP | \
 				OMAP343X_PADCONF_PUD_ENABLED | \
 				OMAP343X_PADCONF_MUXMODE7)
-#define CAM_IOMUX_SAFE_MODE_INPUT (OMAP343X_PADCONF_INPUT_ENABLED | \
-				OMAP343X_PADCONF_PULL_UP | \
-				OMAP343X_PADCONF_PUD_ENABLED | \
-				OMAP343X_PADCONF_MUXMODE7)
 #define CAM_IOMUX_FUNC_MODE (OMAP343X_PADCONF_INPUT_ENABLED | \
 				OMAP343X_PADCONF_MUXMODE0)
 
@@ -239,30 +235,18 @@ struct mt9p012_platform_data mapphone_mt9p012_platform_data = {
 
 void mapphone_camera_lines_safe_mode(void)
 {
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x011a);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x011c);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x011e);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x0120);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0122);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0124);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0126);
 	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0128);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x012a);
-	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE_INPUT, 0x012c);
 }
 
 void mapphone_camera_lines_func_mode(void)
 {
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x011a);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x011c);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x011e);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0120);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0122);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0124);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0126);
 	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0128);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x012a);
-	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x012c);
 }
 
 void __init mapphone_camera_init(void)
diff --git a/arch/arm/mach-omap2/board-mapphone-keypad.c b/arch/arm/mach-omap2/board-mapphone-keypad.c
index 32c829b..af16e68 100644
--- a/arch/arm/mach-omap2/board-mapphone-keypad.c
+++ b/arch/arm/mach-omap2/board-mapphone-keypad.c
@@ -110,34 +110,11 @@ static const unsigned short mapphone_p3_keymap[ARRAY_SIZE(mapphone_col_gpios) *
 	[KEYMAP_INDEX(7, 7)] = KEY_W,
 };
 
-#ifndef CONFIG_ARM_OF
-static const unsigned short mapphone_keymap_closed[
-	ARRAY_SIZE(mapphone_col_gpios) * ARRAY_SIZE(mapphone_row_gpios)] = {
-	[KEYMAP_INDEX(0, 3)] = KEY_VOLUMEDOWN,
-	[KEYMAP_INDEX(0, 5)] = KEY_VOLUMEUP,
-	[KEYMAP_INDEX(4, 3)] = KEY_CAMERA-1,	/* camera 1 key, steal KEY_HP*/
-	[KEYMAP_INDEX(4, 5)] = KEY_CAMERA,	/* "camera 2" key */
-};
-#else
-static const unsigned short *mapphone_keymap_closed;
-#endif
-
-static int fixup(int index)
-{
-       int slide_open = gpio_get_value(GPIO_SLIDER);
-       if (!slide_open)
-		return mapphone_keymap_closed[index];
-       return 1;
-}
-
 static struct gpio_event_matrix_info mapphone_keypad_matrix_info = {
 	.info.func = gpio_event_matrix_func,
 	.keymap = mapphone_p3_keymap,
 	.output_gpios = mapphone_col_gpios,
 	.input_gpios = mapphone_row_gpios,
-#ifndef CONFIG_ARM_OF
-	.sw_fixup = fixup,
-#endif
 	.noutputs = ARRAY_SIZE(mapphone_col_gpios),
 	.ninputs = ARRAY_SIZE(mapphone_row_gpios),
 	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
@@ -231,12 +208,6 @@ static int __init mapphone_dt_kp_init(void)
 			mapphone_keypad_matrix_info.keymap = \
 				(unsigned short *)kp_prop;
 
-		kp_prop = of_get_property(kp_node, \
-				DT_PROP_KEYPAD_CLOSED_MAPS, NULL);
-		if (kp_prop) {
-			mapphone_keymap_closed = (unsigned short *)kp_prop;
-			mapphone_keypad_matrix_info.sw_fixup = fixup;
-		}
 		of_node_put(kp_node);
 	}
 
diff --git a/arch/arm/mach-omap2/board-mapphone-spi.c b/arch/arm/mach-omap2/board-mapphone-spi.c
index fe97d3b..72a8fd4 100644
--- a/arch/arm/mach-omap2/board-mapphone-spi.c
+++ b/arch/arm/mach-omap2/board-mapphone-spi.c
@@ -155,6 +155,10 @@ struct regulator_consumer_supply cpcap_vcsi_consumers[] = {
 	REGULATOR_CONSUMER("vdds_dsi", &mapphone_dss_device.dev),
 };
 
+struct regulator_consumer_supply cpcap_vwlan1_consumers[] = {
+	REGULATOR_CONSUMER("vwlan1", NULL /* cpcap_cam_device */),
+};
+
 struct regulator_consumer_supply cpcap_vwlan2_consumers[] = {
 	REGULATOR_CONSUMER("vwlan2", NULL /* sd slot */),
 };
@@ -307,6 +311,8 @@ static struct regulator_init_data cpcap_regulator[CPCAP_NUM_REGULATORS] = {
 			.max_uV			= 1900000,
 			.valid_ops_mask		= 0,
 		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan1_consumers),
+		.consumer_supplies	= cpcap_vwlan1_consumers,
 	},
 	[CPCAP_VWLAN2] = {
 		.constraints = {
diff --git a/arch/arm/mach-omap2/board-mapphone.c b/arch/arm/mach-omap2/board-mapphone.c
index 64adb1b..5102742 100644
--- a/arch/arm/mach-omap2/board-mapphone.c
+++ b/arch/arm/mach-omap2/board-mapphone.c
@@ -77,6 +77,22 @@
 #include <media/mt9p012.h>
 
 #endif
+#if defined(CONFIG_VIDEO_OV8810) || defined(CONFIG_VIDEO_OV8810_MODULE)
+#include <../drivers/media/video/ov8810.h>
+#include <../drivers/media/video/oldisp/ispcsi2.h>
+#define OV8810_CSI2_CLOCK_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA0_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA1_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_CLOCK_LANE		1	 /* Clock lane position: 1 */
+#define OV8810_CSI2_DATA0_LANE		2	 /* Data0 lane position: 2 */
+#define OV8810_CSI2_DATA1_LANE		3	 /* Data1 lane position: 3 */
+#define OV8810_CSI2_PHY_THS_TERM	1  /* GVH */
+#define OV8810_CSI2_PHY_THS_SETTLE	21  /* GVH */
+#define OV8810_CSI2_PHY_TCLK_TERM	0
+#define OV8810_CSI2_PHY_TCLK_MISS	1
+#define OV8810_CSI2_PHY_TCLK_SETTLE	14
+#endif
+
 #ifdef CONFIG_VIDEO_OMAP3_HPLENS
 #include <../drivers/media/video/hplens.h>
 #endif
@@ -581,6 +597,12 @@ static struct i2c_board_info __initdata mapphone_i2c_bus2_board_info[] = {
 };
 
 static struct i2c_board_info __initdata mapphone_i2c_bus3_board_info[] = {
+#if defined(CONFIG_VIDEO_OV8810)
+	{
+		I2C_BOARD_INFO("ov8810", OV8810_I2C_ADDR),
+		.platform_data = &mapphone_ov8810_platform_data,
+	},
+#endif
 	{
 		I2C_BOARD_INFO("lm3554_led", 0x53),
 		.platform_data = &mapphone_camera_flash,
diff --git a/arch/arm/mach-omap2/mux.c b/arch/arm/mach-omap2/mux.c
index 7b01036..2c901f7 100644
--- a/arch/arm/mach-omap2/mux.c
+++ b/arch/arm/mach-omap2/mux.c
@@ -702,10 +702,12 @@ MUX_CFG_34XX("C27_34XX_CAM_PCLK", 0x112,
 		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("C23_34XX_CAM_FLD", 0x114,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+#if !defined(CONFIG_VIDEO_MIPI_INTERFACE)
 MUX_CFG_34XX("AG17_34XX_CAM_D0", 0x116,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("AH17_34XX_CAM_D1", 0x118,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+#endif
 MUX_CFG_34XX("B24_34XX_CAM_D2", 0x11A,
 		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
 MUX_CFG_34XX("C24_34XX_CAM_D3", 0x11C,
@@ -732,8 +734,72 @@ MUX_CFG_34XX("B23_34XX_CAM_WEN", 0x130,
 		OMAP34XX_MUX_MODE2)
 MUX_CFG_34XX("D25_34XX_CAM_STROBE", 0x132,
 		OMAP34XX_MUX_MODE0)
-MUX_CFG_34XX("K8_34XX_GPMC_WAIT2", 0x0D0,
+MUX_CFG_34XX("K8_34XX_GPMC_WAIT2", 0x0D2,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("H2_34XX_GPMC_A3", 0x07E,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+
+/* MDTV off state */
+MUX_CFG_34XX("F1_34XX_MDTV_INT_OFF", 0x082,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AC3_34XX_MDTV_SIMO_OFF", 0x5DC,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD4_34XX_MDTV_SOMI_OFF", 0x5DE,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD3_34XX_MDTV_CS_OFF", 0x5E0,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AA3_34XX_MDTV_CLK_OFF", 0x5E2,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT)
+/* MDTV on state */
+MUX_CFG_34XX("F1_34XX_MDTV_INT_ON", 0x082,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
+MUX_CFG_34XX("AC3_34XX_MDTV_SIMO_ON", 0x5DC,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AD4_34XX_MDTV_SOMI_ON", 0x5DE,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT_PULLUP)
+MUX_CFG_34XX("AD3_34XX_MDTV_CS_ON", 0x5E0,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AA3_34XX_MDTV_CLK_ON", 0x5E2,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT_PULLUP)
+/* DSS */
+#ifdef CONFIG_PANEL_HDTV
+MUX_CFG_34XX("AG22_34XX_DSS_DATA0", 0xdc, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH22_34XX_DSS_DATA1", 0xde, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AG23_34XX_DSS_DATA2", 0xe0, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH23_34XX_DSS_DATA3", 0xe2, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AG24_34XX_DSS_DATA4", 0xe4, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH24_34XX_DSS_DATA5", 0xe6, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+#endif
+
+/* Touch IC state */
+MUX_CFG_34XX("D25_34XX_GPIO109", 0x12a,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+/* Linear Vib. En state */
+#ifdef CONFIG_VIB_PWM
+MUX_CFG_34XX("AF22_34XX_GPIO9_OUT", 0xa18,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+#endif
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+	/*MIPI Camra*/
+MUX_CFG_34XX("AG17_34XX_CAM_D0", 0x116,
+		OMAP34XX_MUX_MODE2 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AH17_34XX_CAM_D1", 0x118,
+		OMAP34XX_MUX_MODE2 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD17_34XX_CSI2_DX0", 0x134,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AE18_34XX_CSI2_DY0", 0x136,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD16_34XX_CSI2_DX1", 0x138,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AE17_34XX_CSI2_DY1", 0x13A,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+#endif/*CONFIG_VIDEO_MIPI_INTERFACE*/
 };
 
 #define OMAP34XX_PINS_SZ	ARRAY_SIZE(omap34xx_pins)
diff --git a/arch/arm/plat-omap/dma.c b/arch/arm/plat-omap/dma.c
index cd53b28..e9eb2d9 100755
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@ -673,13 +673,16 @@ static inline void disable_lnk(int lch)
 static inline void omap2_enable_irq_lch(int lch)
 {
 	u32 val;
+	unsigned long flags;
 
 	if (!cpu_class_is_omap2())
 		return;
 
+	spin_lock_irqsave(&dma_chan_lock, flags);
 	val = dma_read(IRQENABLE_L0);
 	val |= 1 << lch;
 	dma_write(val, IRQENABLE_L0);
+	spin_unlock_irqrestore(&dma_chan_lock, flags);
 }
 
 int omap_request_dma(int dev_id, const char *dev_name,
@@ -749,11 +752,13 @@ int omap_request_dma(int dev_id, const char *dev_name,
 	}
 
 	if (cpu_class_is_omap2()) {
+		spin_lock_irqsave(&dma_chan_lock, flags);
 		omap2_enable_irq_lch(free_ch);
 		omap_enable_channel_irq(free_ch);
 		/* Clear the CSR register and IRQ status register */
 		dma_write(OMAP2_DMA_CSR_CLEAR_MASK, CSR(free_ch));
 		dma_write(1 << free_ch, IRQSTATUS_L0);
+		spin_unlock_irqrestore(&dma_chan_lock, flags);
 	}
 
 	*dma_ch_out = free_ch;
@@ -788,10 +793,12 @@ void omap_free_dma(int lch)
 
 	if (cpu_class_is_omap2()) {
 		u32 val;
+		spin_lock_irqsave(&dma_chan_lock, flags);
 		/* Disable interrupts */
 		val = dma_read(IRQENABLE_L0);
 		val &= ~(1 << lch);
 		dma_write(val, IRQENABLE_L0);
+		spin_unlock_irqrestore(&dma_chan_lock, flags);
 
 		/* Clear the CSR register and IRQ status register */
 		dma_write(OMAP2_DMA_CSR_CLEAR_MASK, CSR(lch));
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdefs.h b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
index 78be880..9b7b2aa 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -305,6 +305,7 @@
 		PROC_INVALIDATE_MEM = 0,
 		PROC_WRITEBACK_MEM,
 		PROC_WRITEBACK_INVALIDATE_MEM,
+		PROC_WRBK_INV_ALL,
 	} ;
 
 /* Memory Segment Status Values */
diff --git a/arch/arm/plat-omap/include/dspbridge/mem.h b/arch/arm/plat-omap/include/dspbridge/mem.h
index 535ac3a..8d598f4 100644
--- a/arch/arm/plat-omap/include/dspbridge/mem.h
+++ b/arch/arm/plat-omap/include/dspbridge/mem.h
@@ -185,7 +185,7 @@
  *  Ensures:
  *      Cache is synchronized
  */
-	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType);
+	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType);
 
 /*
  *  ======== MEM_Free ========
diff --git a/arch/arm/plat-omap/include/mach/board-mapphone.h b/arch/arm/plat-omap/include/mach/board-mapphone.h
index 2a24113..08ffba0 100644
--- a/arch/arm/plat-omap/include/mach/board-mapphone.h
+++ b/arch/arm/plat-omap/include/mach/board-mapphone.h
@@ -50,6 +50,9 @@ extern void __init mapphone_mmcprobe_init(void);
 #if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
 extern struct mt9p012_platform_data mapphone_mt9p012_platform_data;
 #endif
+#if defined(CONFIG_VIDEO_OV8810)
+extern struct ov8810_platform_data mapphone_ov8810_platform_data;
+#endif
 #ifdef CONFIG_VIDEO_OMAP3_HPLENS
 extern struct hplens_platform_data mapphone_hplens_platform_data;
 #endif
diff --git a/arch/arm/plat-omap/include/mach/dt_path.h b/arch/arm/plat-omap/include/mach/dt_path.h
index cb7da66..1acc4da 100644
--- a/arch/arm/plat-omap/include/mach/dt_path.h
+++ b/arch/arm/plat-omap/include/mach/dt_path.h
@@ -59,6 +59,39 @@
 /* Touch Node */
 #define DT_PATH_TOUCH		"/System@0/I2C@0/TouchOBP@0"
 #define DT_PROP_TOUCH_KEYMAP	"touch_key_map"
+#define DT_PROP_TOUCH_I2C_ADDRESS       "i2c,address"
+#define DT_PROP_TOUCH_KEYMAP		"touch_key_map"
+#define DT_PROP_TOUCH_NUM_TOUCH_KEYS	"number_of_touch_keys"
+#define DT_PROP_TOUCH_FLAGS		"touchobp-flags"
+#define DT_PROP_TOUCH_ABS_MIN_X		"abs_min_x"
+#define DT_PROP_TOUCH_ABS_MAX_X		"abs_max_x"
+#define DT_PROP_TOUCH_ABS_MIN_Y		"abs_min_y"
+#define DT_PROP_TOUCH_ABS_MAX_Y		"abs_max_y"
+#define DT_PROP_TOUCH_ABS_MIN_P		"abs_min_p"
+#define DT_PROP_TOUCH_ABS_MAX_P		"abs_max_p"
+#define DT_PROP_TOUCH_ABS_MIN_W		"abs_min_w"
+#define DT_PROP_TOUCH_ABS_MAX_W		"abs_max_w"
+#define DT_PROP_TOUCH_FUZZ_X		"fuzz_x"
+#define DT_PROP_TOUCH_FUZZ_Y		"fuzz_y"
+#define DT_PROP_TOUCH_FUZZ_P		"fuzz_p"
+#define DT_PROP_TOUCH_FUZZ_W		"fuzz_w"
+#define DT_PROP_TOUCH_KEY_ARRAY_MAP	"key_array_map"
+#define DT_PROP_TOUCH_KEY_ARRAY_COUNT	"key_array_count"
+#define DT_PROP_TOUCH_T7		"obj_t7"	/* power_cfg */
+#define DT_PROP_TOUCH_T8		"obj_t8"	/* acquire_cfg */
+#define DT_PROP_TOUCH_T9		"obj_t9"	/* multi_touch_cfg */
+#define DT_PROP_TOUCH_T15		"obj_t15"	/* key_array */
+#define DT_PROP_TOUCH_T17		"obj_t17"	/* linear_tbl_cfg */
+#define DT_PROP_TOUCH_T19		"obj_t19"	/* gpio_pwm_cfg */
+#define DT_PROP_TOUCH_T20		"obj_t20"	/* grip_suppression_cfg */
+#define DT_PROP_TOUCH_T22		"obj_t22"	/* noise_suppression_cfg */
+#define DT_PROP_TOUCH_T24		"obj_t24"	/* one_touch_gesture_proc_cfg */
+#define DT_PROP_TOUCH_T25		"obj_t25"	/* self_test_cfg */
+#define DT_PROP_TOUCH_T27		"obj_t27"	/* two_touch_gesture_proc_cfg */
+#define DT_PROP_TOUCH_T28		"obj_t28"	/* cte_config_cfg */
+
+/* Accelerometer Node */
+#define DT_PATH_LIS331DLH	"/System@0/I2C@0/Accelerometer@0"
 
 /* GPIO Node */
 #define DT_PATH_GPIO        "/System@0/GPIO@0"
diff --git a/arch/arm/plat-omap/include/mach/hardware.h b/arch/arm/plat-omap/include/mach/hardware.h
index d55d28f..9a06f93 100644
--- a/arch/arm/plat-omap/include/mach/hardware.h
+++ b/arch/arm/plat-omap/include/mach/hardware.h
@@ -381,10 +381,15 @@
 #include "board-sx1.h"
 #endif
 
+#ifdef CONFIG_MACH_SHOLEST
+#include "board-sholest.h"
+#else /* !CONFIG_MACH_SHOLEST */
+
 #ifdef CONFIG_MACH_MAPPHONE
 #include "board-mapphone.h"
 #endif
 
+#endif
 #endif /* !__ASSEMBLER__ */
 
 #endif	/* __ASM_ARCH_OMAP_HARDWARE_H */
diff --git a/arch/arm/plat-omap/include/mach/mux.h b/arch/arm/plat-omap/include/mach/mux.h
index 98e0a00..3ecbb1a 100644
--- a/arch/arm/plat-omap/include/mach/mux.h
+++ b/arch/arm/plat-omap/include/mach/mux.h
@@ -923,8 +923,10 @@ enum omap34xx_index {
 	C25_34XX_CAM_XCLKA,
 	C27_34XX_CAM_PCLK,
 	C23_34XX_CAM_FLD,
+#ifndef CONFIG_VIDEO_MIPI_INTERFACE
 	AG17_34XX_CAM_D0,
 	AH17_34XX_CAM_D1,
+#endif
 	B24_34XX_CAM_D2,
 	C24_34XX_CAM_D3,
 	D24_34XX_CAM_D4,
@@ -939,7 +941,42 @@ enum omap34xx_index {
 	B23_34XX_CAM_WEN,
 	D25_34XX_CAM_STROBE,
 	K8_34XX_GPMC_WAIT2,
-
+	H2_34XX_GPMC_A3,
+
+	/* MDTV, INT&SPI */
+	F1_34XX_MDTV_INT_OFF,
+	AC3_34XX_MDTV_SIMO_OFF,
+	AD4_34XX_MDTV_SOMI_OFF,
+	AD3_34XX_MDTV_CS_OFF,
+	AA3_34XX_MDTV_CLK_OFF,
+	F1_34XX_MDTV_INT_ON,
+	AC3_34XX_MDTV_SIMO_ON,
+	AD4_34XX_MDTV_SOMI_ON,
+	AD3_34XX_MDTV_CS_ON,
+	AA3_34XX_MDTV_CLK_ON,
+
+	/* DSS */
+#ifdef CONFIG_PANEL_HDTV
+	AG22_34XX_DSS_DATA0,
+	AH22_34XX_DSS_DATA1,
+	AG23_34XX_DSS_DATA2,
+	AH23_34XX_DSS_DATA3,
+	AG24_34XX_DSS_DATA4,
+	AH24_34XX_DSS_DATA5,
+#endif
+	D25_34XX_GPIO109,
+#ifdef CONFIG_VIB_PWM
+	AF22_34XX_GPIO9_OUT,
+#endif
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+	/*MIPI Camra*/
+	AG17_34XX_CAM_D0,
+	AH17_34XX_CAM_D1,
+	AD17_34XX_CSI2_DX0,
+	AE18_34XX_CSI2_DY0,
+	AD16_34XX_CSI2_DX1,
+	AE17_34XX_CSI2_DY1,
+#endif/*CONFIG_VIDEO_MIPI_INTERFACE*/
 };
 
 struct omap_mux_cfg {
diff --git a/arch/arm/plat-omap/include/mach/oldisp_user.h b/arch/arm/plat-omap/include/mach/oldisp_user.h
index 510f324..18826b6 100644
--- a/arch/arm/plat-omap/include/mach/oldisp_user.h
+++ b/arch/arm/plat-omap/include/mach/oldisp_user.h
@@ -45,6 +45,13 @@
    _IOWR('V', BASE_VIDIOC_PRIVATE + 12, struct isprsz_coef)
 #define VIDIOC_PRIVATE_ISP_RSZ_CFG \
    _IOWR('V', BASE_VIDIOC_PRIVATE + 13, struct isprsz_coef)
+#define VIDIOC_PRIVATE_ISP_HARDPIPE_CLEAR \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct ispprv_run_hardpipe)
+#define VIDIOC_PRIVATE_ISP_CCDC_BAYER_CFG \
+   _IOWR('V', BASE_VIDIOC_PRIVATE + 15, struct ispccdc_color_offset)
+#define VIDIOC_PRIVATE_ISP_LSC_WORKAROUND_CFG \
+   _IOW('V', BASE_VIDIOC_PRIVATE + 16, int)
+
 
 /* AE/AWB related structures and flags*/
 
@@ -699,5 +706,8 @@ struct ispprv_run_hardpipe {
 	__u32 crop_height;
 };
 
+struct ispccdc_color_offset{
+	__u16 offsetcode;
+};
 
 #endif /* OMAP_ISP_USER_H */
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index cb574ec..47eafc3 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -745,7 +745,6 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
 {
 	/* Keep STATUS here for future additions to this function */
 	DSP_STATUS status = DSP_SOK;
-	enum DSP_FLUSHTYPE FlushMemType = PROC_WRITEBACK_INVALIDATE_MEM;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 	DBC_Require(cRefs > 0);
 
@@ -756,7 +755,7 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
 	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
 		/* Critical section */
 		(void)SYNC_EnterCS(hProcLock);
-		MEM_FlushCache(pMpuAddr, ulSize, FlushMemType);
+		MEM_FlushCache(pMpuAddr, ulSize, ulFlags);
 		(void)SYNC_LeaveCS(hProcLock);
 	} else {
 		status = DSP_EHANDLE;
@@ -1073,7 +1072,7 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor, IN CONST s32 iArgc,
 	struct DCD_MANAGER *hDCDHandle;
 	struct DMM_OBJECT *hDmmMgr;
 	u32 dwExtEnd;
-	u32 uProcId;
+	u32 uProcId = 0;
 #ifdef DEBUG
 	BRD_STATUS uBrdState;
 #endif
diff --git a/drivers/dsp/bridge/services/mem.c b/drivers/dsp/bridge/services/mem.c
index 47ec09b..3b4dca5 100644
--- a/drivers/dsp/bridge/services/mem.c
+++ b/drivers/dsp/bridge/services/mem.c
@@ -478,7 +478,7 @@ void MEM_Exit(void)
  *  Purpose:
  *      Flush cache
  */
-void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
+void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType)
 {
 	DBC_Require(cRefs > 0);
 
@@ -501,6 +501,10 @@ void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
 		outer_flush_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
 				  cBytes));
 	break;
+    /* Writeback and Invalidate all */
+	case PROC_WRBK_INV_ALL:
+		__cpuc_flush_kern_all();
+	break;
 	default:
 		GT_1trace(MEM_debugMask, GT_6CLASS, "MEM_FlushCache: invalid "
 			  "FlushMemType 0x%x\n", FlushType);
diff --git a/drivers/gpu/pvr/mem_debug.c b/drivers/gpu/pvr/mem_debug.c
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/omap3430/sysutils_linux.c b/drivers/gpu/pvr/omap3430/sysutils_linux.c
index dfa478b..2266e89 100644
--- a/drivers/gpu/pvr/omap3430/sysutils_linux.c
+++ b/drivers/gpu/pvr/omap3430/sysutils_linux.c
@@ -238,6 +238,8 @@ IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
 		return;
 	}
 
+	/* unpin the memory bus */
+	omap_pm_set_min_bus_tput(&gpsPVRLDMDev->dev, OCP_INITIATOR_AGENT, 0);
 
 	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
 
diff --git a/drivers/gpu/pvr/pdump_osfunc.h b/drivers/gpu/pvr/pdump_osfunc.h
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/sgx_mkif_km.h b/drivers/gpu/pvr/sgx_mkif_km.h
old mode 100755
new mode 100644
diff --git a/drivers/i2c/chips/Kconfig b/drivers/i2c/chips/Kconfig
index e1ad67a..a225c50 100644
--- a/drivers/i2c/chips/Kconfig
+++ b/drivers/i2c/chips/Kconfig
@@ -158,4 +158,12 @@ config SENSORS_PCA963X
 	 This driver can also be built as a module.  If so, the module
 	 will be called pca963X.
 
+##w21558, LP3907 regulator feature
+config MOT_FEAT_LP3907
+	tristate "LP3907 Voltage Regulator chip"
+	depends on I2C
+	help
+	  If you say yes or m here you get support for the National Semiconductor
+	  LP3907 Regulator driver.
+
 endmenu
diff --git a/drivers/i2c/chips/Makefile b/drivers/i2c/chips/Makefile
index c4877d9..05fff0e 100644
--- a/drivers/i2c/chips/Makefile
+++ b/drivers/i2c/chips/Makefile
@@ -21,7 +21,8 @@ obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 obj-$(CONFIG_TWL4030_POWEROFF)	+= twl4030-poweroff.o
 obj-$(CONFIG_TWL4030_MADC)	+= twl4030-madc.o
 obj-$(CONFIG_RTC_X1205_I2C)	+= x1205.o
-
+#w21558, Add LP3907 module
+obj-$(CONFIG_MOT_FEAT_LP3907)  += lp3907_i2c.o
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 8790ee4..b3f8b53 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -271,4 +271,12 @@ config INPUT_HALLEFFECT_BU52014HV
 	  effect sensor.
 
 	  If unsure, say N.
+
+config DISABLE_IRQ_WAKE_KPD
+	tristate "Disable IRQ wakeup on Keypad"
+	default y
+	help
+	  Say Y here if you wish not to let Keypad input wake up the phone
+	  from sleep state.
+
 endif
diff --git a/drivers/input/misc/gpio_matrix.c b/drivers/input/misc/gpio_matrix.c
index 10e1f86..c739615 100644
--- a/drivers/input/misc/gpio_matrix.c
+++ b/drivers/input/misc/gpio_matrix.c
@@ -269,11 +269,13 @@ static int gpio_keypad_request_irqs(struct gpio_kp *kp)
 				"irq %d\n", mi->input_gpios[i], irq);
 			goto err_request_irq_failed;
 		}
+#ifndef CONFIG_DISABLE_IRQ_WAKE_KPD
 		err = set_irq_wake(irq, 1);
 		if (err) {
 			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
 				"irq %d\n", mi->input_gpios[i], irq);
 		}
+#endif
 		disable_irq(irq);
 	}
 	return 0;
diff --git a/drivers/input/touchscreen/qtouch_obp_ts.c b/drivers/input/touchscreen/qtouch_obp_ts.c
index 77a49f7..0f311d3 100644
--- a/drivers/input/touchscreen/qtouch_obp_ts.c
+++ b/drivers/input/touchscreen/qtouch_obp_ts.c
@@ -66,8 +66,8 @@ struct qtouch_ts_data {
 	uint32_t			last_keystate;
 	uint16_t			eeprom_checksum;
 	uint8_t			    checksum_cnt;
-	int					x_delta;
-	int					y_delta;
+        int                             x_delta;
+        int                             y_delta;
 
 	/* Note: The message buffer is reused for reading different messages.
 	 * MUST enforce that there is no concurrent access to msg_buf. */
@@ -407,6 +407,35 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 			return ret;
 		}
 	}
+
+	/* configure the COM CONFIG support */
+	obj = find_obj(ts, QTM_OBJ_SPT_COM_CONFIG);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->com_cfg,
+					min(sizeof(ts->pdata->com_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the COM CONFIG config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the GPIO PWM support */
+	obj = find_obj(ts, QTM_OBJ_SPT_GPIO_PWM);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->gpio_pwm_cfg,
+					min(sizeof(ts->pdata->gpio_pwm_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the GPIO PWM config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	/* configure the grip suppression table */
 	obj = find_obj(ts, QTM_OBJ_PROCI_GRIPFACESUPPRESSION);
 	if (obj && obj->entry.num_inst > 0) {
@@ -421,6 +450,76 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 		}
 	}
 
+	/* configure noise suppression */
+	obj = find_obj(ts, QTM_OBJ_PROCG_NOISE_SUPPRESSION);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->noise_suppression_cfg,
+					min(sizeof(ts->pdata->noise_suppression_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the noise suppression config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the one touch gesture processor */
+	obj = find_obj(ts, QTM_OBJ_PROCI_ONE_TOUCH_GESTURE_PROC);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->one_touch_gesture_proc_cfg,
+					min(sizeof(ts->pdata->one_touch_gesture_proc_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the one touch gesture processor config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure self test */
+	obj = find_obj(ts, QTM_OBJ_SPT_SELF_TEST);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->self_test_cfg,
+					min(sizeof(ts->pdata->self_test_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the self test config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the two touch gesture processor */
+	obj = find_obj(ts, QTM_OBJ_PROCI_TWO_TOUCH_GESTURE_PROC);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->two_touch_gesture_proc_cfg,
+					min(sizeof(ts->pdata->two_touch_gesture_proc_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the two touch gesture processor config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the capacitive touch engine  */
+	obj = find_obj(ts, QTM_OBJ_SPT_CTE_CONFIG);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->cte_config_cfg,
+					min(sizeof(ts->pdata->cte_config_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the capacitive touch engine config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	/* configure the noise suppression table */
 	obj = find_obj(ts, QTM_OBJ_NOISESUPPRESSION_1);
 	if (obj && obj->entry.num_inst > 0) {
@@ -435,6 +534,20 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 		}
 	}
 
+	/* configure the user data table */
+	obj = find_obj(ts, QTM_OBJ_CPT_USERDATA);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->userdata,
+					min(sizeof(ts->pdata->userdata),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the user data\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	ret = qtouch_force_calibration(ts);
 	if (ret != 0) {
 		pr_err("%s: Unable to recalibrate after reset\n", __func__);
@@ -573,6 +686,12 @@ static int do_touch_multi_msg(struct qtouch_ts_data *ts, struct qtm_object *obj,
 	width = msg->touch_area;
 	pressure = msg->touch_amp;
 
+	if (ts->pdata->flags & QTOUCH_FLIP_X)
+		x = (ts->pdata->abs_max_x-1)-x;
+
+	if (ts->pdata->flags & QTOUCH_FLIP_Y)
+		y = (ts->pdata->abs_max_y-1)-y;
+
 	if (ts->pdata->flags & QTOUCH_SWAP_XY)
 		swap(x, y);
 
@@ -582,23 +701,23 @@ static int do_touch_multi_msg(struct qtouch_ts_data *ts, struct qtm_object *obj,
 
 	down = !(msg->status & QTM_TOUCH_MULTI_STATUS_RELEASE);
 
-	/* The chip may report erroneous points way
-	beyond what a user could possibly perform so we filter
-	these out */
-	if (ts->finger_data[finger].down &&
-			(abs(ts->finger_data[finger].x_data - x) > ts->x_delta ||
-			abs(ts->finger_data[finger].y_data - y) > ts->y_delta)) {
-				down = 0;
-				if (qtouch_tsdebug & 2)
-					pr_info("%s: x0 %i x1 %i y0 %i y1 %i\n",
-						__func__,
-						ts->finger_data[finger].x_data, x,
-						ts->finger_data[finger].y_data, y);
-	} else {
-		ts->finger_data[finger].x_data = x;
-		ts->finger_data[finger].y_data = y;
-		ts->finger_data[finger].w_data = width;
-	}
+        /* The chip may report erroneous points way
+        beyond what a user could possibly perform so we filter
+        these out */
+        if (ts->finger_data[finger].down &&
+                       (abs(ts->finger_data[finger].x_data - x) > ts->x_delta ||
+                       abs(ts->finger_data[finger].y_data - y) > ts->y_delta)) {
+                               down = 0;
+                               if (qtouch_tsdebug & 2)
+                                       pr_info("%s: x0 %i x1 %i y0 %i y1 %i\n",
+                                               __func__,
+                                               ts->finger_data[finger].x_data, x,
+                                               ts->finger_data[finger].y_data, y);
+        } else {
+               ts->finger_data[finger].x_data = x;
+               ts->finger_data[finger].y_data = y;
+               ts->finger_data[finger].w_data = width;
+        }
 
 	/* The touch IC will not give back a pressure of zero
 	   so send a 0 when a liftoff is produced */
@@ -758,6 +877,17 @@ static int qtouch_process_info_block(struct qtouch_ts_data *ts)
 	addr = QTM_OBP_ID_INFO_ADDR + sizeof(qtm_info);
 	report_id = 1;
 
+	/* Clear the object table */
+	for (i = 0; i < QTM_OBP_MAX_OBJECT_NUM; ++i) {
+		ts->obj_tbl[i].entry.type = 0;
+		ts->obj_tbl[i].entry.addr = 0;
+		ts->obj_tbl[i].entry.size = 0;
+		ts->obj_tbl[i].entry.num_inst = 0;
+		ts->obj_tbl[i].entry.num_rids = 0;
+		ts->obj_tbl[i].report_id_min = 0;
+		ts->obj_tbl[i].report_id_max = 0;
+	}
+
 	/* read out the object entries table */
 	for (i = 0; i < qtm_info.num_objs; ++i) {
 		struct qtm_object *obj;
@@ -846,6 +976,26 @@ static int qtouch_process_info_block(struct qtouch_ts_data *ts)
 
 	ts->eeprom_checksum = ts->pdata->nv_checksum;
 
+/*below: use different setting for vf.5 && vf.6*/
+	if ((qtm_info.family_id == 0x80) && \
+		((qtm_info.version == 0xf5) || \
+		(qtm_info.version == 0xf6) || \
+		(qtm_info.version == 0x12) || \
+		(qtm_info.version == 0x14))) {
+		printk(KERN_INFO "use setting for old touch firmware \n");
+		/* ts->pdata->power_cfg.active_acq_int = 0x0a; */
+
+		/* ts->pdata->acquire_cfg.touch_autocal = 0; */
+		/* ts->pdata->acquire_cfg.anti_cal_sthr = 0x14; */
+
+		ts->pdata->multi_touch_cfg.burst_len = 0x21;
+		/* ts->pdata->multi_touch_cfg.tch_det_thr = 0x25; */
+
+		/* ts->pdata->noise_suppression_cfg.gcaf_num_active = 0x03; */
+		/* ts->pdata->noise_suppression_cfg.gcaf_num_idle = 0; */
+
+		/* ts->pdata->cte_config_cfg.active_gcaf_depth = 0x10; */
+	}
 	return 0;
 
 err_no_checksum:
@@ -894,8 +1044,8 @@ static int qtouch_ts_probe(struct i2c_client *client,
 	ts->client = client;
 	i2c_set_clientdata(client, ts);
 	ts->checksum_cnt = 0;
-	ts->x_delta = ts->pdata->x_delta;
-	ts->y_delta = ts->pdata->y_delta;
+        ts->x_delta = ts->pdata->x_delta;
+        ts->y_delta = ts->pdata->y_delta;
 
 	ts->input_dev = input_allocate_device();
 	if (ts->input_dev == NULL) {
@@ -1052,6 +1202,10 @@ static int qtouch_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 	if (qtouch_tsdebug & 4)
 		pr_info("%s: Suspending\n", __func__);
 
+	ret = qtouch_power_config(ts, 0);
+	if (ret < 0)
+		pr_err("%s: Cannot write power config\n", __func__);
+
 	disable_irq_nosync(ts->client->irq);
 	ret = cancel_work_sync(&ts->work);
 	if (ret) { /* if work was pending disable-count is now 2 */
@@ -1059,10 +1213,6 @@ static int qtouch_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 		enable_irq(ts->client->irq);
 	}
 
-	ret = qtouch_power_config(ts, 0);
-	if (ret < 0)
-		pr_err("%s: Cannot write power config\n", __func__);
-
 	return 0;
 }
 
@@ -1091,14 +1241,32 @@ static int qtouch_ts_resume(struct i2c_client *client)
 	}
 	input_sync(ts->input_dev);
 
+	enable_irq(ts->client->irq);
+
 	ret = qtouch_power_config(ts, 1);
 	if (ret < 0) {
 		pr_err("%s: Cannot write power config\n", __func__);
 		return -EIO;
 	}
+
 	qtouch_force_reset(ts, 0);
 
-	enable_irq(ts->client->irq);
+	/* Below is a workaround for touch hang issue after toggling
+	   the power key */
+	ret = qtouch_force_calibration(ts);
+	if (ret != 0) {
+		pr_err("%s: Unable to recalibrate after reset\n", __func__);
+		return -EIO;
+	}
+	/* reset the address pointer */
+	ret = qtouch_set_addr(ts, ts->obj_tbl[QTM_OBJ_GEN_MSG_PROC].entry.addr);
+	if (ret != 0) {
+		pr_err("%s: Unable to reset address pointer after reset\n",
+		       __func__);
+		return -EIO;
+	}
+	msleep(50);
+
 	return 0;
 }
 
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index aecad1f..7e9955b 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -194,6 +194,12 @@ config LEDS_SHOLES
 	depends on LEDS_CLASS
 	help
 	  This option enables support for LEDs on Sholes.
+          
+config LEDS_SHOLEST
+	tristate "LED Support for Sholes Tablet device"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for LEDs on Sholes Tablet.
 
 config LEDS_LM3530
 	tristate "LM3530 ALS driver"
@@ -207,6 +213,32 @@ config LEDS_LM3554
 	help
 	  This option enables support for the LM3554 .
 
+config LEDS_BD7885
+	tristate "LED Support for BD7885 I2C chips"
+	depends on LEDS_CLASS && I2C
+	help
+	  This option enables support for LEDs connected to BD7885
+	  LED driver chips accessed via the I2C bus.  Supported
+
+config LEDS_BU9847
+	tristate "LED Support for BU9847 I2C chips"
+	depends on LEDS_CLASS && I2C
+	help
+	  This option enables support for LEDs connected to BU9847
+	  LED driver chips accessed via the I2C bus.  Supported
+
+config LEDS_AF_LED
+	tristate "LED Support for AF LED operatiion"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for LEDs connected to CPCAP.
+	  
+config LEDS_FLASH_RESET
+	tristate "LED Support for FLASH_RESET pin control"
+	depends on LEDS_CLASS && LEDS_BD7885
+	help
+	  This option enables support for LED's FLASH_RESET pin operation.
+
 comment "LED Triggers"
 
 config LEDS_TRIGGERS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 4597956..2c4d4c9 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -26,6 +26,9 @@ obj-$(CONFIG_LEDS_FSG)			+= leds-fsg.o
 obj-$(CONFIG_LEDS_PCA955X)		+= leds-pca955x.o
 obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
+obj-$(CONFIG_LEDS_BD7885)		+= leds-bd7885.o
+obj-$(CONFIG_LEDS_BU9847)		+= leds-bu9847.o
+obj-$(CONFIG_LEDS_AF_LED)		+= leds-ld-cpcap-afled.o
 obj-$(CONFIG_LEDS_SHOLES)		+= leds-ld-cpcap-disp.o \
 					   leds-ld-cpcap-rgb.o \
 					   leds-ld-cpcap-kpad.o
diff --git a/drivers/leds/led-lm3530.c b/drivers/leds/led-lm3530.c
index e5033e4..ca02bf5 100755
--- a/drivers/leds/led-lm3530.c
+++ b/drivers/leds/led-lm3530.c
@@ -190,6 +190,7 @@ static void ld_lm3530_brightness_set(struct led_classdev *led_cdev,
 	if (value == LED_OFF) {
 		als_data->led_on = 0;
 		brightness &= LD_LM3530_LAST_BRIGHTNESS_MASK;
+
 		if (lm3530_write_reg(als_data, LM3530_GEN_CONFIG, brightness)) {
 			pr_err("%s:writing failed while setting brightness:%d\n",
 				__func__, error);
@@ -198,13 +199,14 @@ static void ld_lm3530_brightness_set(struct led_classdev *led_cdev,
 	} else {
 		brightness |= 0x01;
 		if (lm3530_write_reg(als_data, LM3530_GEN_CONFIG, brightness)) {
-			pr_err("%s:writing failed while setting brightness:%d\n",
-				__func__, error);
-			return;
-		}
+                	pr_err("%s:writing failed while setting brightness:%d\n",
+                        	__func__, error);
+                        return;
+                }
+
 		if (lm3530_write_reg(als_data, LM3530_BRIGHTNESS_CTRL_REG,
-			value / 2)) {
-				pr_err("%s:Failed to set brightness:%d\n",
+						 value / 2)) {
+			pr_err("%s:Failed to set brightness:%d\n",
 				__func__, error);
 			return;
 		}
@@ -264,6 +266,7 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 			als_data->mode = -1;
 			return -1;
 		}
+
 		als_data->mode = AUTOMATIC;
 	} else {
 		als_data->mode = mode_value;
@@ -277,13 +280,15 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 			return -1;
 		}
 
-		if (lm3530_write_reg(als_data, LM3530_GEN_CONFIG, brightness)) {
+		if (lm3530_write_reg(als_data, LM3530_GEN_CONFIG,
+					 brightness)) {
 			pr_err("%s:writing failed while setting brightness:%d\n",
-				__func__, error);
+			       __func__, error);
 			return -1;
 		}
 
-		config = (mode_value == MANUAL ? 0 : als_data->als_pdata->als_resistor_sel);
+		config = (mode_value == MANUAL ? 0 :
+				als_data->als_pdata->als_resistor_sel);
 		lm3530_write_reg(als_data, LM3530_ALS_RESISTOR_SELECT, config);
 
 		error = lm3530_write_reg(als_data,
@@ -724,16 +729,17 @@ static int lm3530_resume(struct i2c_client *client)
 {
 	struct lm3530_data *als_data = i2c_get_clientdata(client);
 
-	if (lm3530_debug)
-		pr_info("%s: Resuming\n", __func__);
+        if (lm3530_debug)
+                pr_info("%s: Resuming\n", __func__);
 
-	/* Work around a HW issue that the HW will not generate an
-	interrupt when enabled */
-	queue_work(als_data->working_queue, &als_data->wq);
+        /* Work around a HW issue that the HW will not generate an
+        interrupt when enabled */
+        queue_work(als_data->working_queue, &als_data->wq);
 
-	return 0;
+        return 0;
 }
 
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void lm3530_early_suspend(struct early_suspend *handler)
 {
diff --git a/drivers/leds/leds-ld-cpcap-disp.c b/drivers/leds/leds-ld-cpcap-disp.c
index ecd5318..de69fb2 100755
--- a/drivers/leds/leds-ld-cpcap-disp.c
+++ b/drivers/leds/leds-ld-cpcap-disp.c
@@ -27,8 +27,10 @@
 struct disp_button_led_data {
 	struct led_classdev disp_button_class_dev;
 	struct cpcap_device *cpcap;
+#ifndef CONFIG_LEDS_SHOLEST
 	struct regulator *regulator;
 	int regulator_state;
+#endif
 };
 
 static void disp_button_set(struct led_classdev *led_cdev,
@@ -41,6 +43,10 @@ static void disp_button_set(struct led_classdev *led_cdev,
 			 disp_button_class_dev);
 
 	if (value > 0) {
+#ifdef CONFIG_LEDS_SHOLEST
+		brightness = (LD_BLED_CPCAP_DUTY_CYCLE |
+			LD_BLED_CPCAP_CURRENT | LD_DISP_BUTTON_ON);
+#else
 		brightness = (LD_DISP_BUTTON_DUTY_CYCLE |
 			LD_DISP_BUTTON_CURRENT | LD_DISP_BUTTON_ON);
 
@@ -49,34 +55,53 @@ static void disp_button_set(struct led_classdev *led_cdev,
 			regulator_enable(disp_button_led_data->regulator);
 			disp_button_led_data->regulator_state = 1;
 		}
+#endif
 
+#ifdef CONFIG_LEDS_SHOLEST
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_BLEDC,
+						  brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
 						  CPCAP_REG_KLC,
 						  brightness,
 						  LD_DISP_BUTTON_CPCAP_MASK);
-
+#endif
 		if (cpcap_status < 0)
 			pr_err("%s: Writing to the register failed for %i\n",
 			       __func__, cpcap_status);
 
 	} else {
+#ifndef CONFIG_LEDS_SHOLEST
 		if ((disp_button_led_data->regulator) &&
 		    (disp_button_led_data->regulator_state == 1)) {
 			regulator_disable(disp_button_led_data->regulator);
 			disp_button_led_data->regulator_state = 0;
 		}
+#endif
 		/* Due to a HW issue turn off the current then
 		turn off the duty cycle */
 		brightness = 0x01;
+#ifdef CONFIG_LEDS_SHOLEST
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
-					  CPCAP_REG_KLC, brightness,
-					  LD_DISP_BUTTON_CPCAP_MASK);
-
+						  CPCAP_REG_BLEDC, brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_KLC, brightness,
+						  LD_DISP_BUTTON_CPCAP_MASK);
+#endif
 		brightness = 0x00;
+#ifdef CONFIG_LEDS_SHOLEST
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_BLEDC, brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
 						  CPCAP_REG_KLC, brightness,
 						  LD_DISP_BUTTON_CPCAP_MASK);
-
+#endif
 		if (cpcap_status < 0)
 			pr_err("%s: Writing to the register failed for %i\n",
 			       __func__, cpcap_status);
@@ -104,6 +129,7 @@ static int disp_button_probe(struct platform_device *pdev)
 	info->cpcap = pdev->dev.platform_data;
 	platform_set_drvdata(pdev, info);
 
+#ifndef CONFIG_LEDS_SHOLEST
 	info->regulator = regulator_get(&pdev->dev, LD_SUPPLY);
 	if (IS_ERR(info->regulator)) {
 		pr_err("%s: Cannot get %s regulator\n", __func__, LD_SUPPLY);
@@ -113,6 +139,7 @@ static int disp_button_probe(struct platform_device *pdev)
 	}
 
 	info->regulator_state = 0;
+#endif
 
 	info->disp_button_class_dev.name = "button-backlight";
 	info->disp_button_class_dev.brightness_set = disp_button_set;
@@ -125,8 +152,10 @@ static int disp_button_probe(struct platform_device *pdev)
 	return ret;
 
 err_reg_button_class_failed:
+#ifndef CONFIG_LEDS_SHOLEST
 	if (info->regulator)
 		regulator_put(info->regulator);
+#endif
 exit_request_reg_failed:
 	kfree(info);
 	return ret;
@@ -136,8 +165,10 @@ static int disp_button_remove(struct platform_device *pdev)
 {
 	struct disp_button_led_data *info = platform_get_drvdata(pdev);
 
+#ifndef CONFIG_LEDS_SHOLEST
 	if (info->regulator)
 		regulator_put(info->regulator);
+#endif
 
 	led_classdev_unregister(&info->disp_button_class_dev);
 	return 0;
diff --git a/drivers/leds/leds-ld-cpcap-rgb.c b/drivers/leds/leds-ld-cpcap-rgb.c
index c0406c6..0b4131f 100755
--- a/drivers/leds/leds-ld-cpcap-rgb.c
+++ b/drivers/leds/leds-ld-cpcap-rgb.c
@@ -36,12 +36,20 @@ struct msg_ind_led_data {
 void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 				int color, enum led_brightness value)
 {
+#ifdef CONFIG_LEDS_SHOLEST
+	unsigned short brightness = LD_MSG_IND_LO_CURRENT | LD_MSG_IND_ON;
+#else
 	unsigned short brightness = LD_MSG_IND_CURRENT | LD_MSG_IND_ON;
+#endif
 	int cpcap_status = 0;
 	int cpcap_register = 0;
 
 	if (color & LD_LED_RED)
+#ifdef CONFIG_LEDS_SHOLEST
+        cpcap_register = CPCAP_REG_ADLC;
+#else
 		cpcap_register = CPCAP_REG_REDC;
+#endif
 	else if (color & LD_LED_GREEN)
 		cpcap_register = CPCAP_REG_GREENC;
 	else if (color & LD_LED_BLUE)
@@ -56,7 +64,25 @@ void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 					  LD_MSG_IND_CPCAP_MASK);
 
 		brightness = 0x00;
-	} else if (value <= 51)
+	}
+#ifdef CONFIG_LEDS_SHOLEST
+	else if (value <= 51)
+		brightness |= (LD_MSG_IND_LOW << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 104)
+		brightness |= (LD_MSG_IND_LOW_MED << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 155)
+		brightness |= (LD_MSG_IND_MEDIUM << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 201)
+		brightness |= (LD_MSG_IND_MED_HIGH << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else
+		brightness |= (LD_MSG_IND_HIGH << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+#else
+    else if (value <= 51)
 		brightness |= LD_MSG_IND_LOW;
 	else if (value <= 104)
 		brightness |= LD_MSG_IND_LOW_MED;
@@ -66,6 +92,7 @@ void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 		brightness |= LD_MSG_IND_MED_HIGH;
 	else
 		brightness |= LD_MSG_IND_HIGH;
+#endif
 
 	cpcap_status = cpcap_regacc_write(msg_ind_data->cpcap,
 					  cpcap_register, brightness,
diff --git a/drivers/media/dvb/siano/Kconfig b/drivers/media/dvb/siano/Kconfig
index dd863f2..80a4dfa 100644
--- a/drivers/media/dvb/siano/Kconfig
+++ b/drivers/media/dvb/siano/Kconfig
@@ -2,25 +2,68 @@
 # Siano Mobile Silicon Digital TV device configuration
 #
 
-config DVB_SIANO_SMS1XXX
-	tristate "Siano SMS1XXX USB dongle support"
-	depends on DVB_CORE && USB
+# w21558, SPI interface between OMAP and SMS1130
+config MOT_FEAT_SPI_SMS1130
+	bool "Siano and OMAP SPI interface support"
+	default n
+
+config SMS_SIANO_MDTV_TDMB
+	tristate "Siano SMS1xxx based MDTV receiver"
+	default n
+	---help---
+	Choose Y or M here if you have MDTV receiver with a Siano chipset.
+	To compile this driver as a module, choose M here
+	(The modules will be called smsmdtv).
+	Note: All dependents, if selected, will be part of this module.
+	Further documentation on this driver can be found on the WWW at http://www.siano-ms.com/
+
+if SMS_SIANO_MDTV_TDMB
+menu "Siano module components"
+
+# Kernel sub systems support
+
+config SMS_DVB3_SUBSYS
+	bool "DVB v.3 Subsystem support"
+	default n
+	---help---
+	Choose
+
+config SMS_HOSTLIB_SUBSYS
+	bool "Host Library Subsystem support."
+	default n
+	---help---
+	Choose if you would like to have Siano's host library kernel sub-system support.
+
+if SMS_HOSTLIB_SUBSYS
+
+config SMS_NET_SUBSYS
+	bool "Siano Network Adapter"
+	default n
 	---help---
-	  Choose Y here if you have a USB dongle with a SMS1XXX chipset.
+	Choose if you would like to have Siano's network adapter support.
+
+endif # SMS_HOSTLIB_SUBSYS
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called sms1xxx.
+# Hardware interfaces support
 
-config DVB_SIANO_SMS1XXX_SMS_IDS
-	bool "Enable support for Siano Mobile Silicon default USB IDs"
-	depends on DVB_SIANO_SMS1XXX
-	default y
+config SMS_SPI_DRV
+	bool "SPI interface support"
+	default n
 	---help---
-	  Choose Y here if you have a USB dongle with a SMS1XXX chipset
-	  that uses Siano Mobile Silicon's default usb vid:pid.
+	Choose if you would like to have Siano's support for OMAP34XX SPI interface
+
+config SMS_USB_DRV
+        bool "USB inteface support"
+        default n
+        ---help---
+        Choose
 
-	  Choose N here if you would prefer to use Siano's external driver.
+config SMS_SDIO_DRV
+        bool "SDIO interface support"
+        default n
+        ---help---
+        Choose
 
-	  Further documentation on this driver can be found on the WWW at
-	  <http://www.siano-ms.com/>.
+endmenu
+endif # SMS_SIANO_MDTV_TDMB
 
diff --git a/drivers/media/dvb/siano/Makefile b/drivers/media/dvb/siano/Makefile
index ee0737a..f2fcbc0 100644
--- a/drivers/media/dvb/siano/Makefile
+++ b/drivers/media/dvb/siano/Makefile
@@ -1,8 +1,42 @@
-sms1xxx-objs := smscoreapi.o smsusb.o smsdvb.o sms-cards.o
+#sms1xxx-objs := smscoreapi.o smsusb.o smsdvb.o sms-cards.o
 
-obj-$(CONFIG_DVB_SIANO_SMS1XXX) += sms1xxx.o
+#obj-$(CONFIG_DVB_SIANO_SMS1XXX) += sms1xxx.o
 
-EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
+#EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 
-EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
+#EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
+###############################################################################
+#
+# Siano Mobile Silicon, Inc.
+# MDTV receiver kernel modules.
+# Copyright (C) 2006-2008, Uri Shkolnik
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+###############################################################################
 
+#Local variables initailization
+MODULE_NAME = smsmdtv
+
+SMSOBJ := smscoreapi.o sms-cards.o smsendian.o smsir.o
+
+EXTRA_CFLAGS += -DSMS_HOSTLIB_SUBSYS
+SMSOBJ += smschar.o
+
+EXTRA_CFLAGS += -DSMS_SPI_DRV
+SMSOBJ += smsspilog.o smsspicommon.o smsspiphy_omap34xx.o
+
+smsmdtv-objs := $(SMSOBJ)
+
+obj-m := smsmdtv.o
diff --git a/drivers/media/dvb/siano/sms-cards.c b/drivers/media/dvb/siano/sms-cards.c
index 4307e4e..27ccb97 100644
--- a/drivers/media/dvb/siano/sms-cards.c
+++ b/drivers/media/dvb/siano/sms-cards.c
@@ -18,9 +18,9 @@
  */
 
 #include "sms-cards.h"
+#include "smsir.h"
 
 struct usb_device_id smsusb_id_table[] = {
-#ifdef CONFIG_DVB_SIANO_SMS1XXX_SMS_IDS
 	{ USB_DEVICE(0x187f, 0x0010),
 		.driver_info = SMS1XXX_BOARD_SIANO_STELLAR },
 	{ USB_DEVICE(0x187f, 0x0100),
@@ -31,7 +31,6 @@ struct usb_device_id smsusb_id_table[] = {
 		.driver_info = SMS1XXX_BOARD_SIANO_NOVA_B },
 	{ USB_DEVICE(0x187f, 0x0300),
 		.driver_info = SMS1XXX_BOARD_SIANO_VEGA },
-#endif
 	{ USB_DEVICE(0x2040, 0x1700),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_CATAMOUNT },
 	{ USB_DEVICE(0x2040, 0x1800),
@@ -60,167 +59,265 @@ struct usb_device_id smsusb_id_table[] = {
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
 	{ USB_DEVICE(0x2040, 0x5590),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
-	{ }		/* Terminating entry */
-};
+	{ USB_DEVICE(0x187f, 0x0202),
+		.driver_info = SMS1XXX_BOARD_SIANO_NICE },
+	{ USB_DEVICE(0x187f, 0x0301),
+		.driver_info = SMS1XXX_BOARD_SIANO_VENICE },
+	{ } /* Terminating entry */
+	};
+
 MODULE_DEVICE_TABLE(usb, smsusb_id_table);
 
 static struct sms_board sms_boards[] = {
 	[SMS_BOARD_UNKNOWN] = {
-		.name	= "Unknown board",
+	/* 0 */
+		.name = "Unknown board",
 	},
 	[SMS1XXX_BOARD_SIANO_STELLAR] = {
-		.name	= "Siano Stellar Digital Receiver",
-		.type	= SMS_STELLAR,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-stellar-dvbt-01.fw",
+	/* 1 */
+		.name =
+		"Siano Stellar Digital Receiver",
+		.type = SMS_STELLAR,
 	},
 	[SMS1XXX_BOARD_SIANO_NOVA_A] = {
-		.name	= "Siano Nova A Digital Receiver",
-		.type	= SMS_NOVA_A0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-a-dvbt-01.fw",
+	/* 2 */
+		.name = "Siano Nova A Digital Receiver",
+		.type = SMS_NOVA_A0,
 	},
 	[SMS1XXX_BOARD_SIANO_NOVA_B] = {
-		.name	= "Siano Nova B Digital Receiver",
-		.type	= SMS_NOVA_B0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-b-dvbt-01.fw",
+	/* 3 */
+		.name = "Siano Nova B Digital Receiver",
+		.type = SMS_NOVA_B0,
 	},
 	[SMS1XXX_BOARD_SIANO_VEGA] = {
-		.name	= "Siano Vega Digital Receiver",
-		.type	= SMS_VEGA,
+	/* 4 */
+		.name = "Siano Vega Digital Receiver",
+		.type = SMS_VEGA,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_CATAMOUNT] = {
-		.name	= "Hauppauge Catamount",
-		.type	= SMS_STELLAR,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-stellar-dvbt-01.fw",
+	/* 5 */
+		.name = "Hauppauge Catamount",
+		.type = SMS_STELLAR,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-stellar-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_OKEMO_A] = {
-		.name	= "Hauppauge Okemo-A",
-		.type	= SMS_NOVA_A0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-a-dvbt-01.fw",
+	/* 6 */
+		.name = "Hauppauge Okemo-A",
+		.type = SMS_NOVA_A0,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-nova-a-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_OKEMO_B] = {
-		.name	= "Hauppauge Okemo-B",
-		.type	= SMS_NOVA_B0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-b-dvbt-01.fw",
+	/* 7 */
+		.name = "Hauppauge Okemo-B",
+		.type = SMS_NOVA_B0,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-nova-b-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_WINDHAM] = {
-		.name	= "Hauppauge WinTV MiniStick",
-		.type	= SMS_NOVA_B0,
+	/* 8 */
+		.name = "Hauppauge WinTV MiniStick",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.led_power = 26,
-		.led_lo    = 27,
-		.led_hi    = 28,
+		.board_cfg.leds_power = 26,
+		.board_cfg.led0 = 27,
+		.board_cfg.led1 = 28,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD] = {
-		.name	= "Hauppauge WinTV MiniCard",
-		.type	= SMS_NOVA_B0,
+	/* 9 */
+		.name = "Hauppauge WinTV MiniCard",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.lna_ctrl  = 29,
+		.board_cfg.foreign_lna0_ctrl = 29,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2] = {
-		.name	= "Hauppauge WinTV MiniCard",
-		.type	= SMS_NOVA_B0,
+	/* 10 */
+		.name = "Hauppauge WinTV MiniCard",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.lna_ctrl  = -1,
+		.board_cfg.foreign_lna0_ctrl = 1,
+	},
+	[SMS1XXX_BOARD_SIANO_NICE] = {
+	/* 11 */
+		.name = "Siano Nice Digital Receiver",
+		.type = SMS_NOVA_B0,
+	},
+	[SMS1XXX_BOARD_SIANO_VENICE] = {
+	/* 12 */
+		.name = "Siano Venice Digital Receiver",
+		.type = SMS_VEGA,
 	},
 };
 
 struct sms_board *sms_get_board(int id)
 {
 	BUG_ON(id >= ARRAY_SIZE(sms_boards));
-
 	return &sms_boards[id];
 }
 
-static int sms_set_gpio(struct smscore_device_t *coredev, int pin, int enable)
-{
-	int lvl, ret;
-	u32 gpio;
-	struct smscore_gpio_config gpioconfig = {
-		.direction            = SMS_GPIO_DIRECTION_OUTPUT,
-		.pullupdown           = SMS_GPIO_PULLUPDOWN_NONE,
-		.inputcharacteristics = SMS_GPIO_INPUTCHARACTERISTICS_NORMAL,
-		.outputslewrate       = SMS_GPIO_OUTPUTSLEWRATE_FAST,
-		.outputdriving        = SMS_GPIO_OUTPUTDRIVING_4mA,
-	};
-
-	if (pin == 0)
-		return -EINVAL;
-
-	if (pin < 0) {
-		/* inverted gpio */
-		gpio = pin * -1;
-		lvl = enable ? 0 : 1;
-	} else {
-		gpio = pin;
-		lvl = enable ? 1 : 0;
-	}
-
-	ret = smscore_configure_gpio(coredev, gpio, &gpioconfig);
-	if (ret < 0)
-		return ret;
-
-	return smscore_set_gpio(coredev, gpio, lvl);
+static inline void sms_gpio_assign_11xx_default_led_config(
+		struct smscore_gpio_config *pGpioConfig) {
+	pGpioConfig->Direction = SMS_GPIO_DIRECTION_OUTPUT;
+	pGpioConfig->InputCharacteristics =
+		SMS_GPIO_INPUTCHARACTERISTICS_NORMAL;
+	pGpioConfig->OutputDriving = SMS_GPIO_OUTPUTDRIVING_4mA;
+	pGpioConfig->OutputSlewRate = SMS_GPIO_OUTPUTSLEWRATE_0_45_V_NS;
+	pGpioConfig->PullUpDown = SMS_GPIO_PULLUPDOWN_NONE;
 }
 
-int sms_board_setup(struct smscore_device_t *coredev)
-{
+int sms_board_event(struct smscore_device_t *coredev,
+		enum SMS_BOARD_EVENTS gevent) {
 	int board_id = smscore_get_board_id(coredev);
 	struct sms_board *board = sms_get_board(board_id);
+	struct smscore_gpio_config MyGpioConfig;
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		/* turn off all LEDs */
-		sms_set_gpio(coredev, board->led_power, 0);
-		sms_set_gpio(coredev, board->led_hi, 0);
-		sms_set_gpio(coredev, board->led_lo, 0);
-		break;
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
-		/* turn off LNA */
-		sms_set_gpio(coredev, board->lna_ctrl, 0);
-		break;
-	}
-	return 0;
-}
+	sms_gpio_assign_11xx_default_led_config(&MyGpioConfig);
 
-int sms_board_power(struct smscore_device_t *coredev, int onoff)
-{
-	int board_id = smscore_get_board_id(coredev);
-	struct sms_board *board = sms_get_board(board_id);
+	switch (gevent) {
+	case BOARD_EVENT_POWER_INIT: /* including hotplug */
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			/* set I/O and turn off all LEDs */
+			smscore_gpio_configure(coredev,
+					board->board_cfg.leds_power,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.leds_power, 0);
+			smscore_gpio_configure(coredev, board->board_cfg.led0,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.led0, 0);
+			smscore_gpio_configure(coredev, board->board_cfg.led1,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			/* set I/O and turn off LNA */
+			smscore_gpio_configure(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					0);
+			break;
+		}
+		break; /* BOARD_EVENT_BIND */
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		/* power LED */
-		sms_set_gpio(coredev,
-			     board->led_power, onoff ? 1 : 0);
-		break;
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
-		/* LNA */
-		sms_set_gpio(coredev,
-			     board->lna_ctrl, onoff ? 1 : 0);
-		break;
-	}
-	return 0;
-}
+	case BOARD_EVENT_POWER_SUSPEND:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.leds_power, 0);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led0, 0);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					0);
+			break;
+		}
+		break; /* BOARD_EVENT_POWER_SUSPEND */
 
-int sms_board_led_feedback(struct smscore_device_t *coredev, int led)
-{
-	int board_id = smscore_get_board_id(coredev);
-	struct sms_board *board = sms_get_board(board_id);
+	case BOARD_EVENT_POWER_RESUME:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.leds_power, 1);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led0, 1);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					1);
+			break;
+		}
+		break; /* BOARD_EVENT_POWER_RESUME */
 
-	/* dont touch GPIO if LEDs are already set */
-	if (smscore_led_state(coredev, -1) == led)
-		return 0;
+	case BOARD_EVENT_BIND:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.leds_power, 1);
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.led0, 1);
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					1);
+			break;
+		}
+		break; /* BOARD_EVENT_BIND */
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		sms_set_gpio(coredev,
-			     board->led_lo, (led & SMS_LED_LO) ? 1 : 0);
-		sms_set_gpio(coredev,
-			     board->led_hi, (led & SMS_LED_HI) ? 1 : 0);
+	case BOARD_EVENT_SCAN_PROG:
+		break; /* BOARD_EVENT_SCAN_PROG */
+	case BOARD_EVENT_SCAN_COMP:
+		break; /* BOARD_EVENT_SCAN_COMP */
+	case BOARD_EVENT_EMERGENCY_WARNING_SIGNAL:
+		break; /* BOARD_EVENT_EMERGENCY_WARNING_SIGNAL */
+	case BOARD_EVENT_FE_LOCK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+			board->board_cfg.led1, 1);
+			break;
+		}
+		break; /* BOARD_EVENT_FE_LOCK */
+	case BOARD_EVENT_FE_UNLOCK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		}
+		break; /* BOARD_EVENT_FE_UNLOCK */
+	case BOARD_EVENT_DEMOD_LOCK:
+		break; /* BOARD_EVENT_DEMOD_LOCK */
+	case BOARD_EVENT_DEMOD_UNLOCK:
+		break; /* BOARD_EVENT_DEMOD_UNLOCK */
+	case BOARD_EVENT_RECEPTION_MAX_4:
+		break; /* BOARD_EVENT_RECEPTION_MAX_4 */
+	case BOARD_EVENT_RECEPTION_3:
+		break; /* BOARD_EVENT_RECEPTION_3 */
+	case BOARD_EVENT_RECEPTION_2:
+		break; /* BOARD_EVENT_RECEPTION_2 */
+	case BOARD_EVENT_RECEPTION_1:
+		break; /* BOARD_EVENT_RECEPTION_1 */
+	case BOARD_EVENT_RECEPTION_LOST_0:
+		break; /* BOARD_EVENT_RECEPTION_LOST_0 */
+	case BOARD_EVENT_MULTIPLEX_OK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 1);
+			break;
+		}
+		break; /* BOARD_EVENT_MULTIPLEX_OK */
+	case BOARD_EVENT_MULTIPLEX_ERRORS:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		}
+		break; /* BOARD_EVENT_MULTIPLEX_ERRORS */
 
-		smscore_led_state(coredev, led);
+	default:
+		sms_err("Unknown SMS board event");
 		break;
 	}
 	return 0;
diff --git a/drivers/media/dvb/siano/sms-cards.h b/drivers/media/dvb/siano/sms-cards.h
index 8e0fe9f..7a6c82e 100644
--- a/drivers/media/dvb/siano/sms-cards.h
+++ b/drivers/media/dvb/siano/sms-cards.h
@@ -22,6 +22,7 @@
 
 #include <linux/usb.h>
 #include "smscoreapi.h"
+#include "smsir.h"
 
 #define SMS_BOARD_UNKNOWN 0
 #define SMS1XXX_BOARD_SIANO_STELLAR 1
@@ -34,25 +35,76 @@
 #define SMS1XXX_BOARD_HAUPPAUGE_WINDHAM 8
 #define SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD 9
 #define SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2 10
+#define SMS1XXX_BOARD_SIANO_NICE	11
+#define SMS1XXX_BOARD_SIANO_VENICE	12
+
+struct sms_board_gpio_cfg {
+	int lna_vhf_exist;
+	int lna_vhf_ctrl;
+	int lna_uhf_exist;
+	int lna_uhf_ctrl;
+	int lna_uhf_d_ctrl;
+	int lna_sband_exist;
+	int lna_sband_ctrl;
+	int lna_sband_d_ctrl;
+	int foreign_lna0_ctrl;
+	int foreign_lna1_ctrl;
+	int foreign_lna2_ctrl;
+	int rf_switch_vhf;
+	int rf_switch_uhf;
+	int rf_switch_sband;
+	int leds_power;
+	int led0;
+	int led1;
+	int led2;
+	int led3;
+	int led4;
+	int ir;
+	int eeprom_wp;
+	int mrc_sense;
+	int mrc_pdn_resetn;
+	int mrc_gp0; /* mrcs spi int */
+	int mrc_gp1;
+	int mrc_gp2;
+	int mrc_gp3;
+	int mrc_gp4;
+	int host_spi_gsp_ts_int;
+};
 
 struct sms_board {
 	enum sms_device_type_st type;
 	char *name, *fw[DEVICE_MODE_MAX];
-
-	/* gpios */
-	int led_power, led_hi, led_lo, lna_ctrl;
+	struct sms_board_gpio_cfg board_cfg;
+	enum ir_kb_type ir_kb_type;
 };
 
 struct sms_board *sms_get_board(int id);
 
-int sms_board_setup(struct smscore_device_t *coredev);
+extern struct usb_device_id smsusb_id_table[];
+extern struct smscore_device_t *coredev;
 
-#define SMS_LED_OFF 0
-#define SMS_LED_LO  1
-#define SMS_LED_HI  2
-int sms_board_led_feedback(struct smscore_device_t *coredev, int led);
-int sms_board_power(struct smscore_device_t *coredev, int onoff);
+enum SMS_BOARD_EVENTS {
+	BOARD_EVENT_POWER_INIT,
+	BOARD_EVENT_POWER_SUSPEND,
+	BOARD_EVENT_POWER_RESUME,
+	BOARD_EVENT_BIND,
+	BOARD_EVENT_SCAN_PROG,
+	BOARD_EVENT_SCAN_COMP,
+	BOARD_EVENT_EMERGENCY_WARNING_SIGNAL,
+	BOARD_EVENT_FE_LOCK,
+	BOARD_EVENT_FE_UNLOCK,
+	BOARD_EVENT_DEMOD_LOCK,
+	BOARD_EVENT_DEMOD_UNLOCK,
+	BOARD_EVENT_RECEPTION_MAX_4,
+	BOARD_EVENT_RECEPTION_3,
+	BOARD_EVENT_RECEPTION_2,
+	BOARD_EVENT_RECEPTION_1,
+	BOARD_EVENT_RECEPTION_LOST_0,
+	BOARD_EVENT_MULTIPLEX_OK,
+	BOARD_EVENT_MULTIPLEX_ERRORS
+};
 
-extern struct usb_device_id smsusb_id_table[];
+int sms_board_event(struct smscore_device_t *coredev,
+		enum SMS_BOARD_EVENTS gevent);
 
 #endif /* __SMS_CARDS_H__ */
diff --git a/drivers/media/dvb/siano/smscoreapi.c b/drivers/media/dvb/siano/smscoreapi.c
index cf613f2..6e03a5f 100644
--- a/drivers/media/dvb/siano/smscoreapi.c
+++ b/drivers/media/dvb/siano/smscoreapi.c
@@ -1,25 +1,23 @@
-/*
- *  Siano core API module
- *
- *  This file contains implementation for the interface to sms core component
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+/****************************************************************
+
+ Siano Mobile Silicon, Inc.
+ MDTV receiver kernel modules.
+ Copyright (C) 2006-2008, Uri Shkolnik
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ ****************************************************************/
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -28,16 +26,41 @@
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
 #include <linux/io.h>
-
+#include <linux/uaccess.h>
 #include <linux/firmware.h>
+#include <linux/wait.h>
+
+#include <asm/byteorder.h>
 
 #include "smscoreapi.h"
+#include "smsendian.h"
 #include "sms-cards.h"
+#include "smsir.h"
+
+#define MAX_GPIO_PIN_NUMBER	31
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10)
+/*#define REQUEST_FIRMWARE_SUPPORTED*/
+#undef REQUEST_FIRMWARE_SUPPORTED
+/*#define DEFAULT_FW_FILE_PATH "/system/mdtv"*/
+#define DEFAULT_FW_FILE_PATH "/system/etc/firmware"
+#else
+/*#define DEFAULT_FW_FILE_PATH "/lib/firmware"*/
+/*#define DEFAULT_FW_FILE_PATH "/system/mdtv"*/
+#define DEFAULT_FW_FILE_PATH "/system/etc/firmware"
+#endif
+
+/* Debug level is low */
+int sms_debug = 7;
 
-int sms_debug;
 module_param_named(debug, sms_debug, int, 0644);
 MODULE_PARM_DESC(debug, "set debug level (info=1, adv=2 (or-able))");
 
+/*##w21558, mode change : 4 --> 2*/
+static int default_mode = DEVICE_MODE_DAB_TDMB;
+module_param(default_mode, int, 0644);
+MODULE_PARM_DESC(default_mode, "default firmware id (device mode)");
+
 struct smscore_device_notifyee_t {
 	struct list_head entry;
 	hotplug_t hotplug;
@@ -45,53 +68,17 @@ struct smscore_device_notifyee_t {
 
 struct smscore_idlist_t {
 	struct list_head entry;
-	int		id;
-	int		data_type;
+	int id;
+	int data_type;
 };
 
 struct smscore_client_t {
 	struct list_head entry;
 	struct smscore_device_t *coredev;
-	void			*context;
-	struct list_head 	idlist;
-	onresponse_t	onresponse_handler;
-	onremove_t		onremove_handler;
-};
-
-struct smscore_device_t {
-	struct list_head entry;
-
-	struct list_head clients;
-	struct list_head subclients;
-	spinlock_t		clientslock;
-
-	struct list_head buffers;
-	spinlock_t		bufferslock;
-	int				num_buffers;
-
-	void			*common_buffer;
-	int				common_buffer_size;
-	dma_addr_t		common_buffer_phys;
-
-	void			*context;
-	struct device	*device;
-
-	char			devpath[32];
-	unsigned long	device_flags;
-
-	setmode_t		setmode_handler;
-	detectmode_t	detectmode_handler;
-	sendrequest_t	sendrequest_handler;
-	preload_t		preload_handler;
-	postload_t		postload_handler;
-
-	int				mode, modes_supported;
-
-	struct completion version_ex_done, data_download_done, trigger_done;
-	struct completion init_device_done, reload_start_done, resume_done;
-
-	int board_id;
-	int led_state;
+	void *context;
+	struct list_head idlist;
+	onresponse_t onresponse_handler;
+	onremove_t onremove_handler;
 };
 
 void smscore_set_board_id(struct smscore_device_t *core, int id)
@@ -99,13 +86,6 @@ void smscore_set_board_id(struct smscore_device_t *core, int id)
 	core->board_id = id;
 }
 
-int smscore_led_state(struct smscore_device_t *core, int led)
-{
-	if (led >= 0)
-		core->led_state = led;
-	return core->led_state;
-}
-
 int smscore_get_board_id(struct smscore_device_t *core)
 {
 	return core->board_id;
@@ -113,9 +93,9 @@ int smscore_get_board_id(struct smscore_device_t *core)
 
 struct smscore_registry_entry_t {
 	struct list_head entry;
-	char			devpath[32];
-	int				mode;
-	enum sms_device_type_st	type;
+	char devpath[32];
+	int mode;
+	enum sms_device_type_st type;
 };
 
 static struct list_head g_smscore_notifyees;
@@ -125,29 +105,22 @@ static struct mutex g_smscore_deviceslock;
 static struct list_head g_smscore_registry;
 static struct mutex g_smscore_registrylock;
 
-static int default_mode = 4;
-
-module_param(default_mode, int, 0644);
-MODULE_PARM_DESC(default_mode, "default firmware id (device mode)");
-
 static struct smscore_registry_entry_t *smscore_find_registry(char *devpath)
 {
 	struct smscore_registry_entry_t *entry;
 	struct list_head *next;
 
 	kmutex_lock(&g_smscore_registrylock);
-	for (next = g_smscore_registry.next;
-	     next != &g_smscore_registry;
-	     next = next->next) {
+	for (next = g_smscore_registry.next; next != &g_smscore_registry; next
+			= next->next) {
 		entry = (struct smscore_registry_entry_t *) next;
 		if (!strcmp(entry->devpath, devpath)) {
 			kmutex_unlock(&g_smscore_registrylock);
 			return entry;
 		}
 	}
-	entry = (struct smscore_registry_entry_t *)
-			kmalloc(sizeof(struct smscore_registry_entry_t),
-				GFP_KERNEL);
+	entry = /* (struct smscore_registry_entry_t *) */kmalloc(
+			sizeof(struct smscore_registry_entry_t), GFP_KERNEL);
 	if (entry) {
 		entry->mode = default_mode;
 		strcpy(entry->devpath, devpath);
@@ -196,8 +169,7 @@ void smscore_registry_setmode(char *devpath, int mode)
 }
 
 static void smscore_registry_settype(char *devpath,
-				     enum sms_device_type_st type)
-{
+		enum sms_device_type_st type) {
 	struct smscore_registry_entry_t *entry;
 
 	entry = smscore_find_registry(devpath);
@@ -207,16 +179,12 @@ static void smscore_registry_settype(char *devpath,
 		sms_err("No registry found.");
 }
 
-
 static void list_add_locked(struct list_head *new, struct list_head *head,
-			    spinlock_t *lock)
-{
+		spinlock_t *lock) {
 	unsigned long flags;
 
 	spin_lock_irqsave(lock, flags);
-
 	list_add(new, head);
-
 	spin_unlock_irqrestore(lock, flags);
 }
 
@@ -234,16 +202,16 @@ int smscore_register_hotplug(hotplug_t hotplug)
 	struct list_head *next, *first;
 	int rc = 0;
 
+	sms_info(" entering... smscore_register_hotplug \n");
 	kmutex_lock(&g_smscore_deviceslock);
 
 	notifyee = kmalloc(sizeof(struct smscore_device_notifyee_t),
-			   GFP_KERNEL);
+		GFP_KERNEL);
 	if (notifyee) {
 		/* now notify callback about existing devices */
 		first = &g_smscore_devices;
-		for (next = first->next;
-		     next != first && !rc;
-		     next = next->next) {
+		for (next = first->next; next != first && !rc;
+			next = next->next) {
 			struct smscore_device_t *coredev =
 				(struct smscore_device_t *) next;
 			rc = hotplug(coredev, coredev->device, 1);
@@ -272,13 +240,15 @@ void smscore_unregister_hotplug(hotplug_t hotplug)
 {
 	struct list_head *next, *first;
 
+	sms_info(" exiting... smscore_register_hotplug \n");
+
 	kmutex_lock(&g_smscore_deviceslock);
 
 	first = &g_smscore_notifyees;
 
 	for (next = first->next; next != first;) {
 		struct smscore_device_notifyee_t *notifyee =
-			(struct smscore_device_notifyee_t *) next;
+				(struct smscore_device_notifyee_t *) next;
 		next = next->next;
 
 		if (notifyee->hotplug == hotplug) {
@@ -302,8 +272,7 @@ static void smscore_notify_clients(struct smscore_device_t *coredev)
 }
 
 static int smscore_notify_callbacks(struct smscore_device_t *coredev,
-				    struct device *device, int arrival)
-{
+		struct device *device, int arrival) {
 	struct list_head *next, *first;
 	int rc = 0;
 
@@ -313,7 +282,7 @@ static int smscore_notify_callbacks(struct smscore_device_t *coredev,
 
 	for (next = first->next; next != first; next = next->next) {
 		rc = ((struct smscore_device_notifyee_t *) next)->
-				hotplug(coredev, device, arrival);
+			 hotplug(coredev, device, arrival);
 		if (rc < 0)
 			break;
 	}
@@ -321,12 +290,10 @@ static int smscore_notify_callbacks(struct smscore_device_t *coredev,
 	return rc;
 }
 
-static struct
-smscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,
-				       dma_addr_t common_buffer_phys)
-{
-	struct smscore_buffer_t *cb =
-		kmalloc(sizeof(struct smscore_buffer_t), GFP_KERNEL);
+static struct smscore_buffer_t *smscore_createbuffer(u8 *buffer,
+		void *common_buffer, dma_addr_t common_buffer_phys) {
+	struct smscore_buffer_t *cb = kmalloc(sizeof(struct smscore_buffer_t),
+			GFP_KERNEL);
 	if (!cb) {
 		sms_info("kmalloc(...) failed");
 		return NULL;
@@ -350,11 +317,11 @@ smscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,
  * @return 0 on success, <0 on error.
  */
 int smscore_register_device(struct smsdevice_params_t *params,
-			    struct smscore_device_t **coredev)
-{
+		struct smscore_device_t **coredev) {
 	struct smscore_device_t *dev;
 	u8 *buffer;
 
+	sms_info(" entering....smscore_register_device \n");
 	dev = kzalloc(sizeof(struct smscore_device_t), GFP_KERNEL);
 	if (!dev) {
 		sms_info("kzalloc(...) failed");
@@ -372,31 +339,42 @@ int smscore_register_device(struct smsdevice_params_t *params,
 	spin_lock_init(&dev->clientslock);
 	spin_lock_init(&dev->bufferslock);
 
-	/* init completion events */
+	/* Device protocol completion events */
 	init_completion(&dev->version_ex_done);
 	init_completion(&dev->data_download_done);
 	init_completion(&dev->trigger_done);
 	init_completion(&dev->init_device_done);
 	init_completion(&dev->reload_start_done);
 	init_completion(&dev->resume_done);
+	init_completion(&dev->gpio_configuration_done);
+	init_completion(&dev->gpio_set_level_done);
+	init_completion(&dev->gpio_get_level_done);
+	init_completion(&dev->ir_init_done);
+
+	/* Buffer management */
+	init_waitqueue_head(&dev->buffer_mng_waitq);
 
 	/* alloc common buffer */
+	sms_info(" entering...alloc common buffer \n");
 	dev->common_buffer_size = params->buffer_size * params->num_buffers;
+
+/* w21558 */
+#if defined(MOT_FEAT_OMAP_DMA_USE)
 	dev->common_buffer = dma_alloc_coherent(NULL, dev->common_buffer_size,
-						&dev->common_buffer_phys,
-						GFP_KERNEL | GFP_DMA);
+			&dev->common_buffer_phys, GFP_KERNEL | GFP_DMA);
 	if (!dev->common_buffer) {
 		smscore_unregister_device(dev);
 		return -ENOMEM;
 	}
+#endif
 
 	/* prepare dma buffers */
-	for (buffer = dev->common_buffer;
-	     dev->num_buffers < params->num_buffers;
-	     dev->num_buffers++, buffer += params->buffer_size) {
-		struct smscore_buffer_t *cb =
-			smscore_createbuffer(buffer, dev->common_buffer,
-					     dev->common_buffer_phys);
+	sms_info("entering... prepare dma buffers \n");
+	for (buffer = dev->common_buffer; dev->num_buffers <
+			params->num_buffers; dev->num_buffers++, buffer
+			+= params->buffer_size) {
+		struct smscore_buffer_t *cb = smscore_createbuffer(buffer,
+				dev->common_buffer, dev->common_buffer_phys);
 		if (!cb) {
 			smscore_unregister_device(dev);
 			return -ENOMEM;
@@ -428,7 +406,70 @@ int smscore_register_device(struct smsdevice_params_t *params,
 
 	*coredev = dev;
 
-	sms_info("device %p created", dev);
+	sms_info("device %p created\n", dev);
+
+	return 0;
+}
+
+static int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,
+		void *buffer, size_t size, struct completion *completion) {
+	int rc = coredev->sendrequest_handler(coredev->context, buffer, size);
+	if (rc < 0) {
+		sms_info("sendrequest returned error %d", rc);
+		return rc;
+	}
+
+	return wait_for_completion_timeout(completion,
+			msecs_to_jiffies(SMS_PROTOCOL_MAX_RAOUNDTRIP_MS)) ? 0 : -ETIME;
+}
+
+/**
+ * Starts & enables IR operations
+ *
+ * @return 0 on success, < 0 on error.
+ */
+static int smscore_init_ir(struct smscore_device_t *coredev)
+{
+	int ir_io;
+	int rc;
+	void *buffer;
+
+	coredev->ir.input_dev = NULL;
+	ir_io = sms_get_board(smscore_get_board_id(coredev))->board_cfg.ir;
+	if (ir_io) {/* only if IR port exist we use IR sub-module */
+		sms_info("IR loading");
+		rc = sms_ir_init(coredev);
+
+		if	(rc != 0)
+			sms_err("Error initialization DTV IR sub-module");
+		else {
+			buffer = kmalloc(sizeof(struct SmsMsgData_ST2) +
+						SMS_DMA_ALIGNMENT,
+						GFP_KERNEL | GFP_DMA);
+			if (buffer) {
+				struct SmsMsgData_ST2 *msg =
+				(struct SmsMsgData_ST2 *)
+				SMS_ALIGN_ADDRESS(buffer);
+
+				SMS_INIT_MSG(&msg->xMsgHeader,
+						MSG_SMS_START_IR_REQ,
+						sizeof(struct SmsMsgData_ST2));
+				msg->msgData[0] = coredev->ir.controller;
+				msg->msgData[1] = coredev->ir.timeout;
+
+				smsendian_handle_tx_message(
+					(struct SmsMsgHdr_ST2 *)msg);
+				rc = smscore_sendrequest_and_wait(coredev, msg,
+						msg->xMsgHeader. msgLength,
+						&coredev->ir_init_done);
+
+				kfree(buffer);
+			} else
+				sms_err
+				("Sending IR initialization message failed");
+		}
+	} else
+		sms_info("IR port has not been detected");
 
 	return 0;
 }
@@ -443,16 +484,22 @@ int smscore_register_device(struct smsdevice_params_t *params,
  */
 int smscore_start_device(struct smscore_device_t *coredev)
 {
-	int rc = smscore_set_device_mode(
-			coredev, smscore_registry_getmode(coredev->devpath));
+	int rc;
+
+	sms_info("%p starting......\n", coredev);
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	rc = smscore_set_device_mode(coredev, smscore_registry_getmode(
+			coredev->devpath));
 	if (rc < 0) {
-		sms_info("set device mode faile , rc %d", rc);
+		sms_info("set device mode failed , rc %d", rc);
 		return rc;
 	}
+#endif
 
 	kmutex_lock(&g_smscore_deviceslock);
 
 	rc = smscore_notify_callbacks(coredev, coredev->device, 1);
+	smscore_init_ir(coredev);
 
 	sms_info("device %p started, rc %d", coredev, rc);
 
@@ -461,32 +508,21 @@ int smscore_start_device(struct smscore_device_t *coredev)
 	return rc;
 }
 
-static int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,
-					void *buffer, size_t size,
-					struct completion *completion)
-{
-	int rc = coredev->sendrequest_handler(coredev->context, buffer, size);
-	if (rc < 0) {
-		sms_info("sendrequest returned error %d", rc);
-		return rc;
-	}
-
-	return wait_for_completion_timeout(completion,
-					   msecs_to_jiffies(10000)) ?
-						0 : -ETIME;
-}
-
 static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
-					 void *buffer, size_t size)
-{
+		void *buffer, size_t size) {
 	struct SmsFirmware_ST *firmware = (struct SmsFirmware_ST *) buffer;
 	struct SmsMsgHdr_ST *msg;
-	u32 mem_address = firmware->StartAddress;
+	u32 mem_address;
 	u8 *payload = firmware->Payload;
 	int rc = 0;
 
+	firmware->StartAddress = le32_to_cpu(firmware->StartAddress);
+	firmware->Length = le32_to_cpu(firmware->Length);
+
+	mem_address = firmware->StartAddress;
+
 	sms_info("loading FW to addr 0x%x size %d",
-		 mem_address, firmware->Length);
+			mem_address, firmware->Length);
 	if (coredev->preload_handler) {
 		rc = coredev->preload_handler(coredev->context);
 		if (rc < 0)
@@ -501,35 +537,35 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
 	if (coredev->mode != DEVICE_MODE_NONE) {
 		sms_debug("sending reload command.");
 		SMS_INIT_MSG(msg, MSG_SW_RELOAD_START_REQ,
-			     sizeof(struct SmsMsgHdr_ST));
-		rc = smscore_sendrequest_and_wait(coredev, msg,
-						  msg->msgLength,
-						  &coredev->reload_start_done);
+				sizeof(struct SmsMsgHdr_ST));
+		smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+		rc = smscore_sendrequest_and_wait(coredev, msg, msg->msgLength,
+				&coredev->reload_start_done);
 		mem_address = *(u32 *) &payload[20];
 	}
 
 	while (size && rc >= 0) {
 		struct SmsDataDownload_ST *DataMsg =
-			(struct SmsDataDownload_ST *) msg;
-		int payload_size = min((int) size, SMS_MAX_PAYLOAD_SIZE);
+				(struct SmsDataDownload_ST *) msg;
+		int payload_size = min((int)size, SMS_MAX_PAYLOAD_SIZE);
 
 		SMS_INIT_MSG(msg, MSG_SMS_DATA_DOWNLOAD_REQ,
-			     (u16)(sizeof(struct SmsMsgHdr_ST) +
-				      sizeof(u32) + payload_size));
+				(u16) (sizeof(struct SmsMsgHdr_ST) +
+						sizeof(u32) + payload_size));
 
 		DataMsg->MemAddr = mem_address;
 		memcpy(DataMsg->Payload, payload, payload_size);
 
+		smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 		if ((coredev->device_flags & SMS_ROM_NO_RESPONSE) &&
-		    (coredev->mode == DEVICE_MODE_NONE))
-			rc = coredev->sendrequest_handler(
-				coredev->context, DataMsg,
-				DataMsg->xMsgHeader.msgLength);
+				(coredev->mode	== DEVICE_MODE_NONE)) {
+			rc = coredev->sendrequest_handler(coredev->context, DataMsg,
+					DataMsg->xMsgHeader. msgLength);
+		}
 		else
-			rc = smscore_sendrequest_and_wait(
-				coredev, DataMsg,
-				DataMsg->xMsgHeader.msgLength,
-				&coredev->data_download_done);
+			rc = smscore_sendrequest_and_wait(coredev, DataMsg,
+					DataMsg->xMsgHeader. msgLength,
+					&coredev->data_download_done);
 
 		payload += payload_size;
 		size -= payload_size;
@@ -539,47 +575,48 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
 	if (rc >= 0) {
 		if (coredev->mode == DEVICE_MODE_NONE) {
 			struct SmsMsgData_ST *TriggerMsg =
-				(struct SmsMsgData_ST *) msg;
+					(struct SmsMsgData_ST *) msg;
 
 			SMS_INIT_MSG(msg, MSG_SMS_SWDOWNLOAD_TRIGGER_REQ,
-				     sizeof(struct SmsMsgHdr_ST) +
-				     sizeof(u32) * 5);
+					sizeof(struct SmsMsgHdr_ST) +
+					sizeof(u32) * 5);
 
 			TriggerMsg->msgData[0] = firmware->StartAddress;
-						/* Entry point */
+			/* Entry point */
 			TriggerMsg->msgData[1] = 5; /* Priority */
 			TriggerMsg->msgData[2] = 0x200; /* Stack size */
 			TriggerMsg->msgData[3] = 0; /* Parameter */
 			TriggerMsg->msgData[4] = 4; /* Task ID */
 
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 			if (coredev->device_flags & SMS_ROM_NO_RESPONSE) {
-				rc = coredev->sendrequest_handler(
-					coredev->context, TriggerMsg,
+				rc = coredev->sendrequest_handler(coredev->
+					context, TriggerMsg,
 					TriggerMsg->xMsgHeader.msgLength);
+
 				msleep(100);
 			} else
-				rc = smscore_sendrequest_and_wait(
-					coredev, TriggerMsg,
+				rc = smscore_sendrequest_and_wait(coredev,
+					TriggerMsg,
 					TriggerMsg->xMsgHeader.msgLength,
 					&coredev->trigger_done);
+
 		} else {
 			SMS_INIT_MSG(msg, MSG_SW_RELOAD_EXEC_REQ,
-				     sizeof(struct SmsMsgHdr_ST));
-
-			rc = coredev->sendrequest_handler(coredev->context,
-							  msg, msg->msgLength);
+					sizeof(struct SmsMsgHdr_ST));
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+			rc = coredev->sendrequest_handler(coredev->context, msg,
+					msg->msgLength);
 		}
 		msleep(500);
 	}
 
-	sms_debug("rc=%d, postload=%p ", rc,
-		  coredev->postload_handler);
+	sms_debug("rc=%d, postload=%p ", rc, coredev->postload_handler);
 
 	kfree(msg);
 
 	return ((rc >= 0) && coredev->postload_handler) ?
-		coredev->postload_handler(coredev->context) :
-		rc;
+			coredev->postload_handler(coredev->context) : rc;
 }
 
 /**
@@ -593,15 +630,16 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
  * @return 0 on success, <0 on error.
  */
 static int smscore_load_firmware_from_file(struct smscore_device_t *coredev,
-					   char *filename,
-					   loadfirmware_t loadfirmware_handler)
-{
+		char *filename, loadfirmware_t loadfirmware_handler) {
 	int rc = -ENOENT;
+	u8 *fw_buf = NULL;
+	u32 fw_buf_size = 0;
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
 	const struct firmware *fw;
-	u8 *fw_buffer;
 
-	if (loadfirmware_handler == NULL && !(coredev->device_flags &
-					      SMS_DEVICE_FAMILY2))
+	if (loadfirmware_handler == NULL && !(coredev->device_flags
+			& SMS_DEVICE_FAMILY2))
 		return -EINVAL;
 
 	rc = request_firmware(&fw, filename, coredev->device);
@@ -610,26 +648,38 @@ static int smscore_load_firmware_from_file(struct smscore_device_t *coredev,
 		return rc;
 	}
 	sms_info("read FW %s, size=%zd", filename, fw->size);
-	fw_buffer = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),
-			    GFP_KERNEL | GFP_DMA);
-	if (fw_buffer) {
-		memcpy(fw_buffer, fw->data, fw->size);
-
-		rc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?
-		      smscore_load_firmware_family2(coredev,
-						    fw_buffer,
-						    fw->size) :
-		      loadfirmware_handler(coredev->context,
-					   fw_buffer, fw->size);
-
-		kfree(fw_buffer);
-	} else {
+	printk(KERN_INFO "read FW %s, size=%zd\n", filename, fw->size);
+	fw_buf = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),
+				GFP_KERNEL | GFP_DMA);
+	if (!fw_buf) {
 		sms_info("failed to allocate firmware buffer");
-		rc = -ENOMEM;
+		return -ENOMEM;
 	}
+	memcpy(fw_buf, fw->data, fw->size);
+	fw_buf_size = fw->size;
+#else
+	if (!coredev->fw_buf) {
+		sms_info("missing fw file buffer");
+		return -EINVAL;
+	}
+	fw_buf = coredev->fw_buf;
+	fw_buf_size = coredev->fw_buf_size;
+	sms_info("fw_buf_size = %d\n", fw_buf_size);
+#endif
 
-	release_firmware(fw);
+	rc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?
+		smscore_load_firmware_family2(coredev, fw_buf, fw_buf_size)
+		: loadfirmware_handler(coredev->context, fw_buf,
+		fw_buf_size);
 
+	kfree(fw_buf);
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	release_firmware(fw);
+#else
+	coredev->fw_buf = NULL;
+	coredev->fw_buf_size = 0;
+#endif
 	return rc;
 }
 
@@ -650,6 +700,9 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 
 	kmutex_lock(&g_smscore_deviceslock);
 
+	/* Release input device (IR) resources */
+	sms_ir_exit(coredev);
+
 	smscore_notify_clients(coredev);
 	smscore_notify_callbacks(coredev, NULL, 0);
 
@@ -657,20 +710,23 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 	 * onresponse must no longer be called */
 
 	while (1) {
-		while ((cb = smscore_getbuffer(coredev))) {
+		while (!list_empty(&coredev->buffers)) {
+			cb = (struct smscore_buffer_t *) coredev->buffers.next;
+			list_del(&cb->entry);
 			kfree(cb);
 			num_buffers++;
 		}
 		if (num_buffers == coredev->num_buffers)
 			break;
+
 		if (++retry > 10) {
 			sms_info("exiting although "
-				 "not all buffers released.");
+					"not all buffers released.");
 			break;
 		}
 
 		sms_info("waiting for %d buffer(s)",
-			 coredev->num_buffers - num_buffers);
+				coredev->num_buffers - num_buffers);
 		msleep(100);
 	}
 
@@ -678,8 +734,10 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 
 	if (coredev->common_buffer)
 		dma_free_coherent(NULL, coredev->common_buffer_size,
-				  coredev->common_buffer,
-				  coredev->common_buffer_phys);
+			coredev->common_buffer, coredev->common_buffer_phys);
+
+	if (coredev->fw_buf != NULL)
+		kfree(coredev->fw_buf);
 
 	list_del(&coredev->entry);
 	kfree(coredev);
@@ -689,33 +747,35 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 	sms_info("device %p destroyed", coredev);
 }
 
+/*##w21558, Removed.*/
+/*
 static int smscore_detect_mode(struct smscore_device_t *coredev)
 {
 	void *buffer = kmalloc(sizeof(struct SmsMsgHdr_ST) + SMS_DMA_ALIGNMENT,
-			       GFP_KERNEL | GFP_DMA);
+			GFP_KERNEL | GFP_DMA);
 	struct SmsMsgHdr_ST *msg =
-		(struct SmsMsgHdr_ST *) SMS_ALIGN_ADDRESS(buffer);
+			(struct SmsMsgHdr_ST *) SMS_ALIGN_ADDRESS(buffer);
 	int rc;
 
 	if (!buffer)
 		return -ENOMEM;
 
 	SMS_INIT_MSG(msg, MSG_SMS_GET_VERSION_EX_REQ,
-		     sizeof(struct SmsMsgHdr_ST));
+			sizeof(struct SmsMsgHdr_ST));
 
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 	rc = smscore_sendrequest_and_wait(coredev, msg, msg->msgLength,
-					  &coredev->version_ex_done);
+			&coredev->version_ex_done);
 	if (rc == -ETIME) {
 		sms_err("MSG_SMS_GET_VERSION_EX_REQ failed first try");
 
 		if (wait_for_completion_timeout(&coredev->resume_done,
-						msecs_to_jiffies(5000))) {
-			rc = smscore_sendrequest_and_wait(
-				coredev, msg, msg->msgLength,
-				&coredev->version_ex_done);
+				msecs_to_jiffies(5000))) {
+			rc = smscore_sendrequest_and_wait(coredev, msg,
+				msg->msgLength, &coredev->version_ex_done);
 			if (rc < 0)
 				sms_err("MSG_SMS_GET_VERSION_EX_REQ failed "
-					"second try, rc %d", rc);
+						"second try, rc %d", rc);
 		} else
 			rc = -ETIME;
 	}
@@ -724,30 +784,27 @@ static int smscore_detect_mode(struct smscore_device_t *coredev)
 
 	return rc;
 }
+*/
 
 static char *smscore_fw_lkup[][SMS_NUM_OF_DEVICE_TYPES] = {
-	/*Stellar		NOVA A0		Nova B0		VEGA*/
-	/*DVBT*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*DVBH*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*TDMB*/
-	{"none", "tdmb_nova_12mhz.inp", "none", "none"},
-	/*DABIP*/
-	{"none", "none", "none", "none"},
-	/*BDA*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*ISDBT*/
-	{"none", "isdbt_nova_12mhz.inp", "dvb_nova_12mhz.inp", "none"},
-	/*ISDBTBDA*/
-	{"none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none"},
-	/*CMMB*/
-	{"none", "none", "none", "cmmb_vega_12mhz.inp"}
-};
-
-static inline char *sms_get_fw_name(struct smscore_device_t *coredev,
-				    int mode, enum sms_device_type_st type)
-{
+/*Stellar               NOVA A0         Nova B0         VEGA */
+/*DVBT*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*DVBH*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*TDMB*/
+{ "none", "tdmb_nova_12mhz.inp", "tdmb_nova_12mhz_b0.inp", "none" },
+/*DABIP*/{ "none", "none", "none", "none" },
+/*BDA*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*ISDBT*/
+{ "none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none" },
+/*ISDBTBDA*/
+{ "none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none" },
+/*CMMB*/{ "none", "none", "none", "cmmb_vega_12mhz.inp" } };
+
+static inline char *sms_get_fw_name(struct smscore_device_t *coredev, int mode,
+		enum sms_device_type_st type) {
 	char **fw = sms_get_board(smscore_get_board_id(coredev))->fw;
 	return (fw && fw[mode]) ? fw[mode] : smscore_fw_lkup[mode][type];
 }
@@ -764,11 +821,15 @@ static inline char *sms_get_fw_name(struct smscore_device_t *coredev,
  */
 int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 {
+/*##w21558, Removed*/
+/*
 	void *buffer;
+*/
 	int rc = 0;
 	enum sms_device_type_st type;
 
 	sms_debug("set device mode to %d", mode);
+	printk(KERN_INFO "%s: set device mode to %d\n", __func__, mode);
 	if (coredev->device_flags & SMS_DEVICE_FAMILY2) {
 		if (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_RAW_TUNER) {
 			sms_err("invalid mode specified %d", mode);
@@ -777,6 +838,8 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 
 		smscore_registry_setmode(coredev->devpath, mode);
 
+/*##w21558, Removed*/
+/*
 		if (!(coredev->device_flags & SMS_DEVICE_NOT_READY)) {
 			rc = smscore_detect_mode(coredev);
 			if (rc < 0) {
@@ -784,9 +847,11 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 				return rc;
 			}
 		}
+*/
 
 		if (coredev->mode == mode) {
 			sms_info("device mode %d already set", mode);
+			printk(KERN_INFO "device mode %d already set", mode);
 			return 0;
 		}
 
@@ -797,50 +862,54 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 			fw_filename = sms_get_fw_name(coredev, mode, type);
 
 			rc = smscore_load_firmware_from_file(coredev,
-							     fw_filename, NULL);
+					fw_filename, NULL);
 			if (rc < 0) {
 				sms_warn("error %d loading firmware: %s, "
-					 "trying again with default firmware",
-					 rc, fw_filename);
+					"trying again with default firmware",
+					rc, fw_filename);
 
 				/* try again with the default firmware */
 				fw_filename = smscore_fw_lkup[mode][type];
 				rc = smscore_load_firmware_from_file(coredev,
-							     fw_filename, NULL);
+						fw_filename, NULL);
 
 				if (rc < 0) {
 					sms_warn("error %d loading "
-						 "firmware: %s", rc,
-						 fw_filename);
+							"firmware: %s", rc,
+							fw_filename);
 					return rc;
 				}
 			}
-			sms_log("firmware download success: %s", fw_filename);
+			sms_info("firmware download success: %s", fw_filename);
 		} else
 			sms_info("mode %d supported by running "
-				 "firmware", mode);
+					"firmware", mode);
 
+/*##w21558, Removed*/
+/*
 		buffer = kmalloc(sizeof(struct SmsMsgData_ST) +
-				 SMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);
+				SMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);
 		if (buffer) {
 			struct SmsMsgData_ST *msg =
-				(struct SmsMsgData_ST *)
+					(struct SmsMsgData_ST *)
 					SMS_ALIGN_ADDRESS(buffer);
 
 			SMS_INIT_MSG(&msg->xMsgHeader, MSG_SMS_INIT_DEVICE_REQ,
-				     sizeof(struct SmsMsgData_ST));
+					sizeof(struct SmsMsgData_ST));
 			msg->msgData[0] = mode;
 
-			rc = smscore_sendrequest_and_wait(
-				coredev, msg, msg->xMsgHeader.msgLength,
-				&coredev->init_device_done);
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+			rc = smscore_sendrequest_and_wait(coredev, msg,
+					msg->xMsgHeader. msgLength,
+					&coredev->init_device_done);
 
 			kfree(buffer);
 		} else {
 			sms_err("Could not allocate buffer for "
-				"init device message.");
+					"init device message.");
 			rc = -ENOMEM;
 		}
+*/
 	} else {
 		if (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_DVBT_BDA) {
 			sms_err("invalid mode specified %d", mode);
@@ -851,7 +920,7 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 
 		if (coredev->detectmode_handler)
 			coredev->detectmode_handler(coredev->context,
-						    &coredev->mode);
+					&coredev->mode);
 
 		if (coredev->mode != mode && coredev->setmode_handler)
 			rc = coredev->setmode_handler(coredev->context, mode);
@@ -862,12 +931,87 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 		coredev->device_flags &= ~SMS_DEVICE_NOT_READY;
 	}
 
-	if (rc != 0)
+	if (rc < 0)
 		sms_err("return error code %d.", rc);
 	return rc;
 }
 
 /**
+ * calls device handler to get fw file name
+ *
+ * @param coredev pointer to a coredev object returned by
+ *                smscore_register_device
+ * @param filename pointer to user buffer to fill the file name
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_get_fw_filename(struct smscore_device_t *coredev, int mode,
+		char *filename) {
+	int rc = 0;
+	enum sms_device_type_st type;
+	char tmpname[200];
+
+	type = smscore_registry_gettype(coredev->devpath);
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	/* driver not need file system services */
+	tmpname[0] = '\0';
+#else
+	sprintf(tmpname, "%s/%s", DEFAULT_FW_FILE_PATH,
+			smscore_fw_lkup[mode][type]);
+#endif
+	if (copy_to_user(filename, tmpname, strlen(tmpname) + 1)) {
+		sms_err("Failed copy file path to user buffer\n");
+		return -EFAULT;
+	}
+	return rc;
+}
+
+/**
+ * calls device handler to keep fw buff for later use
+ *
+ * @param coredev pointer to a coredev object returned by
+ *                smscore_register_device
+ * @param ufwbuf  pointer to user fw buffer
+ * @param size    size in bytes of buffer
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_send_fw_file(struct smscore_device_t *coredev, u8 *ufwbuf,
+		int size) {
+	int rc = 0;
+
+	/* free old buffer */
+	if (coredev->fw_buf != NULL) {
+		kfree(coredev->fw_buf);
+		coredev->fw_buf = NULL;
+	}
+
+	coredev->fw_buf = kmalloc(ALIGN(size, SMS_ALLOC_ALIGNMENT), GFP_KERNEL
+			| GFP_DMA);
+	if (!coredev->fw_buf) {
+		sms_info("Failed allocate FW buffer memory\n");
+		return -EFAULT;
+	}
+
+	if (copy_from_user(coredev->fw_buf, ufwbuf, size)) {
+		sms_info("Failed copy FW from user buffer\n");
+		kfree(coredev->fw_buf);
+		return -EFAULT;
+	}
+	coredev->fw_buf_size = size;
+
+	return rc;
+}
+
+/* ##w21558, Added */
+int smscore_reset_device_mode(struct smscore_device_t *coredev)
+{
+  coredev->mode = -1;
+  return 0;
+}
+
+/**
  * calls device handler to get current mode of operation
  *
  * @param coredev pointer to a coredev object returned by
@@ -890,28 +1034,26 @@ int smscore_get_device_mode(struct smscore_device_t *coredev)
  * @param id client id (SMS_DONT_CARE for all id)
  *
  */
-static struct
-smscore_client_t *smscore_find_client(struct smscore_device_t *coredev,
-				      int data_type, int id)
-{
+static struct smscore_client_t *smscore_find_client(
+		struct smscore_device_t *coredev, int data_type, int id) {
 	struct smscore_client_t *client = NULL;
 	struct list_head *next, *first;
 	unsigned long flags;
 	struct list_head *firstid, *nextid;
 
-
 	spin_lock_irqsave(&coredev->clientslock, flags);
 	first = &coredev->clients;
-	for (next = first->next;
-	     (next != first) && !client;
-	     next = next->next) {
-		firstid = &((struct smscore_client_t *)next)->idlist;
-		for (nextid = firstid->next;
-		     nextid != firstid;
-		     nextid = nextid->next) {
-			if ((((struct smscore_idlist_t *)nextid)->id == id) &&
-			    (((struct smscore_idlist_t *)nextid)->data_type == data_type ||
-			    (((struct smscore_idlist_t *)nextid)->data_type == 0))) {
+	for (next = first->next; (next != first) && !client;
+			next = next->next) {
+		firstid = &((struct smscore_client_t *) next)->idlist;
+		for (nextid = firstid->next; nextid != firstid;
+				nextid = nextid->next) {
+			if ((((struct smscore_idlist_t *) nextid)->id == id)
+					&& (((struct smscore_idlist_t *)
+						 nextid)->data_type
+						== data_type
+						|| (((struct smscore_idlist_t *)
+						nextid)->data_type == 0))) {
 				client = (struct smscore_client_t *) next;
 				break;
 			}
@@ -931,12 +1073,10 @@ smscore_client_t *smscore_find_client(struct smscore_device_t *coredev,
  *
  */
 void smscore_onresponse(struct smscore_device_t *coredev,
-			struct smscore_buffer_t *cb)
-{
-	struct SmsMsgHdr_ST *phdr =
-		(struct SmsMsgHdr_ST *)((u8 *) cb->p + cb->offset);
-	struct smscore_client_t *client =
-		smscore_find_client(coredev, phdr->msgType, phdr->msgDstId);
+		struct smscore_buffer_t *cb) {
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) ((u8 *) cb->p
+			+ cb->offset);
+	struct smscore_client_t *client;
 	int rc = -EBUSY;
 
 	static unsigned long last_sample_time; /* = 0; */
@@ -947,40 +1087,54 @@ void smscore_onresponse(struct smscore_device_t *coredev,
 		last_sample_time = time_now;
 
 	if (time_now - last_sample_time > 10000) {
-		sms_debug("\ndata rate %d bytes/secs",
-			  (int)((data_total * 1000) /
-				(time_now - last_sample_time)));
+		sms_info("\ndata rate %d bytes/secs",
+				(int)((data_total * 1000) /
+						(time_now - last_sample_time)));
 
 		last_sample_time = time_now;
 		data_total = 0;
 	}
 
 	data_total += cb->size;
+
+	/* Do we need to re-route? */
+	if ((phdr->msgType == MSG_SMS_HO_PER_SLICES_IND) ||
+			(phdr->msgType == MSG_SMS_TRANSMISSION_IND)) {
+		if (coredev->mode == DEVICE_MODE_DVBT_BDA)
+			phdr->msgDstId = DVBT_BDA_CONTROL_MSG_ID;
+	}
+
+
+	client = smscore_find_client(coredev, phdr->msgType, phdr->msgDstId);
+
 	/* If no client registered for type & id,
 	 * check for control client where type is not registered */
-	if (client)
+	if (client) {
 		rc = client->onresponse_handler(client->context, cb);
-
+  }
 	if (rc < 0) {
+		smsendian_handle_rx_message((struct SmsMsgData_ST *)phdr);
+
 		switch (phdr->msgType) {
-		case MSG_SMS_GET_VERSION_EX_RES:
-		{
+		case MSG_SMS_GET_VERSION_EX_RES: {
 			struct SmsVersionRes_ST *ver =
-				(struct SmsVersionRes_ST *) phdr;
-			sms_debug("MSG_SMS_GET_VERSION_EX_RES "
-				  "id %d prots 0x%x ver %d.%d",
-				  ver->FirmwareId, ver->SupportedProtocols,
-				  ver->RomVersionMajor, ver->RomVersionMinor);
+					(struct SmsVersionRes_ST *) phdr;
+			sms_info("MSG_SMS_GET_VERSION_EX_RES "
+					"id %d prots 0x%x ver %d.%d",
+					ver->FirmwareId,
+					ver->SupportedProtocols,
+					ver->RomVersionMajor,
+					ver->RomVersionMinor);
 
 			coredev->mode = ver->FirmwareId == 255 ?
-				DEVICE_MODE_NONE : ver->FirmwareId;
+					DEVICE_MODE_NONE : ver->FirmwareId;
 			coredev->modes_supported = ver->SupportedProtocols;
 
 			complete(&coredev->version_ex_done);
 			break;
 		}
 		case MSG_SMS_INIT_DEVICE_RES:
-			sms_debug("MSG_SMS_INIT_DEVICE_RES");
+			printk(KERN_INFO "%s: MSG_SMS_INIT_DEVICE_RES\n", __func__);
 			complete(&coredev->init_device_done);
 			break;
 		case MSG_SW_RELOAD_START_RES:
@@ -994,13 +1148,50 @@ void smscore_onresponse(struct smscore_device_t *coredev,
 			sms_debug("MSG_SW_RELOAD_EXEC_RES");
 			break;
 		case MSG_SMS_SWDOWNLOAD_TRIGGER_RES:
-			sms_debug("MSG_SMS_SWDOWNLOAD_TRIGGER_RES");
+			sms_info("MSG_SMS_SWDOWNLOAD_TRIGGER_RES");
 			complete(&coredev->trigger_done);
 			break;
 		case MSG_SMS_SLEEP_RESUME_COMP_IND:
 			complete(&coredev->resume_done);
 			break;
+		case MSG_SMS_GPIO_CONFIG_EX_RES:
+			sms_debug("MSG_SMS_GPIO_CONFIG_EX_RES");
+			complete(&coredev->gpio_configuration_done);
+			break;
+		case MSG_SMS_GPIO_SET_LEVEL_RES:
+			sms_debug("MSG_SMS_GPIO_SET_LEVEL_RES");
+			complete(&coredev->gpio_set_level_done);
+			break;
+		case MSG_SMS_GPIO_GET_LEVEL_RES:
+		{
+			u32 *msgdata = (u32 *) phdr;
+			coredev->gpio_get_res = msgdata[1];
+			sms_debug("MSG_SMS_GPIO_GET_LEVEL_RES gpio level %d",
+					coredev->gpio_get_res);
+			complete(&coredev->gpio_get_level_done);
+			break;
+		}
+		case MSG_SMS_START_IR_RES:
+			complete(&coredev->ir_init_done);
+			break;
+		case MSG_SMS_IR_SAMPLES_IND:
+			sms_ir_event(coredev,
+				(const char *)
+				((char *)phdr
+				+ sizeof(struct SmsMsgHdr_ST)),
+				(int)phdr->msgLength
+				- sizeof(struct SmsMsgHdr_ST));
+      break;
+
+    case MSG_SMS_SPI_INT_LINE_SET_RES:
+      sms_info("MSG_SMS_SPI_INT_LINE_SET_RES\n");
+			break;
 		default:
+/*
+			sms_info("no client (%p) or error (%d), "
+					"type:%d dstid:%d", client, rc,
+					phdr->msgType, phdr->msgDstId);
+*/
 			break;
 		}
 		smscore_putbuffer(coredev, cb);
@@ -1020,12 +1211,24 @@ struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)
 	struct smscore_buffer_t *cb = NULL;
 	unsigned long flags;
 
+	DEFINE_WAIT(wait);
+
 	spin_lock_irqsave(&coredev->bufferslock, flags);
 
-	if (!list_empty(&coredev->buffers)) {
+	/* This function must return a valid buffer, since the buffer list is
+	 * finite, we check that there is an available buffer, if not, we wait
+	 * until such buffer become available.
+	 */
+
+	prepare_to_wait(&coredev->buffer_mng_waitq, &wait, TASK_INTERRUPTIBLE);
+
+	if (list_empty(&coredev->buffers))
+		schedule();
+
+	finish_wait(&coredev->buffer_mng_waitq, &wait);
+
 		cb = (struct smscore_buffer_t *) coredev->buffers.next;
 		list_del(&cb->entry);
-	}
 
 	spin_unlock_irqrestore(&coredev->bufferslock, flags);
 
@@ -1041,15 +1244,13 @@ struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)
  *
  */
 void smscore_putbuffer(struct smscore_device_t *coredev,
-		       struct smscore_buffer_t *cb)
-{
+		struct smscore_buffer_t *cb) {
+	wake_up_interruptible(&coredev->buffer_mng_waitq);
 	list_add_locked(&cb->entry, &coredev->buffers, &coredev->bufferslock);
 }
 
 static int smscore_validate_client(struct smscore_device_t *coredev,
-				   struct smscore_client_t *client,
-				   int data_type, int id)
-{
+		struct smscore_client_t *client, int data_type, int id) {
 	struct smscore_idlist_t *listentry;
 	struct smscore_client_t *registered_client;
 
@@ -1092,11 +1293,13 @@ static int smscore_validate_client(struct smscore_device_t *coredev,
  * @return 0 on success, <0 on error.
  */
 int smscore_register_client(struct smscore_device_t *coredev,
-			    struct smsclient_params_t *params,
-			    struct smscore_client_t **client)
-{
+		struct smsclient_params_t *params,
+				struct smscore_client_t **client) {
 	struct smscore_client_t *newclient;
 	/* check that no other channel with same parameters exists */
+	sms_info("entering....smscore_register_client \n");
+
+
 	if (smscore_find_client(coredev, params->data_type,
 				params->initial_id)) {
 		sms_err("Client already exist.");
@@ -1117,10 +1320,10 @@ int smscore_register_client(struct smscore_device_t *coredev,
 	list_add_locked(&newclient->entry, &coredev->clients,
 			&coredev->clientslock);
 	smscore_validate_client(coredev, newclient, params->data_type,
-				params->initial_id);
+			params->initial_id);
 	*client = newclient;
-	sms_debug("%p %d %d", params->context, params->data_type,
-		  params->initial_id);
+	sms_debug("Register new client %p DT=%d ID=%d",
+		params->context, params->data_type, params->initial_id);
 
 	return 0;
 }
@@ -1139,10 +1342,9 @@ void smscore_unregister_client(struct smscore_client_t *client)
 
 	spin_lock_irqsave(&coredev->clientslock, flags);
 
-
 	while (!list_empty(&client->idlist)) {
 		struct smscore_idlist_t *identry =
-			(struct smscore_idlist_t *) client->idlist.next;
+				(struct smscore_idlist_t *) client->idlist.next;
 		list_del(&identry->entry);
 		kfree(identry);
 	}
@@ -1166,9 +1368,8 @@ void smscore_unregister_client(struct smscore_client_t *client)
  *
  * @return 0 on success, <0 on error.
  */
-int smsclient_sendrequest(struct smscore_client_t *client,
-			  void *buffer, size_t size)
-{
+int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size) {
 	struct smscore_device_t *coredev;
 	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) buffer;
 	int rc;
@@ -1187,88 +1388,300 @@ int smsclient_sendrequest(struct smscore_client_t *client,
 	}
 
 	rc = smscore_validate_client(client->coredev, client, 0,
-				     phdr->msgSrcId);
+			phdr->msgSrcId);
 	if (rc < 0)
 		return rc;
 
 	return coredev->sendrequest_handler(coredev->context, buffer, size);
 }
 
+#ifdef SMS_HOSTLIB_SUBSYS
+/**
+ * return the size of large (common) buffer
+ *
+ * @param coredev pointer to a coredev object from clients hotplug
+ *
+ * @return size (in bytes) of the buffer
+ */
+int smscore_get_common_buffer_size(struct smscore_device_t *coredev)
+{
+	return coredev->common_buffer_size;
+}
 
-int smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,
-			   struct smscore_gpio_config *pinconfig)
+/**
+ * maps common buffer (if supported by platform)
+ *
+ * @param coredev pointer to a coredev object from clients hotplug
+ * @param vma pointer to vma struct from mmap handler
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_map_common_buffer(struct smscore_device_t *coredev,
+		struct vm_area_struct *vma)
 {
-	struct {
-		struct SmsMsgHdr_ST hdr;
-		u32 data[6];
-	} msg;
+	unsigned long end = vma->vm_end,
+	start = vma->vm_start,
+	size = PAGE_ALIGN(coredev->common_buffer_size);
 
-	if (coredev->device_flags & SMS_DEVICE_FAMILY2) {
-		msg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-		msg.hdr.msgDstId = HIF_TASK;
-		msg.hdr.msgFlags = 0;
-		msg.hdr.msgType  = MSG_SMS_GPIO_CONFIG_EX_REQ;
-		msg.hdr.msgLength = sizeof(msg);
+	if (!(vma->vm_flags & (VM_READ | VM_SHARED)) ||
+			(vma->vm_flags & VM_WRITE)) {
+		sms_err("invalid vm flags");
+		return -EINVAL;
+	}
 
-		msg.data[0] = pin;
-		msg.data[1] = pinconfig->pullupdown;
+	if ((end - start) != size) {
+		sms_err("invalid size %d expected %d",
+				(int)(end - start), (int)size);
+		return -EINVAL;
+	}
 
-		/* Convert slew rate for Nova: Fast(0) = 3 / Slow(1) = 0; */
-		msg.data[2] = pinconfig->outputslewrate == 0 ? 3 : 0;
+	if (remap_pfn_range(vma, start,
+			coredev->common_buffer_phys >> PAGE_SHIFT,
+			size, pgprot_noncached(vma->vm_page_prot))) {
+		sms_err("remap_page_range failed");
+		return -EAGAIN;
+	}
 
-		switch (pinconfig->outputdriving) {
-		case SMS_GPIO_OUTPUTDRIVING_16mA:
-			msg.data[3] = 7; /* Nova - 16mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_12mA:
-			msg.data[3] = 5; /* Nova - 11mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_8mA:
-			msg.data[3] = 3; /* Nova - 7mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_4mA:
-		default:
-			msg.data[3] = 2; /* Nova - 4mA */
-			break;
-		}
+	return 0;
+}
+#endif /* SMS_HOSTLIB_SUBSYS */
+
+static int GetGpioPinParams(u32 PinNum, u32 *pTranslatedPinNum,
+		u32 *pGroupNum, u32 *pGroupCfg) {
+
+	*pGroupCfg = 1;
+
+	if (PinNum >= 0 && PinNum <= 1)	{
+		*pTranslatedPinNum = 0;
+		*pGroupNum = 9;
+		*pGroupCfg = 2;
+	} else if (PinNum >= 2 && PinNum <= 6) {
+		*pTranslatedPinNum = 2;
+		*pGroupNum = 0;
+		*pGroupCfg = 2;
+	} else if (PinNum >= 7 && PinNum <= 11) {
+		*pTranslatedPinNum = 7;
+		*pGroupNum = 1;
+	} else if (PinNum >= 12 && PinNum <= 15) {
+		*pTranslatedPinNum = 12;
+		*pGroupNum = 2;
+		*pGroupCfg = 3;
+	} else if (PinNum == 16) {
+		*pTranslatedPinNum = 16;
+		*pGroupNum = 23;
+	} else if (PinNum >= 17 && PinNum <= 24) {
+		*pTranslatedPinNum = 17;
+		*pGroupNum = 3;
+	} else if (PinNum == 25) {
+		*pTranslatedPinNum = 25;
+		*pGroupNum = 6;
+	} else if (PinNum >= 26 && PinNum <= 28) {
+		*pTranslatedPinNum = 26;
+		*pGroupNum = 4;
+	} else if (PinNum == 29) {
+		*pTranslatedPinNum = 29;
+		*pGroupNum = 5;
+		*pGroupCfg = 2;
+	} else if (PinNum == 30) {
+		*pTranslatedPinNum = 30;
+		*pGroupNum = 8;
+	} else if (PinNum == 31) {
+		*pTranslatedPinNum = 31;
+		*pGroupNum = 17;
+	} else
+		return -1;
+
+	*pGroupCfg <<= 24;
+
+	return 0;
+}
+
+int smscore_gpio_configure(struct smscore_device_t *coredev, u8 PinNum,
+		struct smscore_gpio_config *pGpioConfig) {
+
+	u32 totalLen;
+	u32 TranslatedPinNum;
+	u32 GroupNum;
+	u32 ElectricChar;
+	u32 groupCfg;
+	void *buffer;
+	int rc;
+
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[6];
+	} *pMsg;
+
+
+	if (PinNum > MAX_GPIO_PIN_NUMBER)
+		return -EINVAL;
+
+	if (pGpioConfig == NULL)
+		return -EINVAL;
+
+	totalLen = sizeof(struct SmsMsgHdr_ST) + (sizeof(u32) * 6);
+
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+
+	if (!(coredev->device_flags & SMS_DEVICE_FAMILY2)) {
+		pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_REQ;
+		if (GetGpioPinParams(PinNum, &TranslatedPinNum, &GroupNum,
+				&groupCfg) != 0)
+			return -EINVAL;
+
+		pMsg->msgData[1] = TranslatedPinNum;
+		pMsg->msgData[2] = GroupNum;
+		ElectricChar = (pGpioConfig->PullUpDown)
+				| (pGpioConfig->InputCharacteristics << 2)
+				| (pGpioConfig->OutputSlewRate << 3)
+				| (pGpioConfig->OutputDriving << 4);
+		pMsg->msgData[3] = ElectricChar;
+		pMsg->msgData[4] = pGpioConfig->Direction;
+		pMsg->msgData[5] = groupCfg;
+	} else {
+		pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_EX_REQ;
+		pMsg->msgData[1] = pGpioConfig->PullUpDown;
+		pMsg->msgData[2] = pGpioConfig->OutputSlewRate;
+		pMsg->msgData[3] = pGpioConfig->OutputDriving;
+		pMsg->msgData[4] = pGpioConfig->Direction;
+		pMsg->msgData[5] = 0;
+	}
+
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_configuration_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_configure timeout");
+		else
+			sms_err("smscore_gpio_configure error");
+	}
+	kfree(buffer);
+
+	return rc;
+}
+
+int smscore_gpio_set_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 NewLevel) {
+
+	u32 totalLen;
+	int rc;
+	void *buffer;
 
-		msg.data[4] = pinconfig->direction;
-		msg.data[5] = 0;
-	} else /* TODO: SMS_DEVICE_FAMILY1 */
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[3]; /* keep it 3 ! */
+	} *pMsg;
+
+	if ((NewLevel > 1) || (PinNum > MAX_GPIO_PIN_NUMBER) ||
+			(PinNum > MAX_GPIO_PIN_NUMBER))
 		return -EINVAL;
 
-	return coredev->sendrequest_handler(coredev->context,
-					    &msg, sizeof(msg));
+	totalLen = sizeof(struct SmsMsgHdr_ST) +
+			(3 * sizeof(u32)); /* keep it 3 ! */
+
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_SET_LEVEL_REQ;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+	pMsg->msgData[1] = NewLevel;
+
+	/* Send message to SMS */
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_set_level_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_set_level timeout");
+		else
+			sms_err("smscore_gpio_set_level error");
+	}
+	kfree(buffer);
+
+	return rc;
 }
 
-int smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level)
-{
-	struct {
-		struct SmsMsgHdr_ST hdr;
-		u32 data[3];
-	} msg;
+int smscore_gpio_get_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 *level) {
+
+	u32 totalLen;
+	int rc;
+	void *buffer;
+
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[2];
+	} *pMsg;
+
 
-	if (pin > MAX_GPIO_PIN_NUMBER)
+	if (PinNum > MAX_GPIO_PIN_NUMBER)
 		return -EINVAL;
 
-	msg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-	msg.hdr.msgDstId = HIF_TASK;
-	msg.hdr.msgFlags = 0;
-	msg.hdr.msgType  = MSG_SMS_GPIO_SET_LEVEL_REQ;
-	msg.hdr.msgLength = sizeof(msg);
+	totalLen = sizeof(struct SmsMsgHdr_ST) + (2 * sizeof(u32));
 
-	msg.data[0] = pin;
-	msg.data[1] = level ? 1 : 0;
-	msg.data[2] = 0;
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_GET_LEVEL_REQ;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+	pMsg->msgData[1] = 0;
+
+	/* Send message to SMS */
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_get_level_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_get_level timeout");
+		else
+			sms_err("smscore_gpio_get_level error");
+	}
+	kfree(buffer);
+
+	/* Its a race between other gpio_get_level() and the copy of the single
+	 * global 'coredev->gpio_get_res' to  the function's variable 'level'
+	 */
+	*level = coredev->gpio_get_res;
 
-	return coredev->sendrequest_handler(coredev->context,
-					    &msg, sizeof(msg));
+	return rc;
 }
 
 static int __init smscore_module_init(void)
 {
 	int rc = 0;
 
+	sms_info("entering... smscore_module_init....\n");
 	INIT_LIST_HEAD(&g_smscore_notifyees);
 	INIT_LIST_HEAD(&g_smscore_devices);
 	kmutex_init(&g_smscore_deviceslock);
@@ -1276,25 +1689,127 @@ static int __init smscore_module_init(void)
 	INIT_LIST_HEAD(&g_smscore_registry);
 	kmutex_init(&g_smscore_registrylock);
 
+	/* Register sub system adapter objects */
+
+#ifdef SMS_NET_SUBSYS
+	/* NET Register */
+	rc = smsnet_register();
+	if (rc) {
+		sms_err("Error registering Siano's network client.\n");
+		goto smsnet_error;
+	}
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	/* Char interface Register */
+	rc = smschar_register();
+	if (rc) {
+		sms_err("Error registering Siano's char device client.\n");
+		goto smschar_error;
+	}
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+	/* DVB v.3 Register */
+	rc = smsdvb_register();
+	if (rc) {
+		sms_err("Error registering DVB client.\n");
+		goto smsdvb_error;
+	}
+#endif
+
+	/* Register interfaces objects */
+
+#ifdef SMS_USB_DRV
 	/* USB Register */
 	rc = smsusb_register();
+	if (rc) {
+		sms_err("Error registering USB bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
+
+#ifdef SMS_SDIO_DRV
+	/* SDIO Register */
+	rc = smssdio_register();
+	if (rc) {
+		sms_err("Error registering SDIO bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
+
+#ifdef SMS_SPI_DRV
+	/* SPI Register */
+	rc = smsspi_register();
+	if (rc) {
+		sms_err("Error registering Intel PXA310 SPI bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
 
-	/* DVB Register */
-	rc = smsdvb_register();
+	return rc;
+
+sms_bus_drv_error:
+#ifdef SMS_DVB3_SUBSYS
+	smsdvb_unregister();
+smsdvb_error:
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	smschar_unregister();
+smschar_error:
+#endif
+
+#ifdef SMS_NET_SUBSYS
+	smsnet_unregister();
+smsnet_error:
+#endif
 
-	sms_debug("rc %d", rc);
+	/*sms_err("rc %d", rc);*/
+	printk(KERN_INFO "%s, rc %d\n", __func__, rc);
 
 	return rc;
 }
 
 static void __exit smscore_module_exit(void)
 {
+  printk(KERN_INFO "%s is called.\n", __func__);
+
+#ifdef SMS_NET_SUBSYS
+	/* Net Unregister */
+	smsnet_unregister();
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	/* Char interface Unregister */
+	smschar_unregister();
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+	/* DVB v.3 unregister */
+	smsdvb_unregister();
+#endif
+
+	/* Unegister interfaces objects */
+#ifdef SMS_USB_DRV
+	/* USB unregister */
+	smsusb_unregister();
+#endif
+
+#ifdef SMS_SDIO_DRV
+	/* SDIO unegister */
+	smssdio_unregister();
+#endif
+#ifdef SMS_SPI_DRV
+	/* SPI unegister */
+	smsspi_unregister();
+#endif
 
 	kmutex_lock(&g_smscore_deviceslock);
 	while (!list_empty(&g_smscore_notifyees)) {
 		struct smscore_device_notifyee_t *notifyee =
-			(struct smscore_device_notifyee_t *)
-				g_smscore_notifyees.next;
+		(struct smscore_device_notifyee_t *)
+		g_smscore_notifyees.next;
 
 		list_del(&notifyee->entry);
 		kfree(notifyee);
@@ -1304,26 +1819,20 @@ static void __exit smscore_module_exit(void)
 	kmutex_lock(&g_smscore_registrylock);
 	while (!list_empty(&g_smscore_registry)) {
 		struct smscore_registry_entry_t *entry =
-			(struct smscore_registry_entry_t *)
-				g_smscore_registry.next;
+		(struct smscore_registry_entry_t *)
+		g_smscore_registry.next;
 
 		list_del(&entry->entry);
 		kfree(entry);
 	}
 	kmutex_unlock(&g_smscore_registrylock);
 
-	/* DVB UnRegister */
-	smsdvb_unregister();
-
-	/* Unregister USB */
-	smsusb_unregister();
-
-	sms_debug("");
+	sms_debug("end");
 }
 
 module_init(smscore_module_init);
 module_exit(smscore_module_exit);
 
-MODULE_DESCRIPTION("Driver for the Siano SMS1XXX USB dongle");
-MODULE_AUTHOR("Siano Mobile Silicon,,, (doronc@siano-ms.com)");
+MODULE_DESCRIPTION("Siano MDTV Core module - Version 2.0.1");
+MODULE_AUTHOR("Siano Mobile Silicon, Inc. (uris@siano-ms.com)");
 MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/siano/smscoreapi.h b/drivers/media/dvb/siano/smscoreapi.h
index 760e233..30b3cc9 100644
--- a/drivers/media/dvb/siano/smscoreapi.h
+++ b/drivers/media/dvb/siano/smscoreapi.h
@@ -1,26 +1,26 @@
-/*
- *  Driver for the Siano SMS1xxx USB dongle
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef __smscoreapi_h__
-#define __smscoreapi_h__
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_CORE_API_H__
+#define __SMS_CORE_API_H__
 
 #include <linux/version.h>
 #include <linux/device.h>
@@ -28,14 +28,14 @@
 #include <linux/mm.h>
 #include <linux/scatterlist.h>
 #include <linux/types.h>
-#include <asm/page.h>
+#include <linux/mutex.h>
+#include <linux/compat.h>
+#include <linux/wait.h>
+#include <linux/timer.h>
 
-#include "dmxdev.h"
-#include "dvbdev.h"
-#include "dvb_demux.h"
-#include "dvb_frontend.h"
+#include <asm/page.h>
 
-#include <linux/mutex.h>
+#include "smsir.h"
 
 #define kmutex_init(_p_) mutex_init(_p_)
 #define kmutex_lock(_p_) mutex_lock(_p_)
@@ -46,6 +46,7 @@
 #define min(a, b) (((a) < (b)) ? (a) : (b))
 #endif
 
+#define SMS_PROTOCOL_MAX_RAOUNDTRIP_MS			(10000)
 #define SMS_ALLOC_ALIGNMENT					128
 #define SMS_DMA_ALIGNMENT					16
 #define SMS_ALIGN_ADDRESS(addr) \
@@ -53,7 +54,7 @@
 
 #define SMS_DEVICE_FAMILY2					1
 #define SMS_ROM_NO_RESPONSE					2
-#define SMS_DEVICE_NOT_READY				0x8000000
+#define SMS_DEVICE_NOT_READY					0x8000000
 
 enum sms_device_type_st {
 	SMS_STELLAR = 0,
@@ -67,80 +68,134 @@ struct smscore_device_t;
 struct smscore_client_t;
 struct smscore_buffer_t;
 
-typedef int (*hotplug_t)(struct smscore_device_t *coredev,
-			 struct device *device, int arrival);
+typedef int (*hotplug_t) (struct smscore_device_t *coredev,
+			  struct device *device, int arrival);
 
-typedef int (*setmode_t)(void *context, int mode);
-typedef void (*detectmode_t)(void *context, int *mode);
-typedef int (*sendrequest_t)(void *context, void *buffer, size_t size);
-typedef int (*loadfirmware_t)(void *context, void *buffer, size_t size);
-typedef int (*preload_t)(void *context);
-typedef int (*postload_t)(void *context);
+typedef int (*setmode_t) (void *context, int mode);
+typedef void (*detectmode_t) (void *context, int *mode);
+typedef int (*sendrequest_t) (void *context, void *buffer, size_t size);
+typedef int (*loadfirmware_t) (void *context, void *buffer, size_t size);
+typedef int (*preload_t) (void *context);
+typedef int (*postload_t) (void *context);
 
-typedef int (*onresponse_t)(void *context, struct smscore_buffer_t *cb);
-typedef void (*onremove_t)(void *context);
+typedef int (*onresponse_t) (void *context, struct smscore_buffer_t *cb);
+typedef void (*onremove_t) (void *context);
 
 struct smscore_buffer_t {
 	/* public members, once passed to clients can be changed freely */
 	struct list_head entry;
-	int				size;
-	int				offset;
+	int size;
+	int offset;
 
 	/* private members, read-only for clients */
-	void			*p;
-	dma_addr_t		phys;
-	unsigned long	offset_in_common;
+	void *p;
+	dma_addr_t phys;
+	unsigned long offset_in_common;
 };
 
 struct smsdevice_params_t {
-	struct device	*device;
+	struct device *device;
 
-	int				buffer_size;
-	int				num_buffers;
+	int buffer_size;
+	int num_buffers;
 
-	char			devpath[32];
-	unsigned long	flags;
+	char devpath[32];
+	unsigned long flags;
 
-	setmode_t		setmode_handler;
-	detectmode_t	detectmode_handler;
-	sendrequest_t	sendrequest_handler;
-	preload_t		preload_handler;
-	postload_t		postload_handler;
+	setmode_t setmode_handler;
+	detectmode_t detectmode_handler;
+	sendrequest_t sendrequest_handler;
+	preload_t preload_handler;
+	postload_t postload_handler;
 
-	void			*context;
+	void *context;
 	enum sms_device_type_st device_type;
 };
 
 struct smsclient_params_t {
-	int				initial_id;
-	int				data_type;
-	onresponse_t	onresponse_handler;
-	onremove_t		onremove_handler;
+	int initial_id;
+	int data_type;
+	onresponse_t onresponse_handler;
+	onremove_t onremove_handler;
+	void *context;
+};
+
+struct smscore_device_t {
+	struct list_head entry;
+
+	struct list_head clients;
+	struct list_head subclients;
+	spinlock_t clientslock; /* client lock */
+
+	struct list_head buffers;
+	spinlock_t bufferslock; /* buffer lock  */
+	int num_buffers;
+
+	void *common_buffer;
+	int common_buffer_size;
+	dma_addr_t common_buffer_phys;
+
+	void *context;
+	struct device *device;
+
+	char devpath[32];
+	unsigned long device_flags;
+
+	setmode_t setmode_handler;
+	detectmode_t detectmode_handler;
+	sendrequest_t sendrequest_handler;
+	preload_t preload_handler;
+	postload_t postload_handler;
 
-	void			*context;
+	int mode, modes_supported;
+
+	/* host <--> device messages */
+	struct completion version_ex_done, data_download_done, trigger_done;
+	struct completion init_device_done, reload_start_done, resume_done;
+	struct completion gpio_configuration_done, gpio_set_level_done;
+	struct completion gpio_get_level_done, ir_init_done;
+
+	/* Buffer management */
+	wait_queue_head_t buffer_mng_waitq;
+
+	/* GPIO */
+	int gpio_get_res;
+
+	/* Target hardware board */
+	int board_id;
+
+	/* Firmware */
+	u8 *fw_buf;
+	u32 fw_buf_size;
+
+	/* Infrared (IR) */
+	struct ir_t ir;
 };
 
+/* Use DMA channel */
+#define MOT_FEAT_OMAP_DMA_USE             1
+
 /* GPIO definitions for antenna frequency domain control (SMS8021) */
-#define SMS_ANTENNA_GPIO_0					1
-#define SMS_ANTENNA_GPIO_1					0
+#define SMS_ANTENNA_GPIO_0				1
+#define SMS_ANTENNA_GPIO_1				0
 
-#define BW_8_MHZ							0
-#define BW_7_MHZ							1
-#define BW_6_MHZ							2
-#define BW_5_MHZ							3
-#define BW_ISDBT_1SEG						4
-#define BW_ISDBT_3SEG						5
+#define BW_8_MHZ					0
+#define BW_7_MHZ					1
+#define BW_6_MHZ					2
+#define BW_5_MHZ					3
+#define BW_ISDBT_1SEG					4
+#define BW_ISDBT_3SEG					5
 
 #define MSG_HDR_FLAG_SPLIT_MSG				4
 
-#define MAX_GPIO_PIN_NUMBER					31
+#define MAX_GPIO_PIN_NUMBER				31
 
-#define HIF_TASK							11
-#define SMS_HOST_LIB						150
+#define HIF_TASK					11
+#define SMS_HOST_LIB					150
 #define DVBT_BDA_CONTROL_MSG_ID				201
 
 #define SMS_MAX_PAYLOAD_SIZE				240
-#define SMS_TUNE_TIMEOUT					500
+#define SMS_TUNE_TIMEOUT				500
 
 #define MSG_SMS_GPIO_CONFIG_REQ				507
 #define MSG_SMS_GPIO_CONFIG_RES				508
@@ -148,48 +203,53 @@ struct smsclient_params_t {
 #define MSG_SMS_GPIO_SET_LEVEL_RES			510
 #define MSG_SMS_GPIO_GET_LEVEL_REQ			511
 #define MSG_SMS_GPIO_GET_LEVEL_RES			512
-#define MSG_SMS_RF_TUNE_REQ					561
-#define MSG_SMS_RF_TUNE_RES					562
+#define MSG_SMS_RF_TUNE_REQ				561
+#define MSG_SMS_RF_TUNE_RES				562
 #define MSG_SMS_INIT_DEVICE_REQ				578
 #define MSG_SMS_INIT_DEVICE_RES				579
 #define MSG_SMS_ADD_PID_FILTER_REQ			601
 #define MSG_SMS_ADD_PID_FILTER_RES			602
-#define MSG_SMS_REMOVE_PID_FILTER_REQ		603
-#define MSG_SMS_REMOVE_PID_FILTER_RES		604
-#define MSG_SMS_DAB_CHANNEL					607
-#define MSG_SMS_GET_PID_FILTER_LIST_REQ		608
-#define MSG_SMS_GET_PID_FILTER_LIST_RES		609
-#define MSG_SMS_GET_STATISTICS_REQ			615
-#define MSG_SMS_GET_STATISTICS_RES			616
-#define MSG_SMS_SET_ANTENNA_CONFIG_REQ		651
-#define MSG_SMS_SET_ANTENNA_CONFIG_RES		652
-#define MSG_SMS_GET_STATISTICS_EX_REQ		653
-#define MSG_SMS_GET_STATISTICS_EX_RES		654
-#define MSG_SMS_SLEEP_RESUME_COMP_IND		655
+#define MSG_SMS_REMOVE_PID_FILTER_REQ			603
+#define MSG_SMS_REMOVE_PID_FILTER_RES			604
+#define MSG_SMS_DAB_CHANNEL				607
+#define MSG_SMS_GET_PID_FILTER_LIST_REQ			608
+#define MSG_SMS_GET_PID_FILTER_LIST_RES			609
+#define MSG_SMS_HO_PER_SLICES_IND			630
+#define MSG_SMS_SET_ANTENNA_CONFIG_REQ			651
+#define MSG_SMS_SET_ANTENNA_CONFIG_RES			652
+#define MSG_SMS_SLEEP_RESUME_COMP_IND			655
 #define MSG_SMS_DATA_DOWNLOAD_REQ			660
 #define MSG_SMS_DATA_DOWNLOAD_RES			661
-#define MSG_SMS_SWDOWNLOAD_TRIGGER_REQ		664
-#define MSG_SMS_SWDOWNLOAD_TRIGGER_RES		665
-#define MSG_SMS_SWDOWNLOAD_BACKDOOR_REQ		666
-#define MSG_SMS_SWDOWNLOAD_BACKDOOR_RES		667
+#define MSG_SMS_SWDOWNLOAD_TRIGGER_REQ			664
+#define MSG_SMS_SWDOWNLOAD_TRIGGER_RES			665
+#define MSG_SMS_SWDOWNLOAD_BACKDOOR_REQ			666
+#define MSG_SMS_SWDOWNLOAD_BACKDOOR_RES			667
 #define MSG_SMS_GET_VERSION_EX_REQ			668
 #define MSG_SMS_GET_VERSION_EX_RES			669
-#define MSG_SMS_SET_CLOCK_OUTPUT_REQ		670
+#define MSG_SMS_SET_CLOCK_OUTPUT_REQ			670
 #define MSG_SMS_I2C_SET_FREQ_REQ			685
 #define MSG_SMS_GENERIC_I2C_REQ				687
 #define MSG_SMS_GENERIC_I2C_RES				688
 #define MSG_SMS_DVBT_BDA_DATA				693
-#define MSG_SW_RELOAD_REQ					697
-#define MSG_SMS_DATA_MSG					699
+#define MSG_SW_RELOAD_REQ				697
+#define MSG_SMS_DATA_MSG				699
 #define MSG_SW_RELOAD_START_REQ				702
 #define MSG_SW_RELOAD_START_RES				703
 #define MSG_SW_RELOAD_EXEC_REQ				704
 #define MSG_SW_RELOAD_EXEC_RES				705
 #define MSG_SMS_SPI_INT_LINE_SET_REQ		710
+#define MSG_SMS_SPI_INT_LINE_SET_RES	  711
 #define MSG_SMS_GPIO_CONFIG_EX_REQ			712
 #define MSG_SMS_GPIO_CONFIG_EX_RES			713
 #define MSG_SMS_ISDBT_TUNE_REQ				776
 #define MSG_SMS_ISDBT_TUNE_RES				777
+#define MSG_SMS_TRANSMISSION_IND			782
+#define MSG_SMS_START_IR_REQ				800
+#define MSG_SMS_START_IR_RES				801
+#define MSG_SMS_IR_SAMPLES_IND				802
+#define MSG_SMS_SIGNAL_DETECTED_IND			827
+#define MSG_SMS_NO_SIGNAL_IND				828
+
 
 #define SMS_INIT_MSG_EX(ptr, type, src, dst, len) do { \
 	(ptr)->msgType = type; (ptr)->msgSrcId = src; (ptr)->msgDstId = dst; \
@@ -198,6 +258,16 @@ struct smsclient_params_t {
 #define SMS_INIT_MSG(ptr, type, len) \
 	SMS_INIT_MSG_EX(ptr, type, 0, HIF_TASK, len)
 
+enum SMS_DVB3_EVENTS {
+	DVB3_EVENT_INIT = 0,
+	DVB3_EVENT_SLEEP,
+	DVB3_EVENT_HOTPLUG,
+	DVB3_EVENT_FE_LOCK,
+	DVB3_EVENT_FE_UNLOCK,
+	DVB3_EVENT_UNC_OK,
+	DVB3_EVENT_UNC_ERR
+};
+
 enum SMS_DEVICE_MODE {
 	DEVICE_MODE_NONE = -1,
 	DEVICE_MODE_DVBT = 0,
@@ -213,181 +283,267 @@ enum SMS_DEVICE_MODE {
 };
 
 struct SmsMsgHdr_ST {
-	u16	msgType;
-	u8	msgSrcId;
-	u8	msgDstId;
-	u16	msgLength; /* Length of entire message, including header */
-	u16	msgFlags;
+	u16 msgType;
+	u8 msgSrcId;
+	u8 msgDstId;
+	u16 msgLength;		/* Length of entire message, including header */
+	u16 msgFlags;
 };
 
 struct SmsMsgData_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-	u32			msgData[1];
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 msgData[1];
+};
+
+struct SmsMsgData_ST2 {
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 msgData[2];
 };
 
 struct SmsDataDownload_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-	u32			MemAddr;
-	u8			Payload[SMS_MAX_PAYLOAD_SIZE];
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 MemAddr;
+	u8 Payload[SMS_MAX_PAYLOAD_SIZE];
 };
 
 struct SmsVersionRes_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-
-	u16		ChipModel; /* e.g. 0x1102 for SMS-1102 "Nova" */
-	u8		Step; /* 0 - Step A */
-	u8		MetalFix; /* 0 - Metal 0 */
-
-	u8		FirmwareId; /* 0xFF  ROM, otherwise the
-				     * value indicated by
-				     * SMSHOSTLIB_DEVICE_MODES_E */
-	u8		SupportedProtocols; /* Bitwise OR combination of
-					     * supported protocols */
+	struct SmsMsgHdr_ST xMsgHeader;
+
+	u16 ChipModel;		/* e.g. 0x1102 for SMS-1102 "Nova" */
+	u8 Step;		/* 0 - Step A */
+	u8 MetalFix;		/* 0 - Metal 0 */
+
+	/* FirmwareId 0xFF if ROM, otherwise the
+	 * value indicated by SMSHOSTLIB_DEVICE_MODES_E */
+	u8 FirmwareId;
+	/* SupportedProtocols Bitwise OR combination of
+				 * supported protocols */
+	u8 SupportedProtocols;
+
+	u8 VersionMajor;
+	u8 VersionMinor;
+	u8 VersionPatch;
+	u8 VersionFieldPatch;
+
+	u8 RomVersionMajor;
+	u8 RomVersionMinor;
+	u8 RomVersionPatch;
+	u8 RomVersionFieldPatch;
+
+	u8 TextLabel[34];
+};
 
-	u8		VersionMajor;
-	u8		VersionMinor;
-	u8		VersionPatch;
-	u8		VersionFieldPatch;
+struct SmsFirmware_ST {
+	u32 CheckSum;
+	u32 Length;
+	u32 StartAddress;
+	u8 Payload[1];
+};
 
-	u8		RomVersionMajor;
-	u8		RomVersionMinor;
-	u8		RomVersionPatch;
-	u8		RomVersionFieldPatch;
+/* Statistics information returned as response for SmsHostApiGetStatistics_Req*/
+struct SMSHOSTLIB_STATISTICS_S {
+	u32 Reserved;		/*!< Reserved*/
+
+	/* Common parameters*/
+	u32 IsRfLocked;		/*!< 0 - not locked, 1 - locked*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+	u32 IsExternalLNAOn;	/*!< 0 - external LNA off, 1 - external LNA on*/
+
+	/* Reception quality*/
+	s32 SNR;		/*!< dB*/
+	u32 BER;		/*!< Post Viterbi BER [1E-5]*/
+	u32 FIB_CRC;		/*!< CRC errors percentage, valid only for DAB*/
+	u32 TS_PER;		/*!< Transport stream PER, 0xFFFFFFFF indicate N/A, valid only for DVB-T/H*/
+	u32 MFER;		/*!< DVB-H frame error rate in percentage, 0xFFFFFFFF indicate N/A, valid only for DVB-H*/
+	s32 RSSI;		/*!< dBm*/
+	s32 InBandPwr;		/*!< In band power in dBM*/
+	s32 CarrierOffset;	/*!< Carrier Offset in bin/1024*/
+
+	/* Transmission parameters*/
+	u32 Frequency;		/*!< Frequency in Hz*/
+	u32 Bandwidth;		/*!< Bandwidth in MHz, valid only for DVB-T/H*/
+	u32 TransmissionMode;	/*!< Transmission Mode, for DAB modes 1-4, for DVB-T/H FFT mode carriers in Kilos*/
+	u32 ModemState;		/*!< from SMSHOSTLIB_DVB_MODEM_STATE_ET , valid only for DVB-T/H*/
+	u32 GuardInterval;	/*!< Guard Interval from SMSHOSTLIB_GUARD_INTERVALS_ET, valid only for DVB-T/H*/
+	u32 CodeRate;		/*!< Code Rate from SMSHOSTLIB_CODE_RATE_ET, valid only for DVB-T/H*/
+	u32 LPCodeRate;		/*!< Low Priority Code Rate from SMSHOSTLIB_CODE_RATE_ET, valid only for DVB-T/H*/
+	u32 Hierarchy;		/*!< Hierarchy from SMSHOSTLIB_HIERARCHY_ET, valid only for DVB-T/H*/
+	u32 Constellation;	/*!< Constellation from SMSHOSTLIB_CONSTELLATION_ET, valid only for DVB-T/H*/
+
+	/* Burst parameters, valid only for DVB-H*/
+	u32 BurstSize;		/*!< Current burst size in bytes, valid only for DVB-H*/
+	u32 BurstDuration;	/*!< Current burst duration in mSec, valid only for DVB-H*/
+	u32 BurstCycleTime;	/*!< Current burst cycle time in mSec, valid only for DVB-H*/
+	u32 CalculatedBurstCycleTime;/*!< Current burst cycle time in mSec, as calculated by demodulator, valid only for DVB-H*/
+	u32 NumOfRows;		/*!< Number of rows in MPE table, valid only for DVB-H*/
+	u32 NumOfPaddCols;	/*!< Number of padding columns in MPE table, valid only for DVB-H*/
+	u32 NumOfPunctCols;	/*!< Number of puncturing columns in MPE table, valid only for DVB-H*/
+	u32 ErrorTSPackets;	/*!< Number of erroneous transport-stream packets*/
+	u32 TotalTSPackets;	/*!< Total number of transport-stream packets*/
+	u32 NumOfValidMpeTlbs;	/*!< Number of MPE tables which do not include errors after MPE RS decoding*/
+	u32 NumOfInvalidMpeTlbs;/*!< Number of MPE tables which include errors after MPE RS decoding*/
+	u32 NumOfCorrectedMpeTlbs;/*!< Number of MPE tables which were corrected by MPE RS decoding*/
+	/* Common params*/
+	u32 BERErrorCount;	/*!< Number of errornous SYNC bits.*/
+	u32 BERBitCount;	/*!< Total number of SYNC bits.*/
+
+	/* Interface information*/
+	u32 SmsToHostTxErrors;	/*!< Total number of transmission errors.*/
+
+	/* DAB/T-DMB*/
+	u32 PreBER; 		/*!< DAB/T-DMB only: Pre Viterbi BER [1E-5]*/
+
+	/* DVB-H TPS parameters*/
+	u32 CellId;		/*!< TPS Cell ID in bits 15..0, bits 31..16 zero; if set to 0xFFFFFFFF cell_id not yet recovered*/
+	u32 DvbhSrvIndHP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 DvbhSrvIndLP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+
+	u32 NumMPEReceived;	/*!< DVB-H, Num MPE section received*/
+
+	u32 ReservedFields[10];	/*!< Reserved*/
+};
 
-	u8		TextLabel[34];
+struct PID_STATISTICS_DATA_S {
+	struct PID_BURST_S {
+		u32	size;
+		u32	padding_cols;
+		u32	punct_cols;
+		u32	duration;
+		u32	cycle;
+		u32	calc_cycle;
+	} burst;
+
+	u32	tot_tbl_cnt;
+	u32	invalid_tbl_cnt;
+	u32  tot_cor_tbl;
 };
 
-struct SmsFirmware_ST {
-	u32			CheckSum;
-	u32			Length;
-	u32			StartAddress;
-	u8			Payload[1];
+struct PID_DATA_S {
+	u32 pid;
+	u32 num_rows;
+	struct PID_STATISTICS_DATA_S pid_statistics;
 };
 
-struct SMSHOSTLIB_STATISTICS_ST {
-	u32 Reserved; /* Reserved */
-
-	/* Common parameters */
-	u32 IsRfLocked; /* 0 - not locked, 1 - locked */
-	u32 IsDemodLocked; /* 0 - not locked, 1 - locked */
-	u32 IsExternalLNAOn; /* 0 - external LNA off, 1 - external LNA on */
-
-	/* Reception quality */
-	s32  SNR; /* dB */
-	u32 BER; /* Post Viterbi BER [1E-5] */
-	u32 FIB_CRC;	/* CRC errors percentage, valid only for DAB */
-	u32 TS_PER; /* Transport stream PER, 0xFFFFFFFF indicate N/A,
-		     * valid only for DVB-T/H */
-	u32 MFER; /* DVB-H frame error rate in percentage,
-		   * 0xFFFFFFFF indicate N/A, valid only for DVB-H */
-	s32  RSSI; /* dBm */
-	s32  InBandPwr; /* In band power in dBM */
-	s32  CarrierOffset; /* Carrier Offset in bin/1024 */
-
-	/* Transmission parameters, valid only for DVB-T/H */
-	u32 Frequency; /* Frequency in Hz */
-	u32 Bandwidth; /* Bandwidth in MHz */
-	u32 TransmissionMode; /* Transmission Mode, for DAB modes 1-4,
-			       * for DVB-T/H FFT mode carriers in Kilos */
-	u32 ModemState; /* from SMS_DvbModemState_ET */
-	u32 GuardInterval; /* Guard Interval, 1 divided by value */
-	u32 CodeRate; /* Code Rate from SMS_DvbModemState_ET */
-	u32 LPCodeRate; /* Low Priority Code Rate from SMS_DvbModemState_ET */
-	u32 Hierarchy; /* Hierarchy from SMS_Hierarchy_ET */
-	u32 Constellation; /* Constellation from SMS_Constellation_ET */
-
-	/* Burst parameters, valid only for DVB-H */
-	u32 BurstSize; /* Current burst size in bytes */
-	u32 BurstDuration; /* Current burst duration in mSec */
-	u32 BurstCycleTime; /* Current burst cycle time in mSec */
-	u32 CalculatedBurstCycleTime; /* Current burst cycle time in mSec,
-				       * as calculated by demodulator */
-	u32 NumOfRows; /* Number of rows in MPE table */
-	u32 NumOfPaddCols; /* Number of padding columns in MPE table */
-	u32 NumOfPunctCols; /* Number of puncturing columns in MPE table */
-	/* Burst parameters */
-	u32 ErrorTSPackets; /* Number of erroneous transport-stream packets */
-	u32 TotalTSPackets; /* Total number of transport-stream packets */
-	u32 NumOfValidMpeTlbs; /* Number of MPE tables which do not include
-				* errors after MPE RS decoding */
-	u32 NumOfInvalidMpeTlbs; /* Number of MPE tables which include errors
-				  * after MPE RS decoding */
-	u32 NumOfCorrectedMpeTlbs; /* Number of MPE tables which were corrected
-				    * by MPE RS decoding */
-
-	/* Common params */
-	u32 BERErrorCount; /* Number of errornous SYNC bits. */
-	u32 BERBitCount; /* Total number of SYNC bits. */
-
-	/* Interface information */
-	u32 SmsToHostTxErrors; /* Total number of transmission errors. */
-
-	/* DAB/T-DMB */
-	u32 PreBER; /* DAB/T-DMB only: Pre Viterbi BER [1E-5] */
-
-	/* DVB-H TPS parameters */
-	u32 CellId; /* TPS Cell ID in bits 15..0, bits 31..16 zero;
-		     * if set to 0xFFFFFFFF cell_id not yet recovered */
+#define CORRECT_STAT_RSSI(_stat) ((_stat).RSSI *= (-1))
+#define CORRECT_STAT_BANDWIDTH(_stat) _stat.Bandwidth = (8 - (_stat.Bandwidth))
+#define CORRECT_STAT_TRANSMISSON_MODE(_stat) \
+	do { \
+	if (_stat.TransmissionMode == 0) \
+		_stat.TransmissionMode = 2; \
+	else if (_stat.TransmissionMode == 1) \
+		_stat.TransmissionMode = 8; \
+	else \
+		_stat.TransmissionMode = 4; \
+	} while (0);
+
+struct TRANSMISSION_STATISTICS_S {
+	u32 Frequency;		/*!< Frequency in Hz*/
+	u32 Bandwidth;		/*!< Bandwidth in MHz*/
+	u32 TransmissionMode;	/*!< FFT mode carriers in Kilos*/
+	u32 GuardInterval;	/*!< Guard Interval from SMSHOSTLIB_GUARD_INTERVALS_ET*/
+	u32 CodeRate;		/*!< Code Rate from SMSHOSTLIB_CODE_RATE_ET*/
+	u32 LPCodeRate;		/*!< Low Priority Code Rate from SMSHOSTLIB_CODE_RATE_ET*/
+	u32 Hierarchy;		/*!< Hierarchy from SMSHOSTLIB_HIERARCHY_ET*/
+	u32 Constellation;	/*!< Constellation from SMSHOSTLIB_CONSTELLATION_ET*/
+
+	/* DVB-H TPS parameters*/
+	u32 CellId;		/*!< TPS Cell ID in bits 15..0, bits 31..16 zero; if set to 0xFFFFFFFF cell_id not yet recovered*/
+	u32 DvbhSrvIndHP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 DvbhSrvIndLP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+};
 
+struct RECEPTION_STATISTICS_S {
+	u32 IsRfLocked;		/*!< 0 - not locked, 1 - locked*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+	u32 IsExternalLNAOn;	/*!< 0 - external LNA off, 1 - external LNA on*/
+
+	u32 ModemState;		/*!< from SMSHOSTLIB_DVB_MODEM_STATE_ET*/
+	s32 SNR;		/*!< dB*/
+	u32 BER;		/*!< Post Viterbi BER [1E-5]*/
+	u32 BERErrorCount;	/*!< Number of erronous SYNC bits.*/
+	u32 BERBitCount;	/*!< Total number of SYNC bits.*/
+	u32 TS_PER;		/*!< Transport stream PER, 0xFFFFFFFF indicate N/A*/
+	u32 MFER;		/*!< DVB-H frame error rate in percentage, 0xFFFFFFFF indicate N/A, valid only for DVB-H*/
+	s32 RSSI;		/*!< dBm*/
+	s32 InBandPwr;		/*!< In band power in dBM*/
+	s32 CarrierOffset;	/*!< Carrier Offset in bin/1024*/
+	u32 ErrorTSPackets;	/*!< Number of erroneous transport-stream packets*/
+	u32 TotalTSPackets;	/*!< Total number of transport-stream packets*/
+
+	s32 MRC_SNR;		/*!< dB*/
+	s32 MRC_RSSI;		/*!< dBm*/
+	s32 MRC_InBandPwr;	/*!< In band power in dBM*/
 };
 
-struct SmsMsgStatisticsInfo_ST {
-	u32 RequestResult;
 
-	struct SMSHOSTLIB_STATISTICS_ST Stat;
+/* Statistics information returned as response for SmsHostApiGetStatisticsEx_Req for DVB applications, SMS1100 and up*/
+struct SMSHOSTLIB_STATISTICS_DVB_S {
+	/* Reception*/
+	struct RECEPTION_STATISTICS_S ReceptionData;
 
-	/* Split the calc of the SNR in DAB */
-	u32 Signal; /* dB */
-	u32 Noise; /* dB */
+	/* Transmission parameters*/
+	struct TRANSMISSION_STATISTICS_S TransmissionData;
 
+	/* Burst parameters, valid only for DVB-H*/
+#define	SRVM_MAX_PID_FILTERS		8
+	struct PID_DATA_S PidData[SRVM_MAX_PID_FILTERS];
 };
 
+struct SRVM_SIGNAL_STATUS_S {
+	u32 result;
+	u32 snr;
+	u32 tsPackets;
+	u32 etsPackets;
+	u32 constellation;
+	u32 hpCode;
+	u32 tpsSrvIndLP;
+	u32 tpsSrvIndHP;
+	u32 cellId;
+	u32 reason;
+
+	s32 inBandPower;
+	u32 requestId;
+};
 
 struct smscore_gpio_config {
 #define SMS_GPIO_DIRECTION_INPUT  0
 #define SMS_GPIO_DIRECTION_OUTPUT 1
-	u8 direction;
+	u8 Direction;
 
 #define SMS_GPIO_PULLUPDOWN_NONE     0
 #define SMS_GPIO_PULLUPDOWN_PULLDOWN 1
 #define SMS_GPIO_PULLUPDOWN_PULLUP   2
 #define SMS_GPIO_PULLUPDOWN_KEEPER   3
-	u8 pullupdown;
+	u8 PullUpDown;
 
 #define SMS_GPIO_INPUTCHARACTERISTICS_NORMAL  0
 #define SMS_GPIO_INPUTCHARACTERISTICS_SCHMITT 1
-	u8 inputcharacteristics;
-
-#define SMS_GPIO_OUTPUTSLEWRATE_FAST 0
-#define SMS_GPIO_OUTPUTSLEWRATE_SLOW 1
-	u8 outputslewrate;
-
-#define SMS_GPIO_OUTPUTDRIVING_4mA  0
-#define SMS_GPIO_OUTPUTDRIVING_8mA  1
-#define SMS_GPIO_OUTPUTDRIVING_12mA 2
-#define SMS_GPIO_OUTPUTDRIVING_16mA 3
-	u8 outputdriving;
-};
-
-struct smsdvb_client_t {
-	struct list_head entry;
-
-	struct smscore_device_t	*coredev;
-	struct smscore_client_t	*smsclient;
-
-	struct dvb_adapter	adapter;
-	struct dvb_demux	demux;
-	struct dmxdev		dmxdev;
-	struct dvb_frontend	frontend;
-
-	fe_status_t		fe_status;
-	int			fe_ber, fe_snr, fe_unc, fe_signal_strength;
-
-	struct completion	tune_done, stat_done;
-
-	/* todo: save freq/band instead whole struct */
-	struct dvb_frontend_parameters fe_params;
-
+	u8 InputCharacteristics;
+
+#define SMS_GPIO_OUTPUTSLEWRATE_SLOW		0 /* 10xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_FAST		1 /* 10xx */
+
+#define SMS_GPIO_OUTPUTSLEWRATE_0_45_V_NS	0 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_0_9_V_NS	1 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_1_7_V_NS	2 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_3_3_V_NS	3 /* 11xx */
+	u8 OutputSlewRate;
+
+#define SMS_GPIO_OUTPUTDRIVING_S_4mA		0 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_8mA		1 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_12mA		2 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_16mA		3 /* 10xx */
+
+#define SMS_GPIO_OUTPUTDRIVING_1_5mA		0 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_2_8mA		1 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_4mA			2 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_7mA			3 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_10mA			4 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_11mA			5 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_14mA			6 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_16mA			7 /* 11xx */
+	u8 OutputDriving;
 };
 
 extern void smscore_registry_setmode(char *devpath, int mode);
@@ -402,44 +558,99 @@ extern void smscore_unregister_device(struct smscore_device_t *coredev);
 
 extern int smscore_start_device(struct smscore_device_t *coredev);
 extern int smscore_load_firmware(struct smscore_device_t *coredev,
-				 char *filename,
-				 loadfirmware_t loadfirmware_handler);
+		char *filename, loadfirmware_t loadfirmware_handler);
 
 extern int smscore_set_device_mode(struct smscore_device_t *coredev, int mode);
 extern int smscore_get_device_mode(struct smscore_device_t *coredev);
+/*##w21558, Added*/
+extern int smscore_reset_device_mode(struct smscore_device_t *coredev);
+
+extern int smscore_register_client(struct smscore_device_t *coredev,
+		struct smsclient_params_t *params,
+		struct smscore_client_t **client);
+extern void smscore_unregister_client(struct smscore_client_t *client);
+
+extern int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size);
+extern void smscore_onresponse(struct smscore_device_t *coredev,
+		struct smscore_buffer_t *cb);
+
+
+extern int smscore_get_common_buffer_size(struct smscore_device_t *coredev);
+extern int smscore_map_common_buffer(struct smscore_device_t *coredev,
+		struct vm_area_struct *vma);
+extern int smscore_get_fw_filename(struct smscore_device_t *coredev, int mode,
+				   char *filename);
+extern int smscore_send_fw_file(struct smscore_device_t *coredev, u8 *ufwbuf,
+				int size);
 
 extern int smscore_register_client(struct smscore_device_t *coredev,
-				    struct smsclient_params_t *params,
-				    struct smscore_client_t **client);
+				   struct smsclient_params_t *params,
+				   struct smscore_client_t **client);
 extern void smscore_unregister_client(struct smscore_client_t *client);
 
-extern int smsclient_sendrequest(struct smscore_client_t *client,
-				 void *buffer, size_t size);
+extern int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size);
+
+extern int smscore_register_device(struct smsdevice_params_t *params,
+		struct smscore_device_t **coredev);
+
 extern void smscore_onresponse(struct smscore_device_t *coredev,
 			       struct smscore_buffer_t *cb);
 
+extern int smscore_get_common_buffer_size(struct smscore_device_t *coredev);
+extern int smscore_map_common_buffer(struct smscore_device_t *coredev,
+				     struct vm_area_struct *vma);
 
-extern
-struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev);
+extern struct smscore_buffer_t *smscore_getbuffer(
+		struct smscore_device_t *coredev);
 extern void smscore_putbuffer(struct smscore_device_t *coredev,
 			      struct smscore_buffer_t *cb);
 
-int smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,
-			   struct smscore_gpio_config *pinconfig);
-int smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level);
+int smscore_gpio_configure(struct smscore_device_t *coredev, u8 PinNum,
+		struct smscore_gpio_config *pGpioConfig);
+int smscore_gpio_set_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 NewLevel);
+int smscore_gpio_get_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 *level);
 
 void smscore_set_board_id(struct smscore_device_t *core, int id);
 int smscore_get_board_id(struct smscore_device_t *core);
 
-int smscore_led_state(struct smscore_device_t *core, int led);
+#ifdef SMS_HOSTLIB_SUBSYS
+extern int smschar_register(void);
+extern void smschar_unregister(void);
+#endif
+
+#ifdef SMS_NET_SUBSYS
+extern int smsnet_register(void);
+extern void smsnet_unregister(void);
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+extern int smsdvb_register(void);
+extern void smsdvb_unregister(void);
+#endif
 
-/* smsdvb.c */
-int smsdvb_register(void);
-void smsdvb_unregister(void);
+#ifdef SMS_USB_DRV
+extern int smsusb_register(void);
+extern void smsusb_unregister(void);
+#endif
+
+#ifdef SMS_SDIO_DRV
+extern int smssdio_register(void);
+extern void smssdio_unregister(void);
+#endif
 
-/* smsusb.c */
-int smsusb_register(void);
-void smsusb_unregister(void);
+/*##w21558, general SPI driver, in sholes, OMAP34XX spi driver*/
+
+#ifdef SMS_SPI_DRV
+extern int smsspi_register(void);
+extern void smsspi_unregister(void);
+#endif
+
+/*##w21558, Added*/
+extern int smsmdtv_power_control(int pwrup_enable);
 
 /* ------------------------------------------------------------------------ */
 
@@ -464,5 +675,9 @@ extern int sms_debug;
 #define sms_debug(fmt, arg...) \
 	dprintk(KERN_DEBUG, DBG_ADV, fmt, ##arg)
 
-
-#endif /* __smscoreapi_h__ */
+/*##w21558*/
+#define DISPLAY_CURR_TIME() do {\
+	struct timeval tv; \
+	do_gettimeofday(&tv); \
+	printk(KERN_INFO "%s: time = %ld\n", __func__, tv.tv_sec * 1000 + tv.tv_usec / 1000); } while (0)
+#endif /* __SMS_CORE_API_H__ */
diff --git a/drivers/media/dvb/siano/smsdvb.c b/drivers/media/dvb/siano/smsdvb.c
index 2da953a..027d383 100644
--- a/drivers/media/dvb/siano/smsdvb.c
+++ b/drivers/media/dvb/siano/smsdvb.c
@@ -1,88 +1,239 @@
-/*
- *  Driver for the Siano SMS1xxx USB dongle
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <asm/byteorder.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
 
 #include "smscoreapi.h"
+#include "smsendian.h"
 #include "sms-cards.h"
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
+struct smsdvb_client_t {
+	struct list_head entry;
+
+	struct smscore_device_t *coredev;
+	struct smscore_client_t *smsclient;
+
+	struct dvb_adapter adapter;
+	struct dvb_demux demux;
+	struct dmxdev dmxdev;
+	struct dvb_frontend frontend;
+
+	fe_status_t fe_status;
+
+	struct completion tune_done;
+
+	/* todo: save freq/band instead whole struct */
+	struct dvb_frontend_parameters fe_params;
+
+	struct SMSHOSTLIB_STATISTICS_DVB_S sms_stat_dvb;
+	int event_fe_state;
+	int event_unc_state;
+};
+
 static struct list_head g_smsdvb_clients;
 static struct mutex g_smsdvb_clientslock;
 
+
+/* Events that may come from DVB v3 adapter */
+static void sms_board_dvb3_event(struct smsdvb_client_t *client,
+		enum SMS_DVB3_EVENTS event) {
+
+	struct smscore_device_t *coredev = client->coredev;
+	switch (event) {
+	case DVB3_EVENT_INIT:
+		sms_debug("DVB3_EVENT_INIT");
+		sms_board_event(coredev, BOARD_EVENT_BIND);
+		break;
+	case DVB3_EVENT_SLEEP:
+		sms_debug("DVB3_EVENT_SLEEP");
+		sms_board_event(coredev, BOARD_EVENT_POWER_SUSPEND);
+		break;
+	case DVB3_EVENT_HOTPLUG:
+		sms_debug("DVB3_EVENT_HOTPLUG");
+		sms_board_event(coredev, BOARD_EVENT_POWER_INIT);
+		break;
+	case DVB3_EVENT_FE_LOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_LOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_LOCK;
+			sms_debug("DVB3_EVENT_FE_LOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_LOCK);
+		}
+		break;
+	case DVB3_EVENT_FE_UNLOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_UNLOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_UNLOCK;
+			sms_debug("DVB3_EVENT_FE_UNLOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_UNLOCK);
+		}
+		break;
+	case DVB3_EVENT_UNC_OK:
+		if (client->event_unc_state != DVB3_EVENT_UNC_OK) {
+			client->event_unc_state = DVB3_EVENT_UNC_OK;
+			sms_debug("DVB3_EVENT_UNC_OK");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_OK);
+		}
+		break;
+	case DVB3_EVENT_UNC_ERR:
+		if (client->event_unc_state != DVB3_EVENT_UNC_ERR) {
+			client->event_unc_state = DVB3_EVENT_UNC_ERR;
+			sms_debug("DVB3_EVENT_UNC_ERR");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_ERRORS);
+		}
+		break;
+
+	default:
+		sms_err("Unknown dvb3 api event");
+		break;
+	}
+}
+
 static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 {
 	struct smsdvb_client_t *client = (struct smsdvb_client_t *) context;
-	struct SmsMsgHdr_ST *phdr =
-		(struct SmsMsgHdr_ST *)(((u8 *) cb->p) + cb->offset);
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) (((u8 *) cb->p)
+			+ cb->offset);
+	u32 *pMsgData = (u32 *) phdr + 1;
+	/*u32 MsgDataLen = phdr->msgLength - sizeof(struct SmsMsgHdr_ST);*/
+	bool is_status_update = false;
+
+	smsendian_handle_rx_message((struct SmsMsgData_ST *) phdr);
 
 	switch (phdr->msgType) {
 	case MSG_SMS_DVBT_BDA_DATA:
-		dvb_dmx_swfilter(&client->demux, (u8 *)(phdr + 1),
-				 cb->size - sizeof(struct SmsMsgHdr_ST));
+		dvb_dmx_swfilter(&client->demux, (u8 *) (phdr + 1), cb->size
+				- sizeof(struct SmsMsgHdr_ST));
 		break;
 
 	case MSG_SMS_RF_TUNE_RES:
 		complete(&client->tune_done);
 		break;
 
-	case MSG_SMS_GET_STATISTICS_RES:
-	{
-		struct SmsMsgStatisticsInfo_ST *p =
-			(struct SmsMsgStatisticsInfo_ST *)(phdr + 1);
-
-		if (p->Stat.IsDemodLocked) {
-			client->fe_status = FE_HAS_SIGNAL |
-					    FE_HAS_CARRIER |
-					    FE_HAS_VITERBI |
-					    FE_HAS_SYNC |
-					    FE_HAS_LOCK;
-
-			client->fe_snr = p->Stat.SNR;
-			client->fe_ber = p->Stat.BER;
-			client->fe_unc = p->Stat.BERErrorCount;
-
-			if (p->Stat.InBandPwr < -95)
-				client->fe_signal_strength = 0;
-			else if (p->Stat.InBandPwr > -29)
-				client->fe_signal_strength = 100;
-			else
-				client->fe_signal_strength =
-					(p->Stat.InBandPwr + 95) * 3 / 2;
+	case MSG_SMS_SIGNAL_DETECTED_IND:
+		sms_info("MSG_SMS_SIGNAL_DETECTED_IND");
+		client->sms_stat_dvb.TransmissionData.IsDemodLocked = true;
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_NO_SIGNAL_IND:
+		sms_info("MSG_SMS_NO_SIGNAL_IND");
+		client->sms_stat_dvb.TransmissionData.IsDemodLocked = false;
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_TRANSMISSION_IND: {
+		sms_info("MSG_SMS_TRANSMISSION_IND");
+
+		pMsgData++;
+		memcpy(&client->sms_stat_dvb.TransmissionData, pMsgData,
+				sizeof(struct TRANSMISSION_STATISTICS_S));
+
+		/* Mo need to correct guard interval
+		 * (as opposed to old statistics message).
+		 */
+		CORRECT_STAT_BANDWIDTH(client->sms_stat_dvb.TransmissionData);
+		CORRECT_STAT_TRANSMISSON_MODE(
+				client->sms_stat_dvb.TransmissionData);
+		is_status_update = true;
+		break;
+	}
+	case MSG_SMS_HO_PER_SLICES_IND: {
+		struct RECEPTION_STATISTICS_S *pReceptionData =
+				&client->sms_stat_dvb.ReceptionData;
+		struct SRVM_SIGNAL_STATUS_S SignalStatusData;
+
+		/*sms_info("MSG_SMS_HO_PER_SLICES_IND");*/
+		pMsgData++;
+		SignalStatusData.result = pMsgData[0];
+		SignalStatusData.snr = pMsgData[1];
+		SignalStatusData.inBandPower = (s32) pMsgData[2];
+		SignalStatusData.tsPackets = pMsgData[3];
+		SignalStatusData.etsPackets = pMsgData[4];
+		SignalStatusData.constellation = pMsgData[5];
+		SignalStatusData.hpCode = pMsgData[6];
+		SignalStatusData.tpsSrvIndLP = pMsgData[7] & 0x03;
+		SignalStatusData.tpsSrvIndHP = pMsgData[8] & 0x03;
+		SignalStatusData.cellId = pMsgData[9] & 0xFFFF;
+		SignalStatusData.reason = pMsgData[10];
+		SignalStatusData.requestId = pMsgData[11];
+		pReceptionData->IsRfLocked = pMsgData[16];
+		pReceptionData->IsDemodLocked = pMsgData[17];
+		pReceptionData->ModemState = pMsgData[12];
+		pReceptionData->SNR = pMsgData[1];
+		pReceptionData->BER = pMsgData[13];
+		pReceptionData->RSSI = pMsgData[14];
+		CORRECT_STAT_RSSI(client->sms_stat_dvb.ReceptionData);
+
+		pReceptionData->InBandPwr = (s32) pMsgData[2];
+		pReceptionData->CarrierOffset = (s32) pMsgData[15];
+		pReceptionData->TotalTSPackets = pMsgData[3];
+		pReceptionData->ErrorTSPackets = pMsgData[4];
+
+		/* TS PER */
+		if ((SignalStatusData.tsPackets + SignalStatusData.etsPackets)
+				> 0) {
+			pReceptionData->TS_PER = (SignalStatusData.etsPackets
+					* 100) / (SignalStatusData.tsPackets
+					+ SignalStatusData.etsPackets);
 		} else {
-			client->fe_status = 0;
-			client->fe_snr =
-			client->fe_ber =
-			client->fe_unc =
-			client->fe_signal_strength = 0;
+			pReceptionData->TS_PER = 0;
 		}
 
-		complete(&client->stat_done);
-		break;
-	} }
+		pReceptionData->BERBitCount = pMsgData[18];
+		pReceptionData->BERErrorCount = pMsgData[19];
+
+		pReceptionData->MRC_SNR = pMsgData[20];
+		pReceptionData->MRC_InBandPwr = pMsgData[21];
+		pReceptionData->MRC_RSSI = pMsgData[22];
 
+		is_status_update = true;
+		break;
+	}
+	}
 	smscore_putbuffer(client->coredev, cb);
 
+	if (is_status_update) {
+	if (client->sms_stat_dvb.ReceptionData.IsDemodLocked) {
+		client->fe_status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+			| FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		sms_board_dvb3_event(client, DVB3_EVENT_FE_LOCK);
+		if (client->sms_stat_dvb.ReceptionData.ErrorTSPackets == 0)
+			sms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);
+		else
+			sms_board_dvb3_event(client, DVB3_EVENT_UNC_ERR);
+
+		} else {
+			client->fe_status = 0;
+			sms_board_dvb3_event(client, DVB3_EVENT_FE_UNLOCK);
+		}
+	}
+
 	return 0;
 }
 
@@ -115,8 +266,7 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct SmsMsgData_ST PidMsg;
 
-	sms_debug("add pid %d(%x)",
-		  feed->pid, feed->pid);
+	sms_debug("add pid %d(%x)", feed->pid, feed->pid);
 
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
@@ -125,8 +275,9 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
-	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)&PidMsg);
+	return smsclient_sendrequest(client->smsclient, &PidMsg,
+			sizeof(PidMsg));
 }
 
 static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
@@ -135,8 +286,7 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct SmsMsgData_ST PidMsg;
 
-	sms_debug("remove pid %d(%x)",
-		  feed->pid, feed->pid);
+	sms_debug("remove pid %d(%x)", feed->pid, feed->pid);
 
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
@@ -145,100 +295,81 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
-	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)&PidMsg);
+	return smsclient_sendrequest(client->smsclient, &PidMsg,
+			sizeof(PidMsg));
 }
 
 static int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,
 					void *buffer, size_t size,
 					struct completion *completion)
 {
-	int rc = smsclient_sendrequest(client->smsclient, buffer, size);
+	int rc;
+
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)buffer);
+	rc = smsclient_sendrequest(client->smsclient, buffer, size);
 	if (rc < 0)
 		return rc;
 
-	return wait_for_completion_timeout(completion,
-					   msecs_to_jiffies(2000)) ?
-						0 : -ETIME;
-}
-
-static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
-{
-	struct SmsMsgHdr_ST Msg = { MSG_SMS_GET_STATISTICS_REQ,
-			     DVBT_BDA_CONTROL_MSG_ID,
-			     HIF_TASK, sizeof(struct SmsMsgHdr_ST), 0 };
-	int ret = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
-					      &client->stat_done);
-	if (ret < 0)
-		return ret;
-
-	if (client->fe_status & FE_HAS_LOCK)
-		sms_board_led_feedback(client->coredev,
-				       (client->fe_unc == 0) ?
-				       SMS_LED_HI : SMS_LED_LO);
-	else
-		sms_board_led_feedback(client->coredev, SMS_LED_OFF);
-	return ret;
+	return wait_for_completion_timeout(completion, msecs_to_jiffies(2000))
+			? 0 : -ETIME;
 }
 
 static int smsdvb_read_status(struct dvb_frontend *fe, fe_status_t *stat)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
 		*stat = client->fe_status;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*ber = client->fe_ber;
+	*ber = client->sms_stat_dvb.ReceptionData.BER;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*strength = client->fe_signal_strength;
+	if (client->sms_stat_dvb.ReceptionData.InBandPwr < -95)
+		*strength = 0;
+		else if (client->sms_stat_dvb.ReceptionData.InBandPwr > -29)
+			*strength = 100;
+		else
+			*strength =
+				(client->sms_stat_dvb.ReceptionData.InBandPwr
+				+ 95) * 3 / 2;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*snr = client->fe_snr;
+	*snr = client->sms_stat_dvb.ReceptionData.SNR;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*ucblocks = client->fe_unc;
+	*ucblocks = client->sms_stat_dvb.ReceptionData.ErrorTSPackets;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_get_tune_settings(struct dvb_frontend *fe,
@@ -263,6 +394,10 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe,
 		u32		Data[3];
 	} Msg;
 
+	client->fe_status = FE_HAS_SIGNAL;
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+
 	Msg.Msg.msgSrcId  = DVBT_BDA_CONTROL_MSG_ID;
 	Msg.Msg.msgDstId  = HIF_TASK;
 	Msg.Msg.msgFlags  = 0;
@@ -275,11 +410,19 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe,
 		  fep->frequency, fep->u.ofdm.bandwidth);
 
 	switch (fep->u.ofdm.bandwidth) {
-	case BANDWIDTH_8_MHZ: Msg.Data[1] = BW_8_MHZ; break;
-	case BANDWIDTH_7_MHZ: Msg.Data[1] = BW_7_MHZ; break;
-	case BANDWIDTH_6_MHZ: Msg.Data[1] = BW_6_MHZ; break;
-	case BANDWIDTH_AUTO: return -EOPNOTSUPP;
-	default: return -EINVAL;
+	case BANDWIDTH_8_MHZ:
+		Msg.Data[1] = BW_8_MHZ;
+		break;
+	case BANDWIDTH_7_MHZ:
+		Msg.Data[1] = BW_7_MHZ;
+		break;
+	case BANDWIDTH_6_MHZ:
+		Msg.Data[1] = BW_6_MHZ;
+		break;
+	case BANDWIDTH_AUTO:
+		return -EOPNOTSUPP;
+	default:
+		return -EINVAL;
 	}
 
 	return smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
@@ -306,8 +449,7 @@ static int smsdvb_init(struct dvb_frontend *fe)
 	struct smsdvb_client_t *client =
 		container_of(fe, struct smsdvb_client_t, frontend);
 
-	sms_board_power(client->coredev, 1);
-
+	sms_board_dvb3_event(client, DVB3_EVENT_INIT);
 	return 0;
 }
 
@@ -316,8 +458,7 @@ static int smsdvb_sleep(struct dvb_frontend *fe)
 	struct smsdvb_client_t *client =
 		container_of(fe, struct smsdvb_client_t, frontend);
 
-	sms_board_led_feedback(client->coredev, SMS_LED_OFF);
-	sms_board_power(client->coredev, 0);
+	sms_board_dvb3_event(client, DVB3_EVENT_SLEEP);
 
 	return 0;
 }
@@ -329,7 +470,7 @@ static void smsdvb_release(struct dvb_frontend *fe)
 
 static struct dvb_frontend_ops smsdvb_fe_ops = {
 	.info = {
-		.name			= "Siano Mobile Digital SMS1xxx",
+		 .name = "Siano Mobile Digital MDTV Receiver",
 		.type			= FE_OFDM,
 		.frequency_min		= 44250000,
 		.frequency_max		= 867250000,
@@ -340,8 +481,7 @@ static struct dvb_frontend_ops smsdvb_fe_ops = {
 			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
 			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
 			FE_CAN_GUARD_INTERVAL_AUTO |
-			FE_CAN_RECOVER |
-			FE_CAN_HIERARCHY_AUTO,
+		 FE_CAN_RECOVER | FE_CAN_HIERARCHY_AUTO,
 	},
 
 	.release = smsdvb_release,
@@ -371,7 +511,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (!arrival)
 		return 0;
 
-	if (smscore_get_device_mode(coredev) != 4) {
+	if (smscore_get_device_mode(coredev) != DEVICE_MODE_DVBT_BDA) {
 		sms_err("SMS Device mode is not set for "
 			"DVB operation.");
 		return 0;
@@ -384,10 +524,15 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	}
 
 	/* register dvb adapter */
+#ifdef SMS_DVB_OLD_DVB_REGISTER_ADAPTER
 	rc = dvb_register_adapter(&client->adapter,
-				  sms_get_board(
-					smscore_get_board_id(coredev))->name,
-				  THIS_MODULE, device, adapter_nr);
+				  sms_get_board(smscore_get_board_id(coredev))->
+				  name, THIS_MODULE, device);
+#else
+	rc = dvb_register_adapter(&client->adapter,
+				  sms_get_board(smscore_get_board_id(coredev))->
+				  name, THIS_MODULE, device, adapter_nr);
+#endif
 	if (rc < 0) {
 		sms_err("dvb_register_adapter() failed %d", rc);
 		goto adapter_error;
@@ -442,7 +587,6 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	client->coredev = coredev;
 
 	init_completion(&client->tune_done);
-	init_completion(&client->stat_done);
 
 	kmutex_lock(&g_smsdvb_clientslock);
 
@@ -450,10 +594,11 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	kmutex_unlock(&g_smsdvb_clientslock);
 
-	sms_info("success");
-
-	sms_board_setup(coredev);
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+	sms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);
 
+	sms_info("success");
 	return 0;
 
 client_error:
@@ -494,8 +639,12 @@ void smsdvb_unregister(void)
 	kmutex_lock(&g_smsdvb_clientslock);
 
 	while (!list_empty(&g_smsdvb_clients))
-	       smsdvb_unregister_client(
-			(struct smsdvb_client_t *) g_smsdvb_clients.next);
+		smsdvb_unregister_client((struct smsdvb_client_t *)
+					 g_smsdvb_clients.next);
 
 	kmutex_unlock(&g_smsdvb_clientslock);
 }
+
+MODULE_DESCRIPTION("SMS DVB subsystem adaptation module");
+MODULE_AUTHOR("Siano Mobile Silicon, Inc. (uris@siano-ms.com)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/siano/smsusb.c b/drivers/media/dvb/siano/smsusb.c
index 5d7ca34..87a3c24 100644
--- a/drivers/media/dvb/siano/smsusb.c
+++ b/drivers/media/dvb/siano/smsusb.c
@@ -432,56 +432,11 @@ static void smsusb_disconnect(struct usb_interface *intf)
 	smsusb_term_device(intf);
 }
 
-static int smsusb_suspend(struct usb_interface *intf, pm_message_t msg)
-{
-	struct smsusb_device_t *dev =
-		(struct smsusb_device_t *)usb_get_intfdata(intf);
-	printk(KERN_INFO "%s  Entering status %d.\n", __func__, msg.event);
-	smsusb_stop_streaming(dev);
-	return 0;
-}
-
-static int smsusb_resume(struct usb_interface *intf)
-{
-	int rc, i;
-	struct smsusb_device_t *dev =
-		(struct smsusb_device_t *)usb_get_intfdata(intf);
-	struct usb_device *udev = interface_to_usbdev(intf);
-
-	printk(KERN_INFO "%s  Entering.\n", __func__);
-	usb_clear_halt(udev, usb_rcvbulkpipe(udev, 0x81));
-	usb_clear_halt(udev, usb_rcvbulkpipe(udev, 0x02));
-
-	for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++)
-		printk(KERN_INFO "endpoint %d %02x %02x %d\n", i,
-		       intf->cur_altsetting->endpoint[i].desc.bEndpointAddress,
-		       intf->cur_altsetting->endpoint[i].desc.bmAttributes,
-		       intf->cur_altsetting->endpoint[i].desc.wMaxPacketSize);
-
-	if (intf->num_altsetting > 0) {
-		rc = usb_set_interface(udev,
-				       intf->cur_altsetting->desc.
-				       bInterfaceNumber, 0);
-		if (rc < 0) {
-			printk(KERN_INFO
-			       "%s usb_set_interface failed, rc %d\n",
-			       __func__, rc);
-			return rc;
-		}
-	}
-
-	smsusb_start_streaming(dev);
-	return 0;
-}
-
 static struct usb_driver smsusb_driver = {
 	.name			= "sms1xxx",
 	.probe			= smsusb_probe,
 	.disconnect		= smsusb_disconnect,
 	.id_table		= smsusb_id_table,
-
-	.suspend		= smsusb_suspend,
-	.resume			= smsusb_resume,
 };
 
 int smsusb_register(void)
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 9e4c2ca..6669856 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -316,6 +316,26 @@ config VIDEO_MT9P012
 	  MT9P012 camera.  It is currently working with the TI OMAP3
 	  camera controller.
 
+config VIDEO_MIPI_INTERFACE
+	tristate "MIPI INTERFACE functionality"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is for MIPI INTERFACE functiionality
+
+config VIDEO_MIPI_DLI_TEST
+	tristate "MIPI DLI TEST functionality"
+	depends on VIDEO_MIPI_INTERFACE && VIDEO_V4L2
+	---help---
+	  This is for MIPI INTERFACE functiionality
+
+config VIDEO_OV8810
+	tristate "OV8810 raw sensor driver (8MP)"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Omni-Vision
+	  OV8810 camera.  It is currently working with the TI OMAP3
+	  camera controller.
+
 config VIDEO_OMAP3_HPLENS
 	tristate "HP generic lens driver"
 	depends on I2C && VIDEO_V4L2
@@ -990,3 +1010,13 @@ config USB_S2255
 endif # V4L_USB_DRIVERS
 
 endif # VIDEO_CAPTURE_DRIVERS
+
+#
+# NXP HDMI TDA19989 configuration
+#
+config HDMI_TDA19989
+	tristate "NXP HDMI 1.3 Transmitter driver"
+	depends on I2C
+	help
+	  to support HDMI1.3 transmitter
+	  with 3*8bit video inputs and CEC.
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 283a852..a987332 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -112,6 +112,8 @@ obj-$(CONFIG_VIDEO_OMAP3) += omap34xxcam.o
 
 obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
 obj-$(CONFIG_VIDEO_MT9P012)     += mt9p012.o
+obj-$(CONFIG_VIDEO_OV8810)     += ov8810.o
+obj-$(CONFIG_VIDEO_MIPI_DLI_TEST) += mipi_dli.o
 obj-$(CONFIG_VIDEO_OMAP3_HP3A) += hp3a/
 obj-$(CONFIG_VIDEO_OMAP3_HPLENS) += hplens.o
 
@@ -162,6 +164,7 @@ obj-$(CONFIG_VIDEO_AU0828) += au0828/
 
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
 
+obj-$(CONFIG_HDMI_TDA19989) += tda19989.o
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 EXTRA_CFLAGS += -Idrivers/media/dvb/frontends
 EXTRA_CFLAGS += -Idrivers/media/common/tuners
diff --git a/drivers/media/video/hp3a/hp3a.h b/drivers/media/video/hp3a/hp3a.h
index eb3b9c8..760d224 100644
--- a/drivers/media/video/hp3a/hp3a.h
+++ b/drivers/media/video/hp3a/hp3a.h
@@ -31,6 +31,7 @@ void hp3a_frame_done(void);
 void hp3a_stream_on(void);
 void hp3a_stream_off(void);
 void hp3a_ccdc_start(void);
+void hp3a_update_wb(void);
 int hp3a_hist_busy(void);
 int hp3a_af_busy(void);
 void hp3a_set_sensor_sync(unsigned char exposure, unsigned char gain);
diff --git a/drivers/media/video/hp3a/hp3a_af.c b/drivers/media/video/hp3a/hp3a_af.c
index bb08632..d90a9dc 100644
--- a/drivers/media/video/hp3a/hp3a_af.c
+++ b/drivers/media/video/hp3a/hp3a_af.c
@@ -123,9 +123,8 @@ void hp3a_disable_af(void)
 static void hp3a_af_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 			void *arg2)
 {
-	if (unlikely((H3A_AF_DONE & status) != H3A_AF_DONE)) {
+	if (unlikely((H3A_AF_DONE & status) != H3A_AF_DONE))
 		return;
-	}
 
 	/* clear IRQ status bit.*/
 	/*
@@ -158,9 +157,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		/* Install AF callback. */
 		ret = isp_set_callback(CBK_H3A_AF_DONE, hp3a_af_isr,
 					(void *)NULL, (void *)NULL);
-		if (ret) {
+		if (ret)
 			return ret;
-		}
 
 		if (hp3a_af_busy()) {
 			dev_info(device->dev, "Error: AF engine is busy!\n");
@@ -206,7 +204,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 
 		/* Validate paxel dimessions. */
 		if (config->paxel.width < 16 || config->paxel.width > 256 ||
-			config->paxel.height < 2 ||  config->paxel.height > 256) {
+			config->paxel.height < 2 ||
+			config->paxel.height > 256) {
 			dev_info(device->dev,
 				"Error: Invalid paxel dimention %d-%d\n",
 				config->paxel.width, config->paxel.height);
@@ -222,12 +221,13 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		/* IIR filter hz start setup. */
 		WRITE_REG(isp_af_regs[4].val, config->iir.hz_start_pos);
 
-		/* Setup paxel start position after IIR filter hz start setup. */
+		/* Setup paxel start position after */
+		/* IIR filter hz start setup. */
 		if (config->paxel.hz_start < (config->iir.hz_start_pos + 1) ||
 			config->paxel.hz_start > 4095 ||
 			config->paxel.vt_start > 4095) {
 			dev_info(device->dev,
-				"Error : Invalid paxel start position. (hz=%d vt=%d)\n",
+				"Error : Invalid paxel start. (hz=%d vt=%d)\n",
 				config->paxel.hz_start, config->paxel.vt_start);
 			goto func_exit;
 		}
@@ -250,7 +250,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 			goto func_exit;
 		}
 
-		if (config->paxel.line_incr > 8 || config->paxel.line_incr < 2) {
+		if (config->paxel.line_incr > 8 ||
+			config->paxel.line_incr < 2) {
 			dev_info(device->dev,
 				"Error: Invalid paxel line increment %d\n",
 				config->paxel.line_incr);
@@ -262,18 +263,23 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		OR_REG(isp_af_regs[2].val,
 			(config->paxel.vt_cnt - 1) << AF_VT_COUNT_SHIFT);
 		OR_REG(isp_af_regs[2].val,
-			((config->paxel.line_incr >> 1) - 1) << AF_LINE_INCR_SHIFT);
+			((config->paxel.line_incr >> 1) - 1) <<
+			AF_LINE_INCR_SHIFT);
 
 		/* Validate IIR filter coefficients. */
 		for (index = 0; index < AF_NUMBER_OF_COEF; ++index) {
 			if ((config->iir.coeff_set0[index]) > AF_COEF_MAX) {
 				dev_info(device->dev,
-					"Error : Coefficient(%d) for set 0 is incorrect\n", index);
+					"Err : Coefficient %d for set 0 "
+					" is incorrect\n",
+					index);
 				goto func_exit;
 			}
 			if ((config->iir.coeff_set1[index]) > AF_COEF_MAX) {
 				dev_info(device->dev,
-					"Error : Coefficient for(%d) set 1 is incorrect\n", index);
+					"Err : Coefficient %d for set 1 "
+					"wrong\n",
+					index);
 				goto func_exit;
 			}
 		}
diff --git a/drivers/media/video/hp3a/hp3a_common.h b/drivers/media/video/hp3a/hp3a_common.h
index 700733f..54141b5 100644
--- a/drivers/media/video/hp3a/hp3a_common.h
+++ b/drivers/media/video/hp3a/hp3a_common.h
@@ -43,7 +43,7 @@
 #define  AND_REG(x, v)		(x &= (u32)v)
 
 /* hp3a specific default values. */
-#define  MIN_RAW_CAPTURE_INTERVAL	2
+#define  MIN_RAW_CAPTURE_INTERVAL	1
 #define  MAX_STAT_BUFFERS_PER_FRAME	3
 
 enum {
@@ -127,6 +127,7 @@ struct hp3a_3x3with_offset {
 struct hp3a_sensor_param {
 	u32 exposure;
 	u16 gain;
+	u16 fps;
 };
 
 /**
@@ -140,6 +141,7 @@ struct hp3a_sensor_param_internal {
 	u32 frame_id;
 	u32 exposure;
 	u16 gain;
+	u16 fps;
 };
 
 /**
@@ -167,9 +169,9 @@ struct hp3a_histogram_config {
    u32 enable;
 	u8 hist_source;		/* CCDC or Memory */
 	u8 input_bit_width;	/* Needed o know the size per pixel */
-	u8 hist_frames;		/* Numbers of frames to be processed and accumulated */
-	u8 hist_h_v_info;	/* frame-input width and height if source is memory */
-	u8 hist_packed_pxl;	/* If data is packed packed 8-bit into 16 bits */
+	u8 hist_frames;	/* Num frames to be processed, accumulated */
+	u8 hist_h_v_info;	/* input width and height if source is memory */
+	u8 hist_packed_pxl;	/* If data is packed packed 8 into 16 bits */
 	u16 hist_radd;		/* frame-input address in memory */
 	u16 hist_radd_off;	/* line-offset for frame-input */
 	u16 hist_bins;		/* number of bins: 32, 64, 128, or 256 */
@@ -245,6 +247,7 @@ struct hp3a_statistics {
  **/
 struct hp3a_context {
 	int initialized;
+	int default_v4l2_dev;
 	int v4l2_streaming;
 	int update_hardpipe;
 	int hist_done;
@@ -259,10 +262,9 @@ struct hp3a_context {
 	u8 exposure_sync;
 	u8 gain_sync;
 	u32 hist_bin_size;
-	u32 current_exposure;
-	u32 current_gain;
-	u32 exposure;
-	u16 gain;
+	struct hp3a_sensor_param sensor_current;
+	struct hp3a_sensor_param sensor_requested;
+	struct hp3a_sensor_param sensor_stats;
 	u32 frame_count;
 	u32 req_af_buffer_size;
 	u32 req_raw_buffer_size;
diff --git a/drivers/media/video/hp3a/hp3a_ext.c b/drivers/media/video/hp3a/hp3a_ext.c
index b0f82c2..49faf20 100644
--- a/drivers/media/video/hp3a/hp3a_ext.c
+++ b/drivers/media/video/hp3a/hp3a_ext.c
@@ -33,7 +33,6 @@
  **/
 void hp3a_ccdc_done(void)
 {
-	++g_tc.frame_count;
 	hp3a_update_stats_readout_done();
 }
 EXPORT_SYMBOL(hp3a_ccdc_done);
@@ -45,6 +44,7 @@ EXPORT_SYMBOL(hp3a_ccdc_done);
  **/
 void hp3a_ccdc_start(void)
 {
+	++g_tc.frame_count;
 	hp3a_schedule_task();
 }
 EXPORT_SYMBOL(hp3a_ccdc_start);
@@ -57,11 +57,21 @@ EXPORT_SYMBOL(hp3a_ccdc_start);
 void hp3a_frame_done(void)
 {
 	hp3a_update_stats_pipe_done();
-	hp3a_update_hardpipe();
 }
 EXPORT_SYMBOL(hp3a_frame_done);
 
 /**
+ * hp3a_update_wb - Update WB related hw settings.
+ *
+ * No return value.
+ **/
+void hp3a_update_wb(void)
+{
+	hp3a_update_hardpipe();
+}
+EXPORT_SYMBOL(hp3a_update_wb);
+
+/**
  * hp3a_stream_on - Perform stream on specific tasks.
  *
  * No return value.
@@ -69,6 +79,11 @@ EXPORT_SYMBOL(hp3a_frame_done);
 void hp3a_stream_on(void)
 {
 	g_tc.frame_count = 0;
+
+	memset(&g_tc.sensor_current, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_requested, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_stats, 0, sizeof(struct hp3a_sensor_param));
+
 	g_tc.v4l2_streaming = 1;
 	g_tc.raw_cap_sched_count = 0;
 
diff --git a/drivers/media/video/hp3a/hp3a_hardpipe.c b/drivers/media/video/hp3a/hp3a_hardpipe.c
index eb5efcd..f83ace3 100644
--- a/drivers/media/video/hp3a/hp3a_hardpipe.c
+++ b/drivers/media/video/hp3a/hp3a_hardpipe.c
@@ -28,8 +28,8 @@
  **/
 void hp3a_update_hardpipe(void)
 {
-	if (!(omap_readl(ISPPRV_PCR) & ISPPRV_PCR_BUSY) &&
-		g_tc.update_hardpipe == 1) {
+	if (g_tc.update_hardpipe == 1 &&
+		!(omap_readl(ISPPRV_PCR) & ISPPRV_PCR_BUSY)) {
 		omap_writel(g_tc.hpipe_param.dgain, ISPPRV_WB_DGAIN);
 
 		omap_writel(g_tc.hpipe_param.r_gain |
diff --git a/drivers/media/video/hp3a/hp3a_histogram.c b/drivers/media/video/hp3a/hp3a_histogram.c
index 755834e..25919ea 100644
--- a/drivers/media/video/hp3a/hp3a_histogram.c
+++ b/drivers/media/video/hp3a/hp3a_histogram.c
@@ -106,19 +106,18 @@ static void hp3a_histogram_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 	u32 i;
 	struct hp3a_internal_buffer *ibuffer = NULL;
 
-	if (unlikely((HIST_DONE & status) != HIST_DONE)) {
+	if (unlikely((HIST_DONE & status) != HIST_DONE))
 		return;
-	}
 
 	omap_writel(omap_readl(ISPHIST_PCR) & ~(ISPHIST_PCR_EN), ISPHIST_PCR);
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (unlikely(g_tc.v4l2_streaming == 0))
 		return;
-	}
 
 	if (hp3a_dequeue(&g_tc.hist_hw_queue,  &ibuffer) == 0) {
 		/* If there is a buffer available then fill it. */
-		hist_buffer = (u32 *)phys_to_virt(page_to_phys(ibuffer->pages[0]));
+		hist_buffer = (u32 *)phys_to_virt(
+			page_to_phys(ibuffer->pages[0]));
 
 		omap_writel((omap_readl(ISPHIST_CNT)) | \
 			ISPHIST_CNT_CLR_EN, ISPHIST_CNT);
@@ -129,10 +128,10 @@ static void hp3a_histogram_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 		omap_writel((omap_readl(ISPHIST_CNT)) & ~ISPHIST_CNT_CLR_EN,
 			ISPHIST_CNT);
 	} else {
-		/* There are no buffers availavle so just clear internal histogram memory. */
-		for (i = g_tc.hist_bin_size; i--;) {
+		/* There are no buffers availavle so just */
+		/* clear internal histogram memory. */
+		for (i = g_tc.hist_bin_size; i--;)
 			omap_writel(0, ISPHIST_DATA);
-		}
 	}
 
 	/* Set memory HW memory address and enable. */
@@ -169,12 +168,12 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		/* Install HIST_IRQ callback. */
 		ret = isp_set_callback(CBK_HIST_DONE, hp3a_histogram_isr,
 					(void *)NULL, (void *)NULL);
-		if (ret) {
+		if (ret)
 			return ret;
-		}
 
 		if (hp3a_hist_busy()) {
-			dev_info(device->dev, "Error: Histogram engine is busy!\n");
+			dev_info(device->dev, \
+				"Error: Histogram engine is busy\n");
 			return -EINVAL;
 		}
 
@@ -190,27 +189,35 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 
 		if (config->hist_source) {
 			/* source is memory. */
-			WRITE_HV_INFO(isp_hist_regs[14].val, config->hist_h_v_info);
+			WRITE_HV_INFO(isp_hist_regs[14].val,
+				config->hist_h_v_info);
 
-			if ((config->hist_radd & ISP_32B_BOUNDARY_BUF) == config->hist_radd) {
-				WRITE_RADD(isp_hist_regs[12].val, config->hist_radd);
+			if ((config->hist_radd & ISP_32B_BOUNDARY_BUF) ==
+				config->hist_radd) {
+				WRITE_RADD(isp_hist_regs[12].val,
+					config->hist_radd);
 			} else {
-				dev_info(device->dev, "Error: Address should be in 32 byte boundary\n");
+				dev_info(device->dev,
+					"Err: Addr needs 32 byte boundary\n");
 				goto func_exit;
 			}
 
-			if ((config->hist_radd_off & ISP_32B_BOUNDARY_OFFSET) == config->hist_radd_off) {
-				WRITE_RADD_OFF(isp_hist_regs[13].val, config->hist_radd_off);
+			if ((config->hist_radd_off &
+				ISP_32B_BOUNDARY_OFFSET) ==
+				config->hist_radd_off) {
+				WRITE_RADD_OFF(isp_hist_regs[13].val, \
+					config->hist_radd_off);
 			} else {
-				dev_info(device->dev, "Error: Offset should be in 32 byte boundary\n");
+				dev_info(device->dev,
+					"Err: Offset needs 32 byte boundary\n");
 				goto func_exit;
 			}
 		}
 
-		/* set data size bit if the pixel data is 8-bit wide and 2 pixels are packed in to 16-bits. */
-		if (config->hist_packed_pxl) {
+		/* set data size bit if the pixel data is 8-bit wide and */
+		/* 2 pixels are packed in to 16-bits. */
+		if (config->hist_packed_pxl)
 			WRITE_DATA_SIZE(isp_hist_regs[1].val, 1);
-		}
 
 		/* White Balance Field-to-Pattern Assignments */
 		if (unlikely((config->wb_gain_R > MAX_WB_GAIN)
@@ -227,9 +234,8 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		}
 
 		/* Regions size and position */
-		if (config->num_regions > MAX_REGIONS) {
+		if (config->num_regions > MAX_REGIONS)
 			goto func_exit;
-		}
 
 		/* Region 0. */
 		WRITE_REG_HORIZ(isp_hist_regs[3].val, config->reg0_hor);
@@ -251,8 +257,10 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		/* Number of Bins. */
 		if (unlikely(((config->hist_bins > BINS_256) &&
 			(config->hist_bins != BINS_32)) ||
-			((config->hist_bins == BINS_256) && config->num_regions != 0) ||
-			((config->hist_bins == BINS_128) && config->num_regions >= 2))) {
+			((config->hist_bins == BINS_256) &&
+			config->num_regions != 0) ||
+			((config->hist_bins == BINS_128) &&
+			config->num_regions >= 2))) {
 			dev_info(device->dev,
 				"Error: Invalid Bins Number: %d\n",
 				config->hist_bins);
@@ -273,13 +281,16 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 				g_tc.hist_bin_size = HIST_MEM_SIZE;
 			} else if (config->hist_bins == BINS_128) {
 				bit_shift = config->input_bit_width - 7;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(1-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(1-config->num_regions));
 			} else if (config->hist_bins == BINS_64) {
 				bit_shift = config->input_bit_width - 6;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(2-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(2-config->num_regions));
 			} else if (config->hist_bins == BINS_32) {
 				bit_shift = config->input_bit_width - 5;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(3-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(3-config->num_regions));
 			} else {
 				goto func_exit;
 			}
diff --git a/drivers/media/video/hp3a/hp3a_ioctl.c b/drivers/media/video/hp3a/hp3a_ioctl.c
index ffc3ad3..32be4f0 100644
--- a/drivers/media/video/hp3a/hp3a_ioctl.c
+++ b/drivers/media/video/hp3a/hp3a_ioctl.c
@@ -60,9 +60,9 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		ret = hp3a_collect_statistics(&statistics);
 		if (SUCCEEDED(ret)) {
 			if (copy_to_user((struct hp3a_statistics *)arg,
-				&statistics, sizeof(struct hp3a_statistics)) != 0) {
+				&statistics,
+				sizeof(struct hp3a_statistics)) != 0)
 				ret = -EFAULT;
-			}
 		}
 		break;
 	}
@@ -107,7 +107,8 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
-			ret = hp3a_enqueue_irqsave(&g_tc.hist_stat_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.hist_stat_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -122,16 +123,19 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
 			if (ibuffer->isp_addr == 0) {
-				ibuffer->isp_addr = ispmmu_map_pages(ibuffer->pages,
+				ibuffer->isp_addr =
+					ispmmu_map_pages(ibuffer->pages,
 					NR_PAGES((unsigned long)ibuffer->user_addr,
 					ibuffer->buffer_size));
 				if (ibuffer->isp_addr == 0) {
-					dev_err(device->dev , "isp mmu failed to map memory!\n");
+					dev_err(device->dev , \
+						"isp mmu fail to map memory\n");
 					return -EFAULT;
 				}
 			}
 			flush_dcache_ibuffer(ibuffer);
-			ret = hp3a_enqueue_irqsave(&g_tc.af_stat_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.af_stat_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -146,15 +150,18 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
 			if (ibuffer->isp_addr == 0) {
-				ibuffer->isp_addr = ispmmu_map_pages(ibuffer->pages,
+				ibuffer->isp_addr =
+					ispmmu_map_pages(ibuffer->pages,
 					NR_PAGES((unsigned long)ibuffer->user_addr,
 					ibuffer->buffer_size));
 				if (ibuffer->isp_addr == 0) {
-					dev_err(device->dev , "isp mmu failed to map memory!\n");
+					dev_err(device->dev , \
+						"isp mmu fail to map memory\n");
 					return -EFAULT;
 				}
 			}
-			ret = hp3a_enqueue_irqsave(&g_tc.raw_frame_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.raw_frame_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -172,13 +179,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 			ret = -1;
 			if (req_buf.count > 0) {
 				fh->buffers = kzalloc(req_buf.count * \
-						sizeof(struct hp3a_internal_buffer),
-						GFP_KERNEL);
+					sizeof(struct hp3a_internal_buffer),
+					GFP_KERNEL);
 				if (fh->buffers) {
 					fh->buffer_count = req_buf.count;
-					for (i = 0; i < fh->buffer_count; ++i) {
+					for (i = 0; i < fh->buffer_count; ++i)
 						fh->buffers[i].index = i;
-					}
 					ret = 0;
 				}
 			}
@@ -198,10 +204,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 				(struct hp3a_buffer *)arg,
 				sizeof(struct hp3a_buffer)) == 0) {
 			ret = -1;
-			if (buffer.index >= 0 && buffer.index < fh->buffer_count) {
-				if (fh->buffers[buffer.index].buffer_size == 0) {
+			if (buffer.index >= 0 && buffer.index <
+				fh->buffer_count) {
+				if (fh->buffers[buffer.index].buffer_size
+					==	0) {
 					ret = map_user_to_kernel(&buffer,
-							&(fh->buffers[buffer.index]));
+						&(fh->buffers[buffer.index]));
 				}
 			}
 		} else {
@@ -220,10 +228,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 				(struct hp3a_buffer *)arg,
 				sizeof(struct hp3a_buffer)) == 0) {
 			ret = -1;
-			if (buffer.index >= 0 && buffer.index < fh->buffer_count) {
+			if (buffer.index >= 0 && buffer.index <
+				fh->buffer_count) {
 				if (fh->buffers[buffer.index].buffer_size &&
-						fh->buffers[buffer.index].pages) {
-					unmap_buffer_from_kernel(&(fh->buffers[buffer.index]));
+					fh->buffers[buffer.index].pages) {
+					unmap_buffer_from_kernel(
+						&(fh->buffers[buffer.index]));
 					ret = 0;
 				}
 			}
@@ -278,10 +288,9 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 			ret = hp3a_configure_raw(&config);
 			if (SUCCEEDED(ret)) {
 				if (copy_to_user((struct hp3a_raw_config *)arg,
-						&config,
-						sizeof(struct hp3a_raw_config)) != 0) {
+					&config,
+					sizeof(struct hp3a_raw_config)) != 0)
 					ret = -EFAULT;
-				}
 			}
 		} else {
 			ret = -EFAULT;
@@ -318,6 +327,7 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 	 */
 	case HP3A_S_V4L2_DEV_INDEX: {
 		fh->v4l2_dev = (int)arg;
+		g_tc.default_v4l2_dev = fh->v4l2_dev;
 		ret = 0;
 		break;
 	}
diff --git a/drivers/media/video/hp3a/hp3a_queue.c b/drivers/media/video/hp3a/hp3a_queue.c
index 9d7e553..0f374a0 100644
--- a/drivers/media/video/hp3a/hp3a_queue.c
+++ b/drivers/media/video/hp3a/hp3a_queue.c
@@ -29,7 +29,8 @@
  *
  * No return value.
  **/
-int hp3a_initialize_queue(struct hp3a_queue *queue, int queue_size, unsigned int element_size)
+int hp3a_initialize_queue(struct hp3a_queue *queue,
+		int queue_size, unsigned int element_size)
 {
 	if (queue_size > 0 && element_size > 0) {
 		queue->data = kmalloc(queue_size * element_size,  GFP_KERNEL);
@@ -161,7 +162,6 @@ int hp3a_dequeue(struct hp3a_queue *queue, void *element)
 
 		/* copy data from queue to element. */
 		memcpy(element, item, queue->element_size);
-
 		ret = 0;
 	}
 
@@ -195,7 +195,6 @@ int hp3a_dequeue_irqsave(struct hp3a_queue *queue, void *element)
 
 		/* copy data from queue to element. */
 		memcpy(element, item, queue->element_size);
-
 		ret = 0;
 	}
 
diff --git a/drivers/media/video/hp3a/hp3a_raw.c b/drivers/media/video/hp3a/hp3a_raw.c
index dc92e2e..2e81c0a 100644
--- a/drivers/media/video/hp3a/hp3a_raw.c
+++ b/drivers/media/video/hp3a/hp3a_raw.c
@@ -24,11 +24,7 @@
 
 static struct hp3a_reg isp_raw_regs[] = {
 	{HP3A_REG_32BIT, ISPCCDC_SYN_MODE, 0},
-	{HP3A_REG_32BIT, ISPCCDC_HORZ_INFO, 0},
-	{HP3A_REG_32BIT, ISPCCDC_VERT_START, 0},
-	{HP3A_REG_32BIT, ISPCCDC_VERT_LINES, 0},
 	{HP3A_REG_32BIT, ISPCCDC_HSIZE_OFF, 0},
-	{HP3A_REG_32BIT, ISPCCDC_SDOFST, 0},
 	{HP3A_REG_32BIT, ISPCCDC_SDR_ADDR, 0},
 	{HP3A_REG_32BIT, ISPCCDC_CFG, 0},
 	{HP3A_REG_TOK_TERM, 0, 0}
@@ -42,7 +38,7 @@ static struct hp3a_reg isp_raw_regs[] = {
 void hp3a_enable_raw(unsigned long buffer_addr)
 {
 	if (likely(buffer_addr != 0)) {
-		if (likely(g_tc.isp_ctx_saved == 0)) {
+		if (g_tc.isp_ctx_saved == 0) {
 			/* Save ISP registers. */
 			hp3a_read_ispregs(isp_raw_regs);
 			g_tc.isp_ctx_saved = 1;
@@ -60,19 +56,22 @@ void hp3a_enable_raw(unsigned long buffer_addr)
 		omap_writel(buffer_addr, ISPCCDC_SDR_ADDR);
 
 		/* Set register for line memory offset*/
-		omap_writel(ALIGN_TO((g_tc.raw_width << 1), 32), ISPCCDC_HSIZE_OFF);
+		omap_writel(ALIGN_TO((g_tc.raw_width << 1), 32),
+					ISPCCDC_HSIZE_OFF);
 
-		/*0 - By default Donot inverse the field identification */
-		omap_writel((omap_readl(ISPCCDC_SDOFST) & (~ISPCCDC_SDOFST_FINV)),
-								ISPCCDC_SDOFST);
-
-		/*0 - By default one line offset*/
-		omap_writel(omap_readl(ISPCCDC_SDOFST) & ISPCCDC_SDOFST_FOFST_1L,
-				ISPCCDC_SDOFST);
+		/*
+			The following registers must be set during CCDC config.
+			CCDC_HORZ_INFO
+			CCDC_VERT_START
+			CCDC_VERT_LINES
+			CCDC_SDOFST
+		*/
 
 		/* ISPCCDC_SYN_MODE must be set last. */
-		omap_writel((omap_readl(ISPCCDC_SYN_MODE) | ISPCCDC_SYN_MODE_WEN |
-				ISPCCDC_SYN_MODE_EXWEN | ISPCCDC_SYN_MODE_VP2SDR),
+		omap_writel((omap_readl(ISPCCDC_SYN_MODE) |
+				ISPCCDC_SYN_MODE_WEN |
+				ISPCCDC_SYN_MODE_EXWEN |
+				ISPCCDC_SYN_MODE_VP2SDR),
 				ISPCCDC_SYN_MODE);
 	}
 }
@@ -84,7 +83,7 @@ void hp3a_enable_raw(unsigned long buffer_addr)
  **/
 void hp3a_disable_raw(void)
 {
-	if (likely(g_tc.isp_ctx_saved == 1)) {
+	if (g_tc.isp_ctx_saved == 1) {
 		/* Restore ISP registers. */
 		hp3a_write_ispregs(isp_raw_regs);
 		g_tc.isp_ctx_saved = 0;
@@ -123,7 +122,8 @@ int hp3a_configure_raw(struct hp3a_raw_config *raw)
 		if (likely(g_tc.raw_width != 0 && g_tc.raw_height != 0)) {
 			g_tc.raw_hw_configured = 1;
 			g_tc.req_raw_buffer_size = (u32)ALIGN_TO(((ALIGN_TO( \
-				g_tc.raw_width, 16)*g_tc.raw_height)<<1), 0x1000);
+				g_tc.raw_width, 16)*g_tc.raw_height)<<1), \
+				0x1000);
 		} else {
 			g_tc.raw_hw_configured = 0;
 			g_tc.req_raw_buffer_size = -1;
diff --git a/drivers/media/video/hp3a/hp3a_stats.c b/drivers/media/video/hp3a/hp3a_stats.c
index f74b237..094b7ed 100644
--- a/drivers/media/video/hp3a/hp3a_stats.c
+++ b/drivers/media/video/hp3a/hp3a_stats.c
@@ -24,6 +24,7 @@
 
 #include "hp3a_common.h"
 #include "hp3a_queue.h"
+#include "hp3a_ispreg.h"
 #include "../oldomap34xxcam.h"
 #include "ispccdc.h"
 
@@ -62,10 +63,11 @@ void initialize_hp3a_framework(struct hp3a_dev *device)
 		g_tc.raw_width = 0;
 		g_tc.raw_height = 0;
 		g_tc.histogram_buffer = NULL;
-		g_tc.af_buffer  = NULL;
-		g_tc.raw_buffer  = NULL;
+		g_tc.af_buffer = NULL;
+		g_tc.raw_buffer = NULL;
 		g_tc.exposure_sync = 2;
 		g_tc.gain_sync = 1;
+		g_tc.default_v4l2_dev = 0;
 
 		/* Initialize task queues. */
 		hp3a_initialize_queue(&g_tc.hist_stat_queue, 8,
@@ -117,15 +119,14 @@ void hp3a_framework_start(struct hp3a_fh *fh)
 	fh->buffer_count = 0;
 	fh->buffers = NULL;
 	g_tc.frame_done.done = 0;
-	g_tc.current_exposure = 0;
-	g_tc.current_gain = 0;
-	g_tc.exposure = 0;
-	g_tc.gain = 0;
 	g_tc.hist_done = 0;
 	g_tc.hist_hw_enable = 0;
 	g_tc.af_hw_enable = 0;
-	g_tc.raw_hw_configured = 0;
 	g_tc.isp_ctx_saved = 0;
+
+	memset(&g_tc.sensor_current, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_requested, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_stats, 0, sizeof(struct hp3a_sensor_param));
 }
 
 /**
@@ -140,22 +141,17 @@ void hp3a_framework_stop(struct hp3a_fh *fh)
 
 	spin_lock_irqsave(&g_tc.stats_lock, irqflags);
 
-	/* Reset flags. */
-	g_tc.v4l2_streaming = 0;
-
 	/* Need to flush queue. */
 	hp3a_flush_queue(&g_tc.sensor_write_queue);
 	hp3a_flush_queue(&g_tc.sensor_read_queue);
 	hp3a_flush_queue(&g_tc.raw_frame_queue);
 	hp3a_flush_queue(&g_tc.af_stat_queue);
 	hp3a_flush_queue(&g_tc.hist_stat_queue);
-	hp3a_flush_queue(&g_tc.hist_hw_queue);
-	hp3a_flush_queue(&g_tc.ready_stats_queue);
 
 	/* Internal buffer clean up. */
-	for (i = 0; i < fh->buffer_count; ++i) {
+	for (i = 0; i < fh->buffer_count; ++i)
 		unmap_buffer_from_kernel(&(fh->buffers[i]));
-	}
+
 	kfree(fh->buffers);
 	fh->buffers = NULL;
 
@@ -186,40 +182,63 @@ void hp3a_framework_stop(struct hp3a_fh *fh)
 int hp3a_set_sensor_param(struct hp3a_sensor_param *param, struct hp3a_fh *fh)
 {
 	int ret = -1;
-	struct hp3a_sensor_param_internal sensor_param;
+	struct hp3a_sensor_param_internal sensor_param = {
+		.exposure = 0,
+		.gain = 0,
+		.fps = 0};
 
 	if (likely(fh->v4l2_dev > -1)) {
 		if (likely(g_tc.v4l2_streaming == 1)) {
 			sensor_param.v4l2_dev = fh->v4l2_dev;
 			ret = 0;
 
-			if (g_tc.current_exposure != param->exposure) {
+			/* queue fps & exposure together */
+			if (param->fps && g_tc.sensor_requested.fps != \
+					param->fps) {
+				g_tc.sensor_requested.fps = param->fps;
+				sensor_param.fps = param->fps;
+			}
+
+			if (param->exposure &&
+					abs(g_tc.sensor_requested.exposure - \
+					param->exposure) > 2) {
+				g_tc.sensor_requested.exposure = \
+					param->exposure;
 				sensor_param.exposure = param->exposure;
-				sensor_param.gain = 0;
+			}
 
-				ret = hp3a_enqueue(&g_tc.sensor_write_queue,
-							&sensor_param);
+			if (sensor_param.fps || sensor_param.exposure) {
+				ret = hp3a_enqueue(
+				&g_tc.sensor_write_queue,
+				&sensor_param);
 			}
 
-			if (g_tc.current_gain != param->gain) {
-				sensor_param.exposure = 0;
+			if (param->gain &&
+				abs(g_tc.sensor_requested.gain - \
+					param->gain) > 2) {
+				g_tc.sensor_requested.gain = param->gain;
 				sensor_param.gain = param->gain;
-
-				ret = hp3a_enqueue(&g_tc.sensor_write_queue,
-						&sensor_param);
+				sensor_param.exposure = 0;
+				sensor_param.fps = 0;
+				ret = hp3a_enqueue(
+					&g_tc.sensor_write_queue,
+					&sensor_param);
 			}
 		} else {
 			struct cam_sensor_settings sensor_settings = {
 			.flags = 0,
 			.exposure = 0,
 			.gain = 0,
+			.fps = 0,
 			.regs = 0,
 			.reg_data = 0};
 
 			sensor_settings.exposure = param->exposure;
 			sensor_settings.gain = param->gain;
+			sensor_settings.fps = param->fps;
 			sensor_settings.flags = (OMAP34XXCAM_SET_GAIN | \
-						OMAP34XXCAM_SET_EXPOSURE);
+						OMAP34XXCAM_SET_EXPOSURE | \
+						OMAP34XXCAM_SET_FPS);
 
 			/**
 			* Write and read sensor settings.
@@ -228,7 +247,9 @@ int hp3a_set_sensor_param(struct hp3a_sensor_param *param, struct hp3a_fh *fh)
 							&sensor_settings);
 		}
 	} else {
-		dev_err(fh->device->dev, "hp3a: Invalid sensor id(%d)\n", fh->v4l2_dev);
+		dev_err(fh->device->dev,
+			"hp3a: Invalid sensor id(%d)\n",
+			fh->v4l2_dev);
 	}
 
 	return ret;
@@ -251,9 +272,8 @@ int hp3a_set_hardpipe_param(struct hp3a_hardpipe_param *param,
 	g_tc.update_hardpipe = 1;
 	spin_unlock_irqrestore(&g_tc.hardpipe_lock, irqflags);
 
-	if (g_tc.v4l2_streaming == 0) {
+	if (g_tc.v4l2_streaming == 0)
 		hp3a_update_hardpipe();
-	}
 
 	return 0;
 }
@@ -268,9 +288,8 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 {
 	unsigned long irqflags = 0;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (unlikely(g_tc.v4l2_streaming == 0))
 		return -1;
-	}
 
 	/* Initialize buffer indexes. */
 	stat->hist_stat_index = -1;
@@ -293,8 +312,8 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 
 		/* Frame meta data. */
 		stat->frame_id = g_tc.frame_count;
-		stat->exposure = g_tc.exposure;
-		stat->gain = g_tc.gain;
+		stat->exposure = g_tc.sensor_stats.exposure;
+		stat->gain = g_tc.sensor_stats.gain;
 
 		/* Raw bayer frame. */
 		if (g_tc.raw_buffer != NULL) {
@@ -313,15 +332,16 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 		/* Histogram. */
 		if (g_tc.histogram_buffer != NULL) {
 			if (g_tc.hist_done  == 1) {
-				stat->hist_stat_index = g_tc.histogram_buffer->index;
+				stat->hist_stat_index = \
+					g_tc.histogram_buffer->index;
 			} else {
-				hp3a_enqueue(&g_tc.hist_stat_queue, &g_tc.histogram_buffer);
+				hp3a_enqueue(&g_tc.hist_stat_queue,
+					&g_tc.histogram_buffer);
 			}
 			g_tc.histogram_buffer = NULL;
 		}
 
 		g_tc.hist_done = 0;
-
 		spin_unlock_irqrestore(&g_tc.stats_lock, irqflags);
 	}
 
@@ -336,10 +356,12 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 void hp3a_update_stats_readout_done(void)
 {
 	int i;
+	bool allow_exp_update = true;
+	bool allow_gain_update = true;
 	struct hp3a_internal_buffer *ibuffer;
 	struct hp3a_sensor_param_internal sensor_param;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (g_tc.v4l2_streaming == 0) {
 		hp3a_disable_histogram();
 		hp3a_disable_af();
 		return;
@@ -369,15 +391,18 @@ void hp3a_update_stats_readout_done(void)
 	for (i = MAX_STAT_BUFFERS_PER_FRAME; i--;) {
 		ibuffer = NULL;
 		if (hp3a_dequeue(&g_tc.ready_stats_queue, &ibuffer) == 0) {
-			if (ibuffer->type == HISTOGRAM && g_tc.histogram_buffer == NULL)
+			if (ibuffer->type == HISTOGRAM &&
+					g_tc.histogram_buffer == NULL)
 				g_tc.histogram_buffer = ibuffer;
-			else if (ibuffer->type == PAXEL && g_tc.af_buffer == NULL)
+			else if (ibuffer->type == PAXEL &&
+						g_tc.af_buffer == NULL)
 				g_tc.af_buffer = ibuffer;
-			else if (ibuffer->type == BAYER && g_tc.raw_buffer == NULL)
+			else if (ibuffer->type == BAYER &&
+						g_tc.raw_buffer == NULL)
 				g_tc.raw_buffer = ibuffer;
 			else {
-				printk(KERN_ERR "hp3a: Error unknown buffer type(%d) in"
-							" ready queue\n", ibuffer->type);
+				printk(KERN_ERR "hp3a: Error unknown "
+				"buffer type(%d)\n", ibuffer->type);
 			}
 		} else {
 			break;
@@ -387,12 +412,25 @@ void hp3a_update_stats_readout_done(void)
 	for (i = QUEUE_COUNT(g_tc.sensor_read_queue); i--;) {
 		if (hp3a_dequeue(&g_tc.sensor_read_queue, &sensor_param) == 0) {
 			if (sensor_param.frame_id == g_tc.frame_count) {
-				if (sensor_param.exposure)
-					g_tc.exposure = sensor_param.exposure;
-				if (sensor_param.gain)
-					g_tc.gain = sensor_param.gain;
+				if (sensor_param.exposure == -1) {
+					g_tc.sensor_stats.exposure = 0;
+					allow_exp_update = false;
+				} else if (sensor_param.exposure && \
+						allow_exp_update) {
+					g_tc.sensor_stats.exposure = \
+						sensor_param.exposure;
+				}
+				if (sensor_param.gain == -1) {
+					g_tc.sensor_stats.gain = 0;
+					allow_gain_update = false;
+				} else if (sensor_param.gain && \
+						allow_gain_update) {
+					g_tc.sensor_stats.gain = \
+						sensor_param.gain;
+				}
 			} else if (sensor_param.frame_id > g_tc.frame_count) {
-				hp3a_enqueue(&g_tc.sensor_read_queue, &sensor_param);
+				hp3a_enqueue(&g_tc.sensor_read_queue,
+								&sensor_param);
 			}
 		} else {
 			break;
@@ -417,25 +455,30 @@ void hp3a_update_stats_pipe_done(void)
 {
 	struct hp3a_internal_buffer *ibuffer;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
-		hp3a_disable_raw();
+	hp3a_disable_raw();
+
+	if (g_tc.v4l2_streaming == 0)
 		return;
-	}
 
 	/* RAW stat buffer processing. */
 	if (g_tc.raw_hw_configured == 1) {
 		if ((++g_tc.raw_cap_sched_count) == g_tc.raw_frequency) {
+			if (omap_readl(ISPCCDC_PCR) & ISPCCDC_PCR_BUSY) {
+				--g_tc.raw_cap_sched_count;
+				return;
+			}
 			g_tc.raw_cap_sched_count = 0;
 			ibuffer = NULL;
-			if (hp3a_dequeue(&g_tc.raw_frame_queue, &ibuffer) == 0) {
-				if (ibuffer->buffer_size >= g_tc.req_raw_buffer_size) {
+			if (hp3a_dequeue(&g_tc.raw_frame_queue, &ibuffer)
+				== 0) {
+				if (ibuffer->buffer_size >=
+					g_tc.req_raw_buffer_size) {
 					hp3a_enable_raw(ibuffer->isp_addr);
 					ibuffer->type = BAYER;
-					hp3a_enqueue(&g_tc.ready_stats_queue, &ibuffer);
+					hp3a_enqueue(&g_tc.ready_stats_queue,
+						&ibuffer);
 				}
 			}
-		} else if (g_tc.raw_cap_sched_count == 1) {
-			hp3a_disable_raw();
 		}
 	}
 }
@@ -463,49 +506,84 @@ static void hp3a_task(struct work_struct *work)
 {
 	/* Place holder for deferred tasks. */
 	struct hp3a_sensor_param_internal sensor_param;
+	struct hp3a_sensor_param_internal empty_param = {
+		.exposure = 0,
+		.gain = 0,
+		.fps = 0};
 	struct cam_sensor_settings sensor_settings = {
 		.flags = 0,
 		.exposure = 0,
 		.gain = 0,
 		.regs = 0,
+		.fps = 0,
 		.reg_data = 0};
-	u32 frame_index = (g_tc.frame_count+1);
+	u32 cur_frame = g_tc.frame_count;
 
 	/**
 	 * Setup exposure and gain for next frame.
 	 */
-	if (hp3a_dequeue(&g_tc.sensor_write_queue, &sensor_param) == 0) {
+	if (hp3a_dequeue(&g_tc.sensor_write_queue,
+							&sensor_param) == 0) {
 		sensor_settings.exposure = sensor_param.exposure;
 		sensor_settings.gain = sensor_param.gain;
+		sensor_settings.fps = sensor_param.fps;
+
+		if (sensor_param.fps)
+			sensor_settings.flags |= OMAP34XXCAM_SET_FPS;
 
 		if (sensor_param.exposure)
 			sensor_settings.flags |= OMAP34XXCAM_SET_EXPOSURE;
+
 		if (sensor_param.gain)
 			sensor_settings.flags |= OMAP34XXCAM_SET_GAIN;
 
 		/**
-		* Write and read sensor settings.
-		*/
-		omap34xxcam_sensor_settings(sensor_param.v4l2_dev, &sensor_settings);
-
-		if (g_tc.current_gain != sensor_settings.gain) {
-			sensor_param.frame_id = (frame_index + g_tc.gain_sync);
+		 * Write and read sensor settings.
+		 */
+		omap34xxcam_sensor_settings(sensor_param.v4l2_dev,
+			&sensor_settings);
+
+		if (g_tc.sensor_current.gain != sensor_settings.gain) {
+			if (g_tc.gain_sync > 1) {
+				empty_param.frame_id = cur_frame + 1;
+				empty_param.gain = -1;
+				hp3a_enqueue_irqsave(
+					&g_tc.sensor_read_queue,
+					&empty_param);
+			}
+			sensor_param.frame_id = \
+				(cur_frame + g_tc.gain_sync);
+			sensor_param.fps = sensor_settings.fps;
 			sensor_param.exposure = 0;
 			sensor_param.gain = sensor_settings.gain;
 			/* Queue new value for stats collecton. */
-			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue, &sensor_param);
+			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue,
+				&sensor_param);
 			/* Save new programmed in gain value. */
-			g_tc.current_gain = sensor_settings.gain;
+			g_tc.sensor_current.gain = sensor_settings.gain;
 		}
 
-		if (g_tc.current_exposure != sensor_settings.exposure) {
-			sensor_param.frame_id = (frame_index + g_tc.exposure_sync);
+		if (g_tc.sensor_current.exposure != sensor_settings.exposure) {
+			if (g_tc.exposure_sync > 1) {
+				empty_param.frame_id = cur_frame + 1;
+				empty_param.gain = 0;
+				empty_param.exposure = -1;
+				hp3a_enqueue_irqsave(
+					&g_tc.sensor_read_queue,
+					&empty_param);
+			}
+			sensor_param.frame_id = \
+				(cur_frame + g_tc.exposure_sync);
+			sensor_param.fps = sensor_settings.fps;
 			sensor_param.exposure = sensor_settings.exposure;
 			sensor_param.gain = 0;
 			/* Queue new value for stats collecton. */
-			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue, &sensor_param);
+			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue,
+				&sensor_param);
 			/* Save new programmed in exposure value. */
-			g_tc.current_exposure = sensor_settings.exposure;
+			g_tc.sensor_current.exposure = sensor_settings.exposure;
 		}
+
+		g_tc.sensor_current.fps = sensor_settings.fps;
 	}
 }
diff --git a/drivers/media/video/hplens.c b/drivers/media/video/hplens.c
index ad29e04..d687519 100644
--- a/drivers/media/video/hplens.c
+++ b/drivers/media/video/hplens.c
@@ -258,7 +258,8 @@ static int hplens_ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power on)
  * from the video_control[] array.  Otherwise, returns -EINVAL if the
  * control is not supported.
  */
-static int hplens_ioctl_queryctrl(struct v4l2_int_device *s, struct v4l2_queryctrl *qc)
+static int hplens_ioctl_queryctrl(struct v4l2_int_device *s,
+			struct v4l2_queryctrl *qc)
 {
 	int i;
 
@@ -298,36 +299,42 @@ static int hplens_ioctl_s_ctrl(struct v4l2_int_device *s,
 
 	switch (vc->id) {
 	case V4L2_CID_HPLENS_CMD_READ: {
-		ret = copy_from_user(&reg, (void *)vc->value,  sizeof(struct hplens_reg));
+		ret = copy_from_user(&reg, (void *)vc->value,  \
+			sizeof(struct hplens_reg));
 		if (ret == 0) {
-			if (reg.addr[0] != 0xff) {   /* valid register address */
+			if (reg.addr[0] != 0xff) {
+				/* valid register address */
 				/* write the register address to read */
-				ret = hplens_reg_write(reg.dev_addr, reg.addr, reg.len_addr);
+				ret = hplens_reg_write(reg.dev_addr, \
+					reg.addr, reg.len_addr);
 			}
 			/* Read the register */
-			ret = hplens_reg_read(reg.dev_addr, reg.data, reg.len_data);
+			ret = hplens_reg_read(reg.dev_addr, \
+				reg.data, reg.len_data);
 			if (ret == 0) {
-				ret = copy_to_user((void *)vc->value, &reg, sizeof(struct hplens_reg));
+				ret = copy_to_user((void *)vc->value, &reg, \
+					sizeof(struct hplens_reg));
 			}
 		}
 	}
 	break;
 	case V4L2_CID_HPLENS_CMD_WRITE: {
-		ret = copy_from_user(&reg, (void *)vc->value,  sizeof(struct hplens_reg));
+		ret = copy_from_user(&reg, (void *)vc->value,  \
+			sizeof(struct hplens_reg));
 		if (ret == 0) {
 			if (reg.addr[0] != 0xff) { /* valid register address */
 				while (fdb < reg.len_addr) {
-					/* put the register address to write in the buffer first */
+					/* write register address in buffer */
 					write_buffer[fdb] = reg.addr[fdb];
 					fdb++;
 				}
 			}
 
-			for (idx = fdb; idx <= reg.len_data; idx++) {
+			for (idx = fdb; idx <= reg.len_data; idx++)
 				write_buffer[idx] = reg.data[idx-fdb];
-			}
 
-			ret = hplens_reg_write(reg.dev_addr, write_buffer, reg.len_data + fdb);
+			ret = hplens_reg_write(reg.dev_addr, \
+				write_buffer, reg.len_data + fdb);
 		}
 	}
 	break;
@@ -335,22 +342,25 @@ static int hplens_ioctl_s_ctrl(struct v4l2_int_device *s,
 
 		/* Using dynamic memory. */
 		eeprom = kmalloc(sizeof(struct hplens_eeprom), GFP_KERNEL);
-		if(eeprom == NULL){
+		if (eeprom == NULL)
 			return -EINVAL;
-		}
 
-		ret = copy_from_user(eeprom, (void *)vc->value,  sizeof(struct hplens_eeprom));
+		ret = copy_from_user(eeprom, (void *)vc->value,  \
+			sizeof(struct hplens_eeprom));
 		if (ret == 0) {
-			if (eeprom->addr[0] != 0xff) {   /* valid register address */
+			if (eeprom->addr[0] != 0xff) {
+				/* valid register address */
 				/* write the register address to read */
-				ret = hplens_reg_write(eeprom->dev_addr, eeprom->addr, eeprom->len_addr);
+				ret = hplens_reg_write(eeprom->dev_addr, \
+					eeprom->addr, eeprom->len_addr);
 			}
 
 			/* Read the register */
-			ret = hplens_reg_read(eeprom->dev_addr, eeprom->data, eeprom->len_data);
-			if (ret == 0) {
-				ret = copy_to_user((void *)vc->value, eeprom, sizeof(struct hplens_eeprom));
-			}
+			ret = hplens_reg_read(eeprom->dev_addr, \
+				eeprom->data, eeprom->len_data);
+			if (ret == 0)
+				ret = copy_to_user((void *)vc->value, eeprom, \
+					sizeof(struct hplens_eeprom));
 		}
 
 		/* clean up. */
@@ -401,7 +411,8 @@ static struct v4l2_int_device hplens_int_device = {
  *
  * Returns 0 if successful, or -EBUSY if unable to get client attached data.
  **/
-static int hplens_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static int hplens_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
 {
 	struct hplens_device *lens = &hplens;
 	int err;
@@ -427,7 +438,8 @@ static int hplens_probe(struct i2c_client *client, const struct i2c_device_id *i
 
 	err = v4l2_int_device_register(lens->v4l2_int_device);
 	if (err) {
-		printk(KERN_ERR "Failed to Register " DRIVER_NAME " as V4L2 device.\n");
+		printk(KERN_ERR "Failed to Register " \
+			DRIVER_NAME " as V4L2 device.\n");
 		i2c_set_clientdata(client, NULL);
 	} else {
 		printk(KERN_ERR "Registered " DRIVER_NAME " as V4L2 device.\n");
diff --git a/drivers/media/video/oldisp/isp.c b/drivers/media/video/oldisp/isp.c
index c407905..7566b0f 100644
--- a/drivers/media/video/oldisp/isp.c
+++ b/drivers/media/video/oldisp/isp.c
@@ -66,13 +66,11 @@
 #endif
 
 
-#if ISP_WORKAROUND
 void *buff_addr;
 dma_addr_t buff_addr_mapped;
 struct scatterlist *sglist_alloc;
 static int alloc_done, num_sc;
 unsigned long offset_value;
-#endif
 
 struct completion isp_wfc;
 
@@ -218,6 +216,7 @@ struct isp_sgdma ispsg;
 struct ispmodule {
 	unsigned int isp_pipeline;
 	int isp_temp_state;
+	int isp_lsc_workaround;
 	int applyCrop;
 	struct v4l2_pix_format pix;
 	unsigned int ccdc_input_width;
@@ -237,6 +236,7 @@ struct ispmodule {
 static struct ispmodule ispmodule_obj = {
 	.isp_pipeline = OMAP_ISP_CCDC,
 	.isp_temp_state = ISP_BUF_INIT,
+	.isp_lsc_workaround = ISP_WORKAROUND,
 	.applyCrop = 0,
 	.pix = {
 		.width = ISP_OUTPUT_WIDTH_DEFAULT,
@@ -278,6 +278,11 @@ static struct isp_reg isp_reg_list[] = {
 	{ISP_TOK_TERM, 0}
 };
 
+int isp_lsc_workaround_enabled(void)
+{
+	return ispmodule_obj.isp_lsc_workaround;
+}
+
 /*
  *
  * V4L2 Handling
@@ -347,30 +352,6 @@ void isp_release_resources(void)
 /* Flag to check first time of isp_get */
 static int off_mode;
 
-static void isp_lsc_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			void *arg2)
-{
-	(void) arg1;
-	(void) arg2;
-
-	if (status & LSC_PRE_ERR) {
-		/* printk(KERN_ERR "isp_sr: LSC_PRE_ERR \n"); */
-		ispccdc_enable_lsc(0);
-		ispccdc_enable_lsc(1);
-	}
-}
-
-static void isp_csia_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			void *arg2)
-{
-	(void) arg1;
-	(void) arg2;
-
-	if (status & CSIA) {
-		isp_csi2_isr();
-	}
-}
-
 /**
  * isp_set_sgdma_callback - Set Scatter-Gather DMA Callback.
  * @sgdma_state: Pointer to structure with the SGDMA state for each videobuffer
@@ -396,7 +377,8 @@ static int isp_set_sgdma_callback(struct isp_sgdma_state *sgdma_state,
 							sgdma_state->arg);
 		isp_set_callback(CBK_CCDC_VD1, sgdma_state->callback, func_ptr,
 							sgdma_state->arg);
-		isp_set_callback(CBK_LSC_ISR, isp_lsc_isr, NULL, NULL);
+		isp_set_callback(CBK_LSC_ISR, (isp_callback_t)isp_lsc_isr,
+		NULL, NULL);
 	}
 
 	/* isp_set_callback(CBK_SBL_OVF, NULL, NULL, NULL); */
@@ -588,7 +570,7 @@ int isp_unset_callback(enum isp_callback_type type)
 		break;
 	case CBK_SBL_OVF:
 		omap_writel((omap_readl(ISP_IRQ0ENABLE)) &
-						~IRQ0ENABLE_OVF_IRQ, ISP_IRQ0ENABLE);
+			~IRQ0ENABLE_OVF_IRQ, ISP_IRQ0ENABLE);
 		break;
 	default:
 		break;
@@ -960,9 +942,6 @@ int isp_configure_interface(struct isp_interface_config *config)
 		ispctrl_val &= ~ISPCTRL_PAR_BRIDGE_BENDIAN;
 		ispctrl_val |= (0x03 << ISPCTRL_PAR_BRIDGE_SHIFT);
 
-		isp_csi2_ctx_config_format(0, config->u.csi.format);
-		isp_csi2_ctx_update(0, false);
-
 		if (config->u.csi.crc)
 			isp_csi2_ctrl_config_ecc_enable(true);
 
@@ -971,7 +950,11 @@ int isp_configure_interface(struct isp_interface_config *config)
 		isp_csi2_ctrl_config_vp_clk_enable(true);
 		isp_csi2_ctrl_update(false);
 
-		isp_set_callback(CBK_CSIA, isp_csia_isr, NULL, NULL);
+		isp_csi2_ctx_config_format(0, config->u.csi.format);
+		isp_csi2_ctx_update(0, false);
+
+		isp_set_callback(CBK_CSIA, (isp_callback_t)isp_csia_isr,
+		NULL, NULL);
 
 		isp_csi2_irq_complexio1_set(1);
 		isp_csi2_irq_status_set(1);
@@ -996,12 +979,15 @@ int isp_configure_interface(struct isp_interface_config *config)
 	omap_writel(ispctrl_val, ISP_CTRL);
 	spin_unlock(&isp_obj.isp_temp_buf_lock);
 	ispccdc_vdint_val = omap_readl(ISPCCDC_VDINT);
+
 	ispccdc_vdint_val &= ~(ISPCCDC_VDINT_0_MASK << ISPCCDC_VDINT_0_SHIFT);
 	ispccdc_vdint_val &= ~(ISPCCDC_VDINT_1_MASK << ISPCCDC_VDINT_1_SHIFT);
+/* - disabled, causing VDINT to be reset to 0 at start_streaming
 	omap_writel((config->vdint0_timing << ISPCCDC_VDINT_0_SHIFT) |
 						(config->vdint1_timing <<
 						ISPCCDC_VDINT_1_SHIFT),
 						ISPCCDC_VDINT);
+*/
 
 	/* Set sensor specific fields in CCDC and Previewer module.*/
 	ispccdc_set_wenlog(config->wenlog);
@@ -1038,11 +1024,15 @@ EXPORT_SYMBOL(isp_configure_interface_bridge);
  **/
 void isp_CCDC_VD01_enable(void)
 {
-	omap_writel(IRQ0STATUS_CCDC_VD0_IRQ | IRQ0STATUS_CCDC_VD1_IRQ,
-							ISP_IRQ0STATUS);
-	omap_writel(omap_readl(ISP_IRQ0ENABLE) | IRQ0ENABLE_CCDC_VD0_IRQ |
-						IRQ0ENABLE_CCDC_VD1_IRQ,
-						ISP_IRQ0ENABLE);
+	u32 irq_enable = omap_readl(ISP_IRQ0ENABLE);
+
+	if (!(irq_enable & (IRQ0ENABLE_CCDC_VD0_IRQ | \
+		IRQ0ENABLE_CCDC_VD1_IRQ))) {
+		omap_writel(IRQ0STATUS_CCDC_VD0_IRQ | \
+			IRQ0STATUS_CCDC_VD1_IRQ, ISP_IRQ0STATUS);
+		omap_writel(irq_enable | (IRQ0ENABLE_CCDC_VD0_IRQ | \
+			IRQ0ENABLE_CCDC_VD1_IRQ), ISP_IRQ0ENABLE);
+	}
 }
 
 /**
@@ -1074,14 +1064,18 @@ static irqreturn_t omap34xx_isp_isr(int irq, void *ispirq_disp)
 	int i;
 	struct ispirq *irqdis = (struct ispirq *)ispirq_disp;
 	u32 irqstatus;
+	unsigned long irqflags = 0;
 
+	spin_lock_irqsave(&isp_obj.lock, irqflags);
 	irqstatus = omap_readl(ISP_IRQ0STATUS);
 	omap_writel(irqstatus, ISP_IRQ0STATUS);
 	/* The following register read is for write sync. */
 	omap_readl(ISP_IRQ0STATUS);
+	spin_unlock_irqrestore(&isp_obj.lock, irqflags);
 
 	for (i = 0; i < CBK_END; ++i) {
-		if ((irqstatus & irqdis->irq_events[i]) == irqdis->irq_events[i]) {
+		if ((irqstatus & irqdis->irq_events[i]) == \
+				irqdis->irq_events[i]) {
 			if (irqdis->isp_callbk[i]) {
 				irqdis->isp_callbk[i](irqdis->irq_events[i],
 				irqdis->isp_callbk_arg1[i],
@@ -1124,35 +1118,41 @@ void omapisp_unset_callback()
 		/* isp_unset_callback(CBK_SBL_OVF); */
 	}
 
-	if (isp_obj.if_status & ISP_CSIA) {
+	if (isp_obj.if_status & ISP_CSIA)
 		isp_unset_callback(CBK_CSIA);
-	}
 
 	omap_writel(omap_readl(ISP_IRQ0STATUS) | ISP_INT_CLR, ISP_IRQ0STATUS);
 }
 EXPORT_SYMBOL(omapisp_unset_callback);
 
-#if ISP_WORKAROUND
 /**
- *  isp_buf_allocation - To allocate a 10MB memory
+ *  isp_buf_allocation - To allocate isp workaround buffer
  *
  **/
 u32 isp_buf_allocation(void)
 {
-	buff_addr = (void *) vmalloc(ISP_BUFFER_MAX_SIZE);
+	if (alloc_done == 0) {
+		buff_addr = (void *) vmalloc(ISP_BUFFER_MAX_SIZE);
 
-	if (!buff_addr) {
-		printk(KERN_ERR "ISP_ERR: Cannot allocate "
-			"ISP_WORKAROUND memory\n");
-		return -ENOMEM;
-	}
+		if (!buff_addr) {
+			printk(KERN_ERR "ISP_ERR: Cannot allocate "
+				"ISP_WORKAROUND memory\n");
+			return -ENOMEM;
+		}
 
-	sglist_alloc = videobuf_vmalloc_to_sg(buff_addr, ISP_BUFFER_MAX_PAGES);
-	if (!sglist_alloc) {
-		printk(KERN_ERR "ISP_ERR: videobuf_vmalloc_to_sg failed\n");
-		return -ENOMEM;
+		sglist_alloc = videobuf_vmalloc_to_sg(buff_addr,
+		ISP_BUFFER_MAX_PAGES);
+		if (!sglist_alloc) {
+			printk(KERN_ERR "ISP_ERR: videobuf_vmalloc_to_sg failed\n");
+			vfree(buff_addr);
+			buff_addr = NULL;
+			return -ENOMEM;
+		}
+		num_sc = dma_map_sg(NULL, sglist_alloc,
+		ISP_BUFFER_MAX_PAGES, 1);
+		alloc_done = 1;
 	}
-	num_sc = dma_map_sg(NULL, sglist_alloc, ISP_BUFFER_MAX_PAGES, 1);
+
 	return 0;
 }
 
@@ -1162,16 +1162,34 @@ u32 isp_buf_allocation(void)
  **/
 u32 isp_buf_mmap(void)
 {
-	buff_addr_mapped = ispmmu_map_sg(sglist_alloc, ISP_BUFFER_MAX_PAGES);
-	if (!buff_addr_mapped) {
-		printk(KERN_ERR "ISP_ERR: ispmmu_map_sg mapping failed\n");
+	if (alloc_done == 0)
+		isp_buf_allocation();
+
+	if (alloc_done == 1) {
+		if (buff_addr_mapped == 0) {
+			buff_addr_mapped = ispmmu_map_sg(sglist_alloc,
+			ISP_BUFFER_MAX_PAGES);
+			if (!buff_addr_mapped) {
+				printk(KERN_ERR "ISP_ERR: ispmmu_map_sg mapping failed\n");
+				return -ENOMEM;
+			}
+		}
+	} else {
+		printk(KERN_ERR "ISP_ERR: no buffer allocated for mapping!\n");
 		return -ENOMEM;
 	}
-	isppreview_set_outaddr(buff_addr_mapped);
-	alloc_done = 1;
+
 	return 0;
 }
 
+void isp_buf_unmmap(void)
+{
+	if (buff_addr_mapped) {
+		ispmmu_unmap(buff_addr_mapped);
+		buff_addr_mapped = 0;
+	}
+}
+
 /**
  *  isp_buf_get - Get the buffer pointer address
  **/
@@ -1179,28 +1197,29 @@ dma_addr_t isp_buf_get(void)
 {
 	dma_addr_t retaddr;
 
-	if (alloc_done == 1)
+	if (ispmodule_obj.isp_lsc_workaround == 1 && buff_addr_mapped)
 		retaddr = buff_addr_mapped + offset_value;
 	else
 		retaddr = 0;
+
 	return retaddr;
 }
 
 /**
- *  isp_buf_free - To free allocated 10MB memory
+ *  isp_buf_free - To free allocated ISP workaround buffer
  *
  **/
 void isp_buf_free(void)
 {
 	if (alloc_done == 1) {
-		ispmmu_unmap(buff_addr_mapped);
+		isp_buf_unmmap();
 		dma_unmap_sg(NULL, sglist_alloc, ISP_BUFFER_MAX_PAGES, 1);
 		kfree(sglist_alloc);
 		vfree(buff_addr);
+		buff_addr = NULL;
 		alloc_done = 0;
 	}
 }
-#endif
 
 /**
  * isp_start - Starts ISP submodule
@@ -1236,23 +1255,23 @@ void isp_stop()
 	omapisp_unset_callback();
 	ispccdc_enable_lsc(0);
 	ispccdc_enable(0);
-	while (ispccdc_busy() && (timeout < 100)) {
+	while (ispccdc_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
 	isppreview_enable(0);
-	while (isppreview_busy() && (timeout < 100)) {
+	while (isppreview_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
 	ispresizer_enable(0);
-	while (ispresizer_busy() && (timeout < 100)) {
+	while (ispresizer_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
@@ -1270,7 +1289,8 @@ void isp_stop()
 		msleep(1);
 	}
 
-	/* omap_writel(omap_readl(ISP_IRQ0STATUS) | ISP_INT_CLR, ISP_IRQ0STATUS); */
+	/* omap_writel(omap_readl(ISP_IRQ0STATUS) | */
+	/* 	ISP_INT_CLR, ISP_IRQ0STATUS); */
 
 	isp_restore_ctx();
 }
@@ -1282,16 +1302,15 @@ void isp_stop()
 void isp_set_buf(struct isp_sgdma_state *sgdma_state)
 {
 	if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) &&
-						is_ispresizer_enabled())
+						is_ispresizer_enabled()) {
 		ispresizer_set_outaddr(sgdma_state->isp_addr);
-#if (ISP_WORKAROUND == 0)
-	else if ((ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW) &&
-						is_isppreview_enabled())
-		isppreview_set_outaddr(sgdma_state->isp_addr);
-#endif
-	else if (ispmodule_obj.isp_pipeline & OMAP_ISP_CCDC)
+	} else if ((ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW) &&
+						is_isppreview_enabled()) {
+		if (ispmodule_obj.isp_lsc_workaround == 0)
+			isppreview_set_outaddr(sgdma_state->isp_addr);
+	} else if (ispmodule_obj.isp_pipeline & OMAP_ISP_CCDC) {
 		ispccdc_set_outaddr(sgdma_state->isp_addr);
-
+	}
 }
 
 /**
@@ -1302,9 +1321,7 @@ void isp_set_buf(struct isp_sgdma_state *sgdma_state)
 u32 isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 					struct v4l2_pix_format *pix_output)
 {
-#if ISP_WORKAROUND
 	int rval;
-#endif
 
 	isp_release_resources();
 	if ((pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10) &&
@@ -1316,23 +1333,27 @@ u32 isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 			isppreview_request();
 			ispresizer_request();
 		ispccdc_config_datapath(CCDC_RAW, CCDC_OTHERS_VP);
-#if ISP_WORKAROUND
-		isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_MEM);
-		ispresizer_config_datapath(RSZ_MEM_YUV);
-		if (alloc_done == 0) {
-#if !defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-			rval = isp_buf_allocation();
-			if (rval)
-				return -EINVAL;
-#endif
+
+		if (ispmodule_obj.isp_lsc_workaround == 1) {
+			DPRINTK_ISPCTRL("Using ISP workaround!\n");
+			isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_MEM);
+			ispresizer_config_datapath(RSZ_MEM_YUV);
+
 			rval = isp_buf_mmap();
-			if (rval)
+			if (rval) {
+				printk(KERN_ERR "ISP_ERR:  isp_buf_mmap() failed!\n");
 				return -EINVAL;
+			}
+
+			isppreview_set_outaddr(buff_addr_mapped);
+		} else {
+			DPRINTK_ISPCTRL("NOT using ISP workaround!\n");
+
+			isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_RSZ);
+			ispresizer_config_datapath(RSZ_OTFLY_YUV);
+			isppreview_set_outaddr(0);
+			ispccdc_enable_lsc(0);
 		}
-#else
-		isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_RSZ);
-		ispresizer_config_datapath(RSZ_OTFLY_YUV);
-#endif
 	} else if (pix_input->pixelformat == pix_output->pixelformat) {
 		ispmodule_obj.isp_pipeline = OMAP_ISP_CCDC;
 		ispccdc_request();
@@ -1405,95 +1426,122 @@ void isp_config_pipeline(struct v4l2_pix_format *pix_input,
  **/
 void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 {
+	unsigned long flags = 0;
 	struct videobuf_buffer *vb = (struct videobuf_buffer *) arg2;
 	int notify = 0;
 	int rval = 0;
-	unsigned long flags;
 
 	switch (status) {
 	case CCDC_VD0:
-   #ifdef CONFIG_VIDEO_OMAP3_HP3A
-      hp3a_ccdc_done();
-   #else
-	  ispccdc_config_shadow_registers();
-   #endif
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		hp3a_ccdc_done();
+#else
+		ispccdc_config_shadow_registers();
+#endif
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
-			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW)) {
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
+			return;
+		} else if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
 			return;
-		else {
-			spin_lock(&isp_obj.isp_temp_buf_lock);
-			if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				return;
-
-			} else {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				break;
-			}
 		}
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+		flags);
 		break;
 	case CCDC_VD1:
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
-			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
-			return;
-		spin_lock(&isp_obj.isp_temp_buf_lock);
-		if (ispmodule_obj.isp_temp_state == ISP_BUF_INIT) {
-			spin_unlock(&isp_obj.isp_temp_buf_lock);
-			ispccdc_enable(0);
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW)) {
 			return;
 		}
-		spin_unlock(&isp_obj.isp_temp_buf_lock);
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+		if (ispmodule_obj.isp_temp_state == ISP_BUF_INIT)
+			ispccdc_enable(0);
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock, flags);
 		return;
-		break;
 	case PREV_DONE:
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		hp3a_frame_done();
+#endif
 		if (is_isppreview_enabled()) {
-			if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) {
-				spin_lock(&isp_obj.isp_temp_buf_lock);
+			spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+			if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER &&
+				!ispresizer_busy()) {
 				if (!ispmodule_obj.applyCrop &&
+				    ispmodule_obj.isp_lsc_workaround &&
 					(ispmodule_obj.isp_temp_state ==
-					 ISP_BUF_INIT))
+					 ISP_BUF_INIT)) {
 					ispresizer_enable(1);
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				if (ispmodule_obj.applyCrop &&
-						!ispresizer_busy()) {
+				} else if (ispmodule_obj.applyCrop) {
 					ispresizer_enable(0);
 					ispresizer_applycrop();
 					ispmodule_obj.applyCrop = 0;
 				}
 			}
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+				flags);
 
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+			if (!isppreview_busy())
+				isppreview_config_shadow_registers();
+			hp3a_update_wb();
+		}
+#else
 			if (!isppreview_busy()) {
 				isppreview_config_shadow_registers();
-#ifdef CONFIG_VIDEO_OMAP3_HP3A
+				isph3a_update_wb();
 			}
-			hp3a_frame_done();
-#else
-			isph3a_update_wb();
 		}
 #endif
-
 		if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER)
 			return;
-		}
+
 		break;
 	case RESZ_DONE:
 		if (is_ispresizer_enabled()) {
-			ispresizer_config_shadow_registers();
-			spin_lock(&isp_obj.isp_temp_buf_lock);
+			spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+			if (!ispresizer_busy() && !ispccdc_busy())
+				ispresizer_config_shadow_registers();
+
+
 			if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
+				spin_unlock_irqrestore
+				(&isp_obj.isp_temp_buf_lock, flags);
 				return;
 			}
-			spin_unlock(&isp_obj.isp_temp_buf_lock);
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
 		}
 		break;
 	case HS_VS:
-		spin_lock(&isp_obj.isp_temp_buf_lock);
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
 		if (ispmodule_obj.isp_temp_state == ISP_BUF_TRAN) {
 			isp_CCDC_VD01_enable();
 			ispmodule_obj.isp_temp_state = ISP_BUF_INIT;
 		}
-		spin_unlock(&isp_obj.isp_temp_buf_lock);
+
+		if (!ispmodule_obj.isp_lsc_workaround &&
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) &&
+			 !ispresizer_busy() &&
+			 !isppreview_busy()) {
+			if (!ispmodule_obj.applyCrop &&
+				 (ispmodule_obj.isp_temp_state ==
+				 ISP_BUF_INIT)) {
+				ispresizer_enable(1);
+			} else if (ispmodule_obj.applyCrop) {
+				ispresizer_enable(0);
+				ispresizer_applycrop();
+				ispmodule_obj.applyCrop = 0;
+			}
+		}
+
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock, flags);
+
+		ktime_get_ts((struct timespec *)&vb->ts);
+
 #ifdef CONFIG_VIDEO_OMAP3_HP3A
 		hp3a_ccdc_start();
 #endif
@@ -1510,9 +1558,8 @@ void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 
 	rval = arg1(vb);
 
-	if (rval) {
+	if (rval)
 		isp_sgdma_process(&ispsg, 1, &notify, arg1);
-	}
 
 	return;
 }
@@ -1540,10 +1587,11 @@ EXPORT_SYMBOL(isp_stop);
 void isp_sgdma_cancel()
 {
 	int sg;
-	unsigned long flags;
 	struct videobuf_buffer *vb;
+	unsigned long flags = 0;
 
 	spin_lock_irqsave(&ispsg.lock, flags);
+
 	for (sg = 0; sg < NUM_SG_DMA; sg++) {
 		if (ispsg.sg_state[sg].arg) {
 			vb = ispsg.sg_state[sg].arg;
@@ -1552,6 +1600,7 @@ void isp_sgdma_cancel()
 			ispsg.sg_state[sg].arg = NULL;
 		}
 	}
+
 	spin_unlock_irqrestore(&ispsg.lock, flags);
 }
 EXPORT_SYMBOL(isp_sgdma_cancel);
@@ -1933,6 +1982,20 @@ int isp_handle_private(int cmd, void *arg)
       ispresizer_config_filter_coef(resizer_coef);
       }
    break;
+   case VIDIOC_PRIVATE_ISP_CCDC_BAYER_CFG:
+	   {
+		   struct ispccdc_color_offset *offset;
+		   offset = (struct ispccdc_color_offset *)arg;
+		   ispccdc_set_crop_offset_dynamic(*offset);
+	   }
+	   break;
+	case VIDIOC_PRIVATE_ISP_LSC_WORKAROUND_CFG:
+	  {
+		 ispmodule_obj.isp_lsc_workaround = (*(int *)arg ? 1 : 0);
+		if (ispmodule_obj.isp_lsc_workaround == 0)
+			isp_buf_free();
+	  }
+	  break;
 	default:
 		rval = -EINVAL;
 		break;
@@ -2043,50 +2106,55 @@ EXPORT_SYMBOL(isp_s_fmt_cap);
  **/
 void isp_config_crop(struct v4l2_pix_format *croppix)
 {
-	u8 crop_scaling_w;
-	u8 crop_scaling_h;
-#if ISP_WORKAROUND
 	unsigned long org_left, num_pix, new_top, new_height;
-#endif
-
 	struct v4l2_pix_format *pix = croppix;
 
-	crop_scaling_w = (ispmodule_obj.preview_output_width * 10) /
-								pix->width;
-	crop_scaling_h = (ispmodule_obj.preview_output_height * 10) /
-								pix->height;
-
-	cur_rect.left = (ispcroprect.left * crop_scaling_w) / 10;
-	cur_rect.top = (ispcroprect.top * crop_scaling_h) / 10;
-	cur_rect.width = (ispcroprect.width * crop_scaling_w) / 10;
-	cur_rect.height = (ispcroprect.height * crop_scaling_h) / 10;
-
-#if ISP_WORKAROUND
-	org_left = cur_rect.left;
-	cur_rect.left = ALIGN_NEAR(cur_rect.left, 16);
-
-	num_pix = org_left - cur_rect.left;
-	new_top = (int)(num_pix * 3) / 4;
-	cur_rect.top = (cur_rect.top - new_top);
-	if ((int)cur_rect.top < 0)
-			cur_rect.top = 0;
-
-	new_height = (2 * new_top) + cur_rect.height;
-	if (new_height < cur_rect.height)
-		cur_rect.height = new_height;
-
-	cur_rect.width = cur_rect.width + (2 * num_pix);
-	cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
-
-	offset_value = ((cur_rect.left * 2) + \
-		((ispmodule_obj.preview_output_width) * 2 * cur_rect.top));
-#endif
+	cur_rect.left = (u32)(ispcroprect.left *
+		ispmodule_obj.preview_output_width)/(u32)pix->width;
+	cur_rect.top = (u32)(ispcroprect.top
+		* ispmodule_obj.preview_output_height)/(u32)pix->height;
+	cur_rect.width = (u32)(ispcroprect.width *
+		ispmodule_obj.preview_output_width)/(u32)pix->width;
+	cur_rect.height = (u32)(ispcroprect.height *
+		ispmodule_obj.preview_output_height)/(u32)pix->height;
+
+	if (ispmodule_obj.isp_lsc_workaround == 1) {
+		org_left = cur_rect.left;
+		cur_rect.left = ALIGN_NEAR(cur_rect.left, 16);
+
+		num_pix = org_left - cur_rect.left;
+		new_top = (int)(num_pix * 3) / 4;
+		cur_rect.top = (cur_rect.top - new_top);
+		if ((int)cur_rect.top < 0)
+				cur_rect.top = 0;
+
+		new_height = (2 * new_top) + cur_rect.height;
+		if (new_height < cur_rect.height)
+			cur_rect.height = new_height;
+
+		cur_rect.width = cur_rect.width + (2 * num_pix);
+		cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
+
+		offset_value = ((cur_rect.left * 2) + \
+			((ispmodule_obj.preview_output_width) * 2
+			* cur_rect.top));
+	} else {
+		offset_value = 0;
+		cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
+		cur_rect.height = ALIGN_NEAR(cur_rect.height, 8);
+	}
 
-	ispresizer_trycrop(cur_rect.left, cur_rect.top, cur_rect.width,
+	ispresizer_trycrop(cur_rect.left, cur_rect.top,
+					cur_rect.width,
 					cur_rect.height,
 					ispmodule_obj.resizer_output_width,
 					ispmodule_obj.resizer_output_height);
 
+	ispmodule_obj.applyCrop = 1;
+
+	DPRINTK_ISPCTRL("ISP: resizer crop (%d-%d-%d-%d) \n",
+		cur_rect.left, cur_rect.top, cur_rect.width, cur_rect.height);
+
 	return;
 }
 EXPORT_SYMBOL(isp_config_crop);
@@ -2120,26 +2188,32 @@ int isp_s_crop(struct v4l2_crop *a, struct v4l2_pix_format *pix)
 
 	if ((crop->c.left + crop->c.width) > pix->width) {
 		rval = -EINVAL;
-		DPRINTK_ISPCTRL("isp_s_crop(): crop->left=%d crop->width=%d pix->width=%d\n",
+		DPRINTK_ISPCTRL("isp_s_crop() crop->left = %d " \
+			"crop->width = %d pix->width = %d\n",
 			crop->c.left, crop->c.width, pix->width);
 		goto out;
 	}
 
 	if ((crop->c.top + crop->c.height) > pix->height) {
 		rval = -EINVAL;
-		DPRINTK_ISPCTRL("isp_s_crop(): crop->top=%d crop->height=%d pix->height=%d\n",
+		DPRINTK_ISPCTRL("isp_s_crop() crop->top = %d " \
+			"crop->height = %d pix->height = %d\n",
 			crop->c.top, crop->c.height, pix->height);
 		goto out;
 	}
 
+
 	ispcroprect.left = crop->c.left;
 	ispcroprect.top = crop->c.top;
 	ispcroprect.width = crop->c.width;
 	ispcroprect.height = crop->c.height;
 
+	DPRINTK_ISPCTRL("ISP: isp_s_crop -> crop (%d-%d-%d-%d)\n",
+		ispcroprect.left, ispcroprect.top,
+		ispcroprect.width, ispcroprect.height);
+
 	isp_config_crop(pix);
 
-	ispmodule_obj.applyCrop = 1;
 out:
 	return rval;
 }
@@ -2166,14 +2240,16 @@ int isp_try_fmt_cap(struct v4l2_pix_format *pix_input,
 		out_aspect_ratio = (pix_output->width * 256)/pix_output->height;
 	}
 
-	if ((out_aspect_ratio - in_aspect_ratio) > 25 &&  (out_aspect_ratio - in_aspect_ratio) < 180) {
+	if ((out_aspect_ratio - in_aspect_ratio) > 25 &&
+		(out_aspect_ratio - in_aspect_ratio) < 180) {
 		/* Adjusted for output aspect ratio. */
-		adjusted_height = ALIGN_TO(((pix_input->width*256)/out_aspect_ratio), 2);
+		adjusted_height = ALIGN_TO(
+			((pix_input->width*256)/out_aspect_ratio), 2);
 
 		ispccdc_config_crop(0,
-			((pix_input->height-adjusted_height)/2),
-			(adjusted_height + (pix_input->height-adjusted_height)/2),
-			pix_input->width);
+		(pix_input->height-adjusted_height)/2,
+		adjusted_height + (pix_input->height-adjusted_height)/2,
+		pix_input->width);
 	} else {
 		ispccdc_config_crop(0, 0, 0, 0);
 	}
@@ -2377,44 +2453,44 @@ EXPORT_SYMBOL(isp_restore_ctx);
 int isp_get(void)
 {
 	int ret_err = 0;
-	DPRINTK_ISPCTRL("isp_get: old %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_get() old %d\n", isp_obj.ref_count);
 	mutex_lock(&(isp_obj.isp_mutex));
 	if (isp_obj.ref_count == 0) {
 		isp_obj.cam_ick = clk_get(&camera_dev, "cam_ick");
 		if (IS_ERR(isp_obj.cam_ick)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for "
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for "
 							"cam_ick failed\n");
 			ret_err = PTR_ERR(isp_obj.cam_ick);
 			goto out_clk_get_ick;
 		}
 		isp_obj.cam_mclk = clk_get(&camera_dev, "cam_mclk");
 		if (IS_ERR(isp_obj.cam_mclk)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for "
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for "
 							"cam_mclk failed\n");
 			ret_err = PTR_ERR(isp_obj.cam_mclk);
 			goto out_clk_get_mclk;
 		}
 		isp_obj.csi2_fck = clk_get(&camera_dev, "csi2_96m_fck");
 		if (IS_ERR(isp_obj.csi2_fck)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for csi2_fclk"
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for csi2_fclk"
 								" failed\n");
 			ret_err = PTR_ERR(isp_obj.csi2_fck);
 			goto out_clk_get_csi2_fclk;
 		}
 		ret_err = clk_enable(isp_obj.cam_ick);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for ick failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : clk_en for ick failed\n");
 			goto out_clk_enable_ick;
 		}
 		ret_err = clk_enable(isp_obj.cam_mclk);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for mclk failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : clk_en for mclk failed\n");
 			goto out_clk_enable_mclk;
 		}
 		ret_err = clk_enable(isp_obj.csi2_fck);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for csi2_fclk"
-								" failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : "
+				"clk_en for csi2_fclk failed\n");
 			goto out_clk_enable_csi2_fclk;
 		}
 		if (off_mode == 1)
@@ -2423,8 +2499,7 @@ int isp_get(void)
 	isp_obj.ref_count++;
 	mutex_unlock(&(isp_obj.isp_mutex));
 
-
-	DPRINTK_ISPCTRL("isp_get: new %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_get : new %d\n", isp_obj.ref_count);
 	return isp_obj.ref_count;
 
 out_clk_enable_csi2_fclk:
@@ -2452,17 +2527,16 @@ EXPORT_SYMBOL(isp_get);
  **/
 int isp_put(void)
 {
-	DPRINTK_ISPCTRL("isp_put: old %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_put old %d \n", isp_obj.ref_count);
 	mutex_lock(&(isp_obj.isp_mutex));
 	if (isp_obj.ref_count)
 		if (--isp_obj.ref_count == 0) {
 			isp_save_ctx();
 			off_mode = 1;
-#if ISP_WORKAROUND && !defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-			isp_buf_free();
-#endif
+
 			isp_release_resources();
 			ispmodule_obj.isp_pipeline = 0;
+			ispmodule_obj.isp_lsc_workaround = ISP_WORKAROUND;
 			clk_disable(isp_obj.cam_ick);
 			clk_disable(isp_obj.cam_mclk);
 			clk_disable(isp_obj.csi2_fck);
@@ -2473,7 +2547,7 @@ int isp_put(void)
 			memset(&cur_rect, 0, sizeof(cur_rect));
 		}
 	mutex_unlock(&(isp_obj.isp_mutex));
-	DPRINTK_ISPCTRL("isp_put: new %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_put new %d \n", isp_obj.ref_count);
 	return isp_obj.ref_count;
 }
 EXPORT_SYMBOL(isp_put);
@@ -2511,9 +2585,7 @@ EXPORT_SYMBOL(isp_restore_context);
  **/
 static int __init isp_init(void)
 {
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
 	int rval;
-#endif
 	int i;
 
 	DPRINTK_ISPCTRL("+isp_init for Omap 3430 Camera ISP\n");
@@ -2527,13 +2599,13 @@ static int __init isp_init(void)
 	init_completion(&isp_wfc);
 	isp_wfc.done = 0;
 
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-	if (alloc_done == 0) {
-		rval = isp_buf_allocation();
-		if (rval)
-			return -EINVAL;
-	}
-#endif
+	buff_addr = NULL;
+	buff_addr_mapped = 0;
+	alloc_done = 0;
+	offset_value = 0;
+	rval = isp_buf_allocation();
+	if (rval)
+		return -EINVAL;
 
 	for (i = 0; i < CBK_END; ++i) {
 		ispirq_obj.irq_events[i] = 0;
@@ -2597,9 +2669,7 @@ static void __exit isp_cleanup(void)
 #endif
 	isp_ccdc_cleanup();
 	free_irq(INT_34XX_CAM_IRQ, &ispirq_obj);
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
 	isp_buf_free();
-#endif
 }
 
 /**
@@ -2624,7 +2694,10 @@ static void rsz_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
  *
  * Interrupt Service Routine for Preview wrapper
  **/
-static void preview_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
+static void preview_isr(
+		unsigned long status,
+		isp_vbq_callback_ptr arg1,
+		void *arg2)
 {
 	isppreview_enable(0);
 	ispresizer_enable(1);
@@ -2638,7 +2711,10 @@ static void preview_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *a
  *
  * Return a pointer to a page array.
  **/
-struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pages_mapped)
+struct page **map_user_memory_to_kernel(
+			unsigned long addr,
+			u32 size,
+			u32 *nr_pages_mapped)
 {
 	struct page **ppages = NULL;
 	int nr_pages;
@@ -2663,15 +2739,13 @@ struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pa
 			if (unlikely(ret != nr_pages)) {
 				kfree(ppages);
 				ppages = NULL;
-				printk(KERN_ERR "isp: Mapping user pages"
-						" to kernel failed!\n");
+				printk(KERN_ERR "isp : Mapping user pages"
+						" to kernel failed\n");
 			}
-			if (nr_pages_mapped) {
+			if (nr_pages_mapped)
 				*nr_pages_mapped = nr_pages;
-			}
-		} else {
-			printk(KERN_ERR "isp: Error allocating kernel memory!\n");
-		}
+		} else
+			printk(KERN_ERR "isp : Error allocating kernel memory\n");
 	}
 
 	return ppages;
@@ -2687,15 +2761,14 @@ void unmap_user_memory_from_kernel(struct page **pages, int nr_pages)
 	u32 i;
 
 	if (pages != NULL) {
-		for (i = 0; i < nr_pages; ++i) {
+		for (i = 0; i < nr_pages; ++i)
 			page_cache_release(pages[i]);
-		}
 	}
 }
 
 /**
  * isp_run_resizer - Run the resizer on memory based input
- *									and output.
+ * and output.
  * @userdata: address to the passed in data structure.
  *
  * Returns 0 on success, < 0 otherwise.
@@ -2705,7 +2778,7 @@ int isp_run_resizer(void *userdata)
 	int i;
 	int ret = -1;
 	struct ispprv_run_resizer *presizer_user = \
-							(struct ispprv_run_resizer *)userdata;
+		(struct ispprv_run_resizer *)userdata;
 	u32 input_buffer_size, output_buffer_size;
 	u32 input_nr_pages, output_nr_pages;
 	struct page **input_pages = NULL;
@@ -2715,23 +2788,24 @@ int isp_run_resizer(void *userdata)
 	struct ispprv_run_resizer resizer_param;
 
 	if (presizer_user == NULL) {
-		printk(KERN_ERR "isp_run_resizer: Invalid user data!\n");
+		printk(KERN_ERR "isp_run_resizer : Invalid user data\n");
 		return -EINVAL;
 	}
 
-	memcpy(&resizer_param, presizer_user, sizeof(struct ispprv_run_resizer));
+	memcpy(&resizer_param, presizer_user, \
+		sizeof(struct ispprv_run_resizer));
 
-	DPRINTK_ISPCTRL("\nisp_run_resizer: input(%d-%d) - output(%d-%d)\n",
-										resizer_param.input_width,
-										resizer_param.input_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+	DPRINTK_ISPCTRL("\nisp_run_resizer : input(%d-%d) - output(%d-%d)\n",
+		resizer_param.input_width,
+		resizer_param.input_height,
+		resizer_param.output_width,
+		resizer_param.output_height);
 
-	DPRINTK_ISPCTRL("isp_run_resizer: start(%d-%d) - end(%d-%d)\n",
-										resizer_param.left,
-										resizer_param.top,
-										resizer_param.crop_width,
-										resizer_param.crop_height);
+	DPRINTK_ISPCTRL("isp_run_resizer : start(%d-%d) - end(%d-%d)\n",
+		resizer_param.left,
+		resizer_param.top,
+		resizer_param.crop_width,
+		resizer_param.crop_height);
 
 	if (presizer_user->datain == 0 || presizer_user->dataout == 0)
 		return -EINVAL;
@@ -2739,60 +2813,59 @@ int isp_run_resizer(void *userdata)
 	ispresizer_save_context();
 
 	input_buffer_size = ALIGN_TO(presizer_user->input_width* \
-										presizer_user->input_height*2 , 0x100);
+		presizer_user->input_height*2 , 0x100);
 	input_pages = map_user_memory_to_kernel(presizer_user->datain,
-									input_buffer_size, &input_nr_pages);
+		input_buffer_size, &input_nr_pages);
 	if (input_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_resizer : memory allocation failed\n");
 		goto exit_cleanup;
 	}
 
 	output_buffer_size = ALIGN_TO(presizer_user->output_width* \
-											presizer_user->output_height*2, 0x1000);
+		presizer_user->output_height*2, 0x1000);
 	output_pages = map_user_memory_to_kernel(presizer_user->dataout,
-									output_buffer_size, &output_nr_pages);
+		output_buffer_size, &output_nr_pages);
 	if (output_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_resizer() memory allocation failed\n");
 		goto exit_cleanup;
 	}
-	for (i = 0; i < output_nr_pages; ++i) {
+	for (i = 0; i < output_nr_pages; ++i)
 		flush_dcache_page(output_pages[i]);
-	}
 
 	isp_addr_in = ispmmu_map_pages(input_pages, input_nr_pages);
 	if (isp_addr_in == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_resizer() isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 	isp_addr_out = ispmmu_map_pages(output_pages, output_nr_pages);
 	if (isp_addr_out == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_resizer()  isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 
 	if ((resizer_param.left == 0) && (resizer_param.top == 0)) {
-		ret = ispresizer_try_size(&resizer_param.input_width,
-												&resizer_param.input_height,
-												&resizer_param.output_width,
-												&resizer_param.output_height);
+			ret = ispresizer_try_size(&resizer_param.input_width,
+			&resizer_param.input_height,
+			&resizer_param.output_width,
+			&resizer_param.output_height);
 
-		ret = ispresizer_config_size(resizer_param.input_width,
-													resizer_param.input_height,
-													resizer_param.output_width,
-													resizer_param.output_height);
+			ret = ispresizer_config_size(resizer_param.input_width,
+			resizer_param.input_height,
+			resizer_param.output_width,
+			resizer_param.output_height);
 
 		ispresizer_set_inaddr(isp_addr_in);
 	} else {
 		ispresizer_trycrop(resizer_param.left,
-										resizer_param.top,
-										resizer_param.crop_width,
-										resizer_param.crop_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+			resizer_param.top,
+			resizer_param.crop_width,
+			resizer_param.crop_height,
+			resizer_param.output_width,
+			resizer_param.output_height);
 
 		ispresizer_applycrop();
 
@@ -2828,12 +2901,10 @@ int isp_run_resizer(void *userdata)
 exit_cleanup:
 	ispresizer_restore_context();
 
-	if (isp_addr_in != 0) {
+	if (isp_addr_in != 0)
 		ispmmu_unmap(isp_addr_in);
-	}
-	if (isp_addr_out != 0) {
+	if (isp_addr_out != 0)
 		ispmmu_unmap(isp_addr_out);
-	}
 	if (input_pages != NULL) {
 		unmap_user_memory_from_kernel(input_pages, input_nr_pages);
 		kfree(input_pages);
@@ -2843,14 +2914,14 @@ exit_cleanup:
 		kfree(output_pages);
 	}
 
-	DPRINTK_ISPCTRL("isp_run_resizer: exit.\n");
+	DPRINTK_ISPCTRL("isp_run_resizer : exit.\n");
 	return ret;
 }
 EXPORT_SYMBOL(isp_run_resizer);
 
 /**
  * isp_run_preview - Run the preview on memory based input
- *									and output.
+ * and output.
  * @userdata: address to the passed in data structure.
  *
  * Returns 0 on success, < 0 otherwise.
@@ -2859,7 +2930,8 @@ int isp_run_preview(void *userdata)
 {
 	int i;
 	int ret = -1;
-	struct ispprv_run_hardpipe *ppreview_user = (struct ispprv_run_hardpipe *)userdata;
+	struct ispprv_run_hardpipe *ppreview_user = \
+		(struct ispprv_run_hardpipe *)userdata;
 	struct ispprv_run_hardpipe preview_param;
 	u32 input_buffer_size, output_buffer_size;
 	u32 input_nr_pages, output_nr_pages;
@@ -2869,25 +2941,27 @@ int isp_run_preview(void *userdata)
 	unsigned long  isp_addr_out = 0;
 	u32 isppreview_pcr;
 	struct ispprv_run_resizer resizer_param;
+	u16 cropadjust = 0;
 
 	if (ppreview_user == NULL) {
-		printk(KERN_ERR "isp_run_preview: Invalid user data!\n");
+		printk(KERN_ERR "isp_run_preview() Invalid user data\n");
 		return -EINVAL;
 	}
 
-	memcpy(&preview_param, ppreview_user, sizeof(struct ispprv_run_hardpipe));
+	memcpy(&preview_param, ppreview_user, \
+		sizeof(struct ispprv_run_hardpipe));
 
-	DPRINTK_ISPCTRL("\nnisp_run_preview: input(%d-%d) - output(%d-%d)\n",
-										preview_param.input_width,
-										preview_param.input_height,
-										preview_param.output_width,
-										preview_param.output_height);
+	DPRINTK_ISPCTRL("\nnisp_run_preview() input(%d-%d) - output(%d-%d)\n",
+		preview_param.input_width,
+		preview_param.input_height,
+		preview_param.output_width,
+		preview_param.output_height);
 
-	DPRINTK_ISPCTRL("isp_run_preview: start(%d-%d) - end(%d-%d)\n",
-										preview_param.left,
-										preview_param.top,
-										preview_param.crop_width,
-										preview_param.crop_height);
+	DPRINTK_ISPCTRL("isp_run_preview() start(%d-%d) - end(%d-%d)\n",
+		preview_param.left,
+		preview_param.top,
+		preview_param.crop_width,
+		preview_param.crop_height);
 
 	if (ppreview_user->datain == 0 || ppreview_user->dataout == 0)
 		return -EINVAL;
@@ -2898,53 +2972,50 @@ int isp_run_preview(void *userdata)
 	ispccdc_config_crop(0, 0, 0, 0);
 
 	ret = isppreview_try_size(preview_param.input_width,
-											preview_param.input_height,
-											&preview_param.output_width,
-											&preview_param.output_height);
-	if (ret < 0) {
+		preview_param.input_height,
+		&preview_param.output_width,
+		&preview_param.output_height);
+	if (ret < 0)
 		goto exit_cleanup;
-	}
 	ret = isppreview_config_size(preview_param.input_width,
-													preview_param.input_height,
-													preview_param.output_width,
-													preview_param.output_height);
-	if (ret < 0) {
+		preview_param.input_height,
+		preview_param.output_width,
+		preview_param.output_height);
+	if (ret < 0)
 		goto exit_cleanup;
-	}
 
 	input_buffer_size = ALIGN_TO(ppreview_user->input_width* \
-										ppreview_user->input_height*2 , 0x100);
+		ppreview_user->input_height*2 , 0x100);
 	input_pages = map_user_memory_to_kernel(preview_param.datain,
-									input_buffer_size, &input_nr_pages);
+		input_buffer_size, &input_nr_pages);
 	if (input_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_preview : memory allocation failed\n");
 		goto exit_cleanup;
 	}
 
 	output_buffer_size = ALIGN_TO(ppreview_user->output_width* \
-											ppreview_user->output_height*2, 0x1000);
+		ppreview_user->output_height*2, 0x1000);
 	output_pages = map_user_memory_to_kernel(preview_param.dataout,
-									output_buffer_size, &output_nr_pages);
+		output_buffer_size, &output_nr_pages);
 	if (output_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_preview memory allocation failed\n");
 		goto exit_cleanup;
 	}
-	for (i = 0; i < output_nr_pages; ++i) {
+	for (i = 0; i < output_nr_pages; ++i)
 		flush_dcache_page(output_pages[i]);
-	}
 
 	isp_addr_in = ispmmu_map_pages(input_pages, input_nr_pages);
 	if (isp_addr_in == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_preview : isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 	isp_addr_out = ispmmu_map_pages(output_pages, output_nr_pages);
 	if (isp_addr_out == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_preview isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 
@@ -2974,47 +3045,56 @@ int isp_run_preview(void *userdata)
 
 	if ((preview_param.left == 0) && (preview_param.top == 0)) {
 		ret = ispresizer_try_size(&resizer_param.input_width,
-												&resizer_param.input_height,
-												&resizer_param.output_width,
-												&resizer_param.output_height);
-		if (ret < 0) {
+				&resizer_param.input_height,
+				&resizer_param.output_width,
+				&resizer_param.output_height);
+		if (ret < 0)
 			goto exit_cleanup;
-		}
 		ret = ispresizer_config_size(resizer_param.input_width,
-													resizer_param.input_height,
-													resizer_param.output_width,
-													resizer_param.output_height);
-		if (ret < 0) {
+				resizer_param.input_height,
+				resizer_param.output_width,
+				resizer_param.output_height);
+		if (ret < 0)
 			goto exit_cleanup;
-		}
 		ispresizer_set_inaddr(buff_addr_mapped);
 	} else {
 		ispresizer_trycrop(preview_param.left,
-										preview_param.top,
-										preview_param.crop_width,
-										preview_param.crop_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+				preview_param.top,
+				preview_param.crop_width,
+				preview_param.crop_height,
+				resizer_param.output_width,
+				resizer_param.output_height);
 
 		ispresizer_applycrop();
 
+      /*account for pixel loss when using crop*/
+		if ((preview_param.input_height > preview_param.output_height)
+				&& (preview_param.top > 16))
+			cropadjust = 8;
+		else
+			cropadjust = 0;
+
+
 		/*pixel alignment in 32bit space, vertical must be 0 per TRM */
 		omap_writel(((preview_param.left%16) <<
-							ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-							(0 <<
-							ISPRSZ_IN_START_VERT_ST_SHIFT),
-							ISPRSZ_IN_START);
+					ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+					(0 <<
+					ISPRSZ_IN_START_VERT_ST_SHIFT),
+					ISPRSZ_IN_START);
 
 		/* Align input address for cropping, per TRM  */
-		ispresizer_set_inaddr(buff_addr_mapped +
-							(preview_param.top*resizer_param.input_width*2)
-							+ ((preview_param.left/16)*32));
+		ispresizer_set_inaddr(buff_addr_mapped -
+				(resizer_param.input_width*2*cropadjust) +
+				(preview_param.top*resizer_param.input_width*2)
+				+ ((preview_param.left/16)*32));
 	}
 
 	ispresizer_set_outaddr(isp_addr_out);
 	ispresizer_config_inlineoffset(resizer_param.input_width*2);
-	isp_set_callback(CBK_PREV_DONE, preview_isr, (void *) NULL, (void *)NULL);
-	isp_set_callback(CBK_RESZ_DONE, rsz_isr, (void *) NULL, (void *)NULL);
+	isp_set_callback(CBK_PREV_DONE, preview_isr,
+			(void *) NULL, (void *)NULL);
+	isp_set_callback(CBK_RESZ_DONE, rsz_isr,
+			(void *) NULL, (void *)NULL);
 
 	omap_writel(RESZ_DONE|PREV_DONE, ISP_IRQ0STATUS);
 	isp_wfc.done = 0;
@@ -3031,12 +3111,10 @@ exit_cleanup:
 	isppreview_restore_context();
 	ispresizer_restore_context();
 
-	if (isp_addr_in != 0) {
+	if (isp_addr_in != 0)
 		ispmmu_unmap(isp_addr_in);
-	}
-	if (isp_addr_out != 0) {
+	if (isp_addr_out != 0)
 		ispmmu_unmap(isp_addr_out);
-	}
 	if (input_pages != NULL) {
 		unmap_user_memory_from_kernel(input_pages, input_nr_pages);
 		kfree(input_pages);
@@ -3046,7 +3124,7 @@ exit_cleanup:
 		kfree(output_pages);
 	}
 
-	DPRINTK_ISPCTRL("isp_run_preview: exit.\n");
+	DPRINTK_ISPCTRL("isp_run_preview : exit.\n");
 	return ret;
 }
 EXPORT_SYMBOL(isp_run_preview);
@@ -3061,33 +3139,34 @@ void isp_print_status(void)
 	if (!is_ispctrl_debug_enabled())
 		return;
 
-	DPRINTK_ISPCTRL("###CM_FCLKEN_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_FCLKEN_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_FCLKEN_CAM));
-	DPRINTK_ISPCTRL("###CM_ICLKEN_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_ICLKEN_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_ICLKEN_CAM));
-	DPRINTK_ISPCTRL("###CM_CLKSEL_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKSEL_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_CLKSEL_CAM));
-	DPRINTK_ISPCTRL("###CM_AUTOIDLE_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_AUTOIDLE_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_AUTOIDLE_CAM));
-	DPRINTK_ISPCTRL("###CM_CLKEN_PLL[18:16] should be 0x7, = 0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKEN_PLL[18 : 16] should be 0x7, = 0x%x\n",
 					omap_readl(OMAP3_CM_CLKEN_PLL));
-	DPRINTK_ISPCTRL("###CM_CLKSEL2_PLL[18:8] should be 0x2D, [6:0] should "
-			"be 1 = 0x%x\n", omap_readl(OMAP3_CM_CLKSEL2_PLL));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_HS=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKSEL2_PLL[18 : 8] should be 0x2D, "
+			"[6 : 0] should be 1 = 0x%x\n",
+			omap_readl(OMAP3_CM_CLKSEL2_PLL));
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_HS = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_HS));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_XCLKA=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_XCLKA = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_XCLKA));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D1=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D1 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D1));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D3=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D3 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D3));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D5=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D5 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D5));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D7=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D7 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D7));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D9=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D9 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D9));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D11=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D11 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D11));
 }
 EXPORT_SYMBOL(isp_print_status);
diff --git a/drivers/media/video/oldisp/isp.h b/drivers/media/video/oldisp/isp.h
index 8d6cd17..895fd73 100644
--- a/drivers/media/video/oldisp/isp.h
+++ b/drivers/media/video/oldisp/isp.h
@@ -74,7 +74,7 @@
 #define NUM_ISP_CAPTURE_FORMATS 	(sizeof(isp_formats) /\
 							sizeof(isp_formats[0]))
 #define ISP_WORKAROUND 1
-#define ISP_BUFFER_MAX_SIZE (1024 * 1024 * 10)
+#define ISP_BUFFER_MAX_SIZE (1024 * 1024 * 16)
 #define ISP_BUFFER_MAX_PAGES (ISP_BUFFER_MAX_SIZE / ISPMMU_PAGE_SIZE)
 
 #define NR_PAGES(x, y)		((((y + x - 1) & PAGE_MASK) >> PAGE_SHIFT) - \
@@ -364,10 +364,13 @@ void __exit isp_hist_cleanup(void);
 void __exit isp_resizer_cleanup(void);
 void __exit isp_af_exit(void);
 
-struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pages_mapped);
+struct page **map_user_memory_to_kernel(unsigned long addr, u32 size,
+		u32 *nr_pages_mapped);
 void unmap_user_memory_from_kernel(struct page **pages, int nr_pages);
 
 int isp_run_resizer(void *userdata);
 int isp_run_preview(void *userdata);
 
+int isp_lsc_workaround_enabled(void);
+
 #endif	/* OMAP_ISP_TOP_H */
diff --git a/drivers/media/video/oldisp/ispccdc.c b/drivers/media/video/oldisp/ispccdc.c
index 044e247..d8c8654 100644
--- a/drivers/media/video/oldisp/ispccdc.c
+++ b/drivers/media/video/oldisp/ispccdc.c
@@ -47,6 +47,8 @@ static unsigned long fpc_table_add_m;
  * @ccdcout_h: CCDC output height.
  * @ccdcin_w: CCDC input width.
  * @ccdcin_h: CCDC input height.
+ * @ccdcin_wstart: CCDC input horizontal offset due to color order.
+ * @ccdcin_hstart: CCDC input vertical offset due to color order.
  * @ccdcin_woffset: CCDC input horizontal offset.
  * @ccdcin_hoffset: CCDC input vertical offset.
  * @crop_w: Crop width.
@@ -68,6 +70,8 @@ static struct isp_ccdc {
 	u32 ccdcout_h;
 	u32 ccdcin_w;
 	u32 ccdcin_h;
+	u8 ccdcin_wstart;
+	u8 ccdcin_hstart;
 	u32 ccdcin_woffset;
 	u32 ccdcin_hoffset;
 	u32 crop_w;
@@ -142,6 +146,22 @@ static struct isp_reg ispccdc_reg_list[] = {
 };
 
 /**
+ * isp_lsc_isr - LSC prefetch error interrupt handling.
+ **/
+void isp_lsc_isr(unsigned long status, void  *arg1, void *arg2)
+{
+	unsigned long irqflags = 0;
+
+	if (status & LSC_PRE_ERR) {
+		spin_lock_irqsave(&ispccdc_obj.ispccdc_lock, irqflags);
+		ispccdc_enable_lsc(0);
+		ispccdc_enable_lsc(1);
+		spin_unlock_irqrestore(&ispccdc_obj.ispccdc_lock, irqflags);
+		/* printk(KERN_ERR "isp_sr: LSC_PRE_ERR \n"); */
+	}
+}
+
+/**
  * omap34xx_isp_ccdc_config - Sets CCDC configuration from userspace
  * @userspace_add: Structure containing CCDC configuration sent from userspace.
  *
@@ -282,8 +302,8 @@ int omap34xx_isp_ccdc_config(void *userspace_add)
 			ispccdc_enable_lsc(1);
 		} else if ((ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) ==
 						ISP_ABS_CCDC_CONFIG_LSC) {
-				ispccdc_enable_lsc(0);
-				ccdc_use_lsc = 0;
+			ispccdc_enable_lsc(0);
+			ccdc_use_lsc = 0;
 		}
 		mutex_lock(&ispccdc_obj.ispccdc_mutex);
 		if ((ISP_ABS_TBL_LSC & ccdc_struct->update)
@@ -299,18 +319,22 @@ int omap34xx_isp_ccdc_config(void *userspace_add)
 						"Cannot allocate\
 						memory for \
 						gain tables \n");
-					mutex_unlock(&ispccdc_obj.ispccdc_mutex);
+					mutex_unlock(
+						&ispccdc_obj.ispccdc_mutex);
 					return -ENOMEM;
 				}
 				lsc_ispmmu_addr = ispmmu_map(
-					virt_to_phys((u8 *)ALIGN_TO(lsc_gain_table, 0x1000)),
+					virt_to_phys((u8 *)ALIGN_TO(
+						lsc_gain_table,
+						0x1000)),
 					lsc_config.size);
 				omap_writel(lsc_ispmmu_addr,
 					ISPCCDC_LSC_TABLE_BASE);
 				lsc_initialized = 1;
 				size_mismatch = 0;
 			}
-			if (copy_from_user((u8 *)ALIGN_TO(lsc_gain_table, 0x1000),
+			if (copy_from_user((u8 *)ALIGN_TO(lsc_gain_table,
+				0x1000),
 				(ccdc_struct->lsc), lsc_config.size)) {
 				mutex_unlock(&ispccdc_obj.ispccdc_mutex);
 				goto copy_from_user_err;
@@ -371,7 +395,7 @@ int ispccdc_request(void)
 							ISPCTRL_CCDC_CLK_EN |
 							ISPCTRL_SBL_WR1_RAM_EN,
 							ISP_CTRL);
-	omap_writel((omap_readl(ISPCCDC_CFG)) | ISPCCDC_CFG_VDLC, ISPCCDC_CFG);
+	omap_writel((omap_readl(ISPCCDC_CFG) | ISPCCDC_CFG_VDLC), ISPCCDC_CFG);
 	spin_unlock(&ispccdc_obj.ispccdc_lock);
 	return 0;
 }
@@ -479,20 +503,40 @@ void ispccdc_enable_lsc(u8 enable)
 		return;
 
 	if (enable) {
-		omap_writel(omap_readl(ISP_CTRL) | ISPCTRL_SBL_SHARED_RPORTB |
-					ISPCTRL_SBL_RD_RAM_EN, ISP_CTRL);
-		omap_writel(omap_readl(ISPCCDC_LSC_CONFIG) | 0x1,
-							ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISP_CTRL) | (ISPCTRL_SBL_SHARED_RPORTB |
+					ISPCTRL_SBL_RD_RAM_EN)), ISP_CTRL);
+		omap_writel((omap_readl(ISPCCDC_LSC_CONFIG) | 0x1),
+			ISPCCDC_LSC_CONFIG);
 		ispccdc_obj.lsc_en = 1;
 	} else {
-		omap_writel(omap_readl(ISPCCDC_LSC_CONFIG) & 0xFFFE,
-							ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISPCCDC_LSC_CONFIG) & ~0x1),
+			ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISP_CTRL) &
+					~(ISPCTRL_SBL_SHARED_RPORTB |
+					ISPCTRL_SBL_RD_RAM_EN)), ISP_CTRL);
 		ispccdc_obj.lsc_en = 0;
 	}
 }
 EXPORT_SYMBOL(ispccdc_enable_lsc);
 
 /**
+ * ispccdc_set_crop_offset_dynamic - Store the component order as component offset.
+ * @raw_fmt: Input data component order.
+ *
+ * Turns the component order into a horizontal & vertical offset and store
+ * offsets to be used later.
+ **/
+void ispccdc_set_crop_offset_dynamic(struct ispccdc_color_offset offset)
+{
+	printk(KERN_INFO "ipsccdc crop offset dyn(%d)\n", offset.offsetcode);
+	if (offset.offsetcode > ISPCCDC_INPUT_FMT_GB_RG)
+		offset.offsetcode = 0;
+	ispccdc_set_crop_offset(offset.offsetcode);
+
+}
+EXPORT_SYMBOL(ispccdc_set_crop_offset_dynamic);
+
+/**
  * ispccdc_set_crop_offset - Store the component order as component offset.
  * @raw_fmt: Input data component order.
  *
@@ -503,22 +547,26 @@ void ispccdc_set_crop_offset(enum ispccdc_raw_fmt raw_fmt)
 {
 	switch (raw_fmt) {
 	case ISPCCDC_INPUT_FMT_GR_BG:
-		ispccdc_obj.ccdcin_woffset = 1;
-		ispccdc_obj.ccdcin_hoffset = 0;
+		ispccdc_obj.ccdcin_wstart = 1;
+		ispccdc_obj.ccdcin_hstart = 0;
 		break;
 	case ISPCCDC_INPUT_FMT_BG_GR:
-		ispccdc_obj.ccdcin_woffset = 1;
-		ispccdc_obj.ccdcin_hoffset = 1;
+		ispccdc_obj.ccdcin_wstart = 1;
+		ispccdc_obj.ccdcin_hstart = 1;
 		break;
 	case ISPCCDC_INPUT_FMT_RG_GB:
-		ispccdc_obj.ccdcin_woffset = 0;
-		ispccdc_obj.ccdcin_hoffset = 0;
+		ispccdc_obj.ccdcin_wstart = 0;
+		ispccdc_obj.ccdcin_hstart = 0;
 		break;
 	case ISPCCDC_INPUT_FMT_GB_RG:
-		ispccdc_obj.ccdcin_woffset = 0;
-		ispccdc_obj.ccdcin_hoffset = 1;
+		ispccdc_obj.ccdcin_wstart = 0;
+		ispccdc_obj.ccdcin_hstart = 1;
 		break;
 	}
+	DPRINTK_ISPCCDC("ispccdc_crop_offset(%d)\n", raw_fmt);
+
+	ispccdc_obj.ccdcin_woffset = ispccdc_obj.ccdcin_wstart;
+	ispccdc_obj.ccdcin_hoffset = ispccdc_obj.ccdcin_hstart;
 }
 EXPORT_SYMBOL(ispccdc_set_crop_offset);
 
@@ -540,8 +588,10 @@ EXPORT_SYMBOL(ispccdc_set_crop_offset);
  **/
 void ispccdc_config_crop(u32 left, u32 top, u32 height, u32 width)
 {
-	ispccdc_obj.ccdcin_woffset = left + ((left + 1) % 2);
-	ispccdc_obj.ccdcin_hoffset = top + (top % 2);
+	ispccdc_obj.ccdcin_woffset = left +
+		((left + ispccdc_obj.ccdcin_wstart) % 2);
+	ispccdc_obj.ccdcin_hoffset = top +
+		((top + ispccdc_obj.ccdcin_hstart) % 2);
 
 	ispccdc_obj.crop_w = width - (width % 16);
 	ispccdc_obj.crop_h = height + (height % 2);
@@ -576,7 +626,7 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 	struct ispccdc_syncif syncif;
 	struct ispccdc_bclamp blkcfg;
 
-	u32 colptn = (ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT) |
+   u32 colptn = (ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT) |
 		(ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC1_SHIFT) |
 		(ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC2_SHIFT) |
 		(ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC3_SHIFT) |
@@ -630,7 +680,7 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
 		spin_lock(&ispccdc_obj.ispccdc_lock);
-		omap_writel((omap_readl(ISPCCDC_CFG)) & ~ISPCCDC_CFG_WENLOG,
+		omap_writel((omap_readl(ISPCCDC_CFG) & ~ISPCCDC_CFG_WENLOG),
 								ISPCCDC_CFG);
 		spin_unlock(&ispccdc_obj.ispccdc_lock);
 		vpcfg.bitshift_sel = BIT11_2;
@@ -658,8 +708,8 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		/* Generally cam_wen is used with cam_hs, vs signals */
 		syn_mode |= ISPCCDC_SYN_MODE_EXWEN;
-		omap_writel((omap_readl(ISPCCDC_CFG))
-			| ISPCCDC_CFG_WENLOG, ISPCCDC_CFG);
+		omap_writel((omap_readl(ISPCCDC_CFG) |
+			ISPCCDC_CFG_WENLOG), ISPCCDC_CFG);
 		/* Video Port Configuration */
 		vpcfg.bitshift_sel = BIT9_0;
 		vpcfg.freq_sel = PIXCLKBY2;
@@ -775,8 +825,10 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 
 	ispccdc_obj.ccdc_inpfmt = input;
 	ispccdc_obj.ccdc_outfmt = output;
-		ispccdc_print_status();
-		isp_print_status();
+
+	ispccdc_print_status();
+	isp_print_status();
+
 	return 0;
 }
 EXPORT_SYMBOL(ispccdc_config_datapath);
@@ -1283,6 +1335,7 @@ int ispccdc_try_size(u32 input_w, u32 input_h, u32 *output_w, u32 *output_h)
 			*output_w -= (*output_w % 16);
 			*output_w += 16;
 		}
+      *output_h -= ispccdc_obj.ccdcin_hstart;
 	}
 
 	ispccdc_obj.ccdcout_w = *output_w;
@@ -1339,12 +1392,32 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 			((ispccdc_obj.ccdcin_h-ispccdc_obj.ccdcin_hoffset) <<
 					ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 					ISPCCDC_FMT_VERT);
+
+	#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		omap_writel(ispccdc_obj.ccdcin_woffset
+						<< ISPCCDC_HORZ_INFO_SPH_SHIFT
+						| ((ispccdc_obj.ccdcout_w - 1)
+						<< ISPCCDC_HORZ_INFO_NPH_SHIFT),
+						ISPCCDC_HORZ_INFO);
+		omap_writel(ispccdc_obj.ccdcin_hoffset
+				<< ISPCCDC_VERT_START_SLV0_SHIFT,
+				ISPCCDC_VERT_START);
+		omap_writel((ispccdc_obj.ccdcout_h - 1) <<
+						ISPCCDC_VERT_LINES_NLV_SHIFT,
+						ISPCCDC_VERT_LINES);
+		ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2, 0, 0);
+	#else
+		omap_writel(ISPCCDC_HORZ_INFO_RESET, ISPCCDC_HORZ_INFO);
+		omap_writel(0, ISPCCDC_VERT_START);
+		omap_writel(0, ISPCCDC_VERT_LINES);
+	#endif
+
 		omap_writel((ispccdc_obj.ccdcout_w <<
 					ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
 					(ispccdc_obj.ccdcout_h <<
 					ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
 					ISPCCDC_VP_OUT);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25) &
+		omap_writel((((ispccdc_obj.ccdcout_h - 1) &
 					ISPCCDC_VDINT_0_MASK) <<
 					ISPCCDC_VDINT_0_SHIFT) |
 					((50 & ISPCCDC_VDINT_1_MASK) <<
@@ -1385,16 +1458,18 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 					((50 & ISPCCDC_VDINT_1_MASK) <<
 					ISPCCDC_VDINT_1_SHIFT), ISPCCDC_VDINT);
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_VP_MEM) {
-		omap_writel((1 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcin_woffset <<
+					ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
 					(ispccdc_obj.ccdcin_w <<
 					ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
 					ISPCCDC_FMT_HORZ);
-		omap_writel((0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcin_hoffset <<
+					ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
 					((ispccdc_obj.ccdcin_h) <<
 					ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 					ISPCCDC_FMT_VERT);
-		omap_writel((ispccdc_obj.ccdcout_w
-					<< ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcout_w <<
+					ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
 					(ispccdc_obj.ccdcout_h <<
 					ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
 					ISPCCDC_VP_OUT);
@@ -1405,17 +1480,19 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 					ISPCCDC_HORZ_INFO_NPH_SHIFT),
 					ISPCCDC_HORZ_INFO);
 */
-		omap_writel(1 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+		omap_writel(ispccdc_obj.ccdcin_woffset <<
+					ISPCCDC_HORZ_INFO_SPH_SHIFT |
 					((ispccdc_obj.ccdcout_w - 1) <<
 					ISPCCDC_HORZ_INFO_NPH_SHIFT),
 					ISPCCDC_HORZ_INFO);
-		omap_writel(0 << ISPCCDC_VERT_START_SLV0_SHIFT,
+		omap_writel(ispccdc_obj.ccdcin_hoffset <<
+					ISPCCDC_VERT_START_SLV0_SHIFT,
 					ISPCCDC_VERT_START);
 		omap_writel((ispccdc_obj.ccdcout_h - 1) <<
 					ISPCCDC_VERT_LINES_NLV_SHIFT,
 					ISPCCDC_VERT_LINES);
 		ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2, 0, 0);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25) &
+		omap_writel((((ispccdc_obj.ccdcout_h - 1) &
 					ISPCCDC_VDINT_0_MASK) <<
 					ISPCCDC_VDINT_0_SHIFT) |
 					((50 & ISPCCDC_VDINT_1_MASK) <<
@@ -1423,12 +1500,14 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_LSC_MEM) {
 		/* Added by MMS */
 		/* Start with 1 pixel apart */
-		omap_writel((1 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT)
+		omap_writel((ispccdc_obj.ccdcin_woffset <<
+				ISPCCDC_FMT_HORZ_FMTSPH_SHIFT)
 				| (ispccdc_obj.ccdcin_w
 				<< ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
 				ISPCCDC_FMT_HORZ);
 
-		omap_writel((0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT)
+		omap_writel((ispccdc_obj.ccdcin_hoffset <<
+				ISPCCDC_FMT_VERT_FMTSLV_SHIFT)
 				| ((ispccdc_obj.ccdcin_h)
 				<< ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 				ISPCCDC_FMT_VERT);
@@ -1450,7 +1529,7 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 		/*Configure the HSIZE_OFF with output buffer width*/
 
 		ispccdc_config_outlineoffset((ispccdc_obj.ccdcout_w * 2), 0, 0);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25)
+		omap_writel((((ispccdc_obj.ccdcout_h - 1)
 				& ISPCCDC_VDINT_0_MASK)
 				<< ISPCCDC_VDINT_0_SHIFT)
 				| (((50) &  ISPCCDC_VDINT_1_MASK)
@@ -1564,15 +1643,18 @@ void ispccdc_enable(u8 enable)
 	if (enable) {
 		if (ccdc_use_lsc && !ispccdc_obj.lsc_en &&
 			((ispccdc_obj.ccdc_inpfmt == CCDC_RAW) ||
-			(ispccdc_obj.ccdc_inpfmt == CCDC_RAW_PATTERN)))
+			(ispccdc_obj.ccdc_inpfmt == CCDC_RAW_PATTERN))) {
 			ispccdc_enable_lsc(1);
-			omap_writel(omap_readl(ISPCCDC_PCR) | (ISPCCDC_PCR_EN),
+		}
+		omap_writel(CCDC_VD0|CCDC_VD1, ISP_IRQ0STATUS);
+		omap_writel(omap_readl(ISPCCDC_PCR) | (ISPCCDC_PCR_EN),
 								ISPCCDC_PCR);
 	} else {
 		omap_writel(omap_readl(ISPCCDC_PCR) & ~(ISPCCDC_PCR_EN),
 								ISPCCDC_PCR);
 	}
-
+	/* write sync */
+	omap_readl(ISPCCDC_PCR);
 }
 EXPORT_SYMBOL(ispccdc_enable);
 
diff --git a/drivers/media/video/oldisp/ispccdc.h b/drivers/media/video/oldisp/ispccdc.h
index a7d1aa5..b0a9068 100644
--- a/drivers/media/video/oldisp/ispccdc.h
+++ b/drivers/media/video/oldisp/ispccdc.h
@@ -215,6 +215,9 @@ void ispccdc_set_wenlog(u32 wenlog);
 
 void ispccdc_set_dcsub(u32 dcsub);
 
+void ispccdc_set_crop_offset_dynamic(struct ispccdc_color_offset offset);
+
 void ispccdc_set_crop_offset(enum ispccdc_raw_fmt);
 
+void isp_lsc_isr(unsigned long status, void *arg1, void *arg2);
 #endif		/* OMAP_ISP_CCDC_H */
diff --git a/drivers/media/video/oldisp/ispcsi2.c b/drivers/media/video/oldisp/ispcsi2.c
index 2e25858..b7218eb 100644
--- a/drivers/media/video/oldisp/ispcsi2.c
+++ b/drivers/media/video/oldisp/ispcsi2.c
@@ -47,6 +47,15 @@ static bool update_ctrl;
 static bool uses_videoport;
 
 /**
+ * isp_csia_isr - CSIA interrupt handling.
+ **/
+void isp_csia_isr(unsigned long status, void *arg1, void *arg2)
+{
+	if (status & CSIA)
+		isp_csi2_isr();
+}
+
+/**
  * isp_csi2_complexio_lanes_config - Configuration of CSI2 ComplexIO lanes.
  * @reqcfg: Pointer to structure containing desired lane configuration
  *
@@ -1808,8 +1817,15 @@ void isp_csi2_isr(void)
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ)
 		printk(KERN_DEBUG "CSI2: ECC correction done\n");
 
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ) {
+		printk(KERN_ERR "CSI2: ECC correction failed\n");
+		ecc_counter++;
+	}
+#else
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ)
 		printk(KERN_ERR "CSI2: ECC correction failed\n");
+#endif
 
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ)
 		printk(KERN_ERR "CSI2: ComplexIO #2 failed\n");
diff --git a/drivers/media/video/oldisp/ispcsi2.h b/drivers/media/video/oldisp/ispcsi2.h
index 3cd366a..853a32e 100644
--- a/drivers/media/video/oldisp/ispcsi2.h
+++ b/drivers/media/video/oldisp/ispcsi2.h
@@ -177,6 +177,11 @@ struct isp_csi2_cfg_update {
 	struct isp_csi2_ctrl_cfg_update ctrl;
 };
 
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+/*Counters for MIPI DLI.*/
+extern unsigned long ecc_counter;
+#endif
+
 int isp_csi2_complexio_lanes_config(struct isp_csi2_lanes_cfg *reqcfg);
 int isp_csi2_complexio_lanes_update(bool force_update);
 int isp_csi2_complexio_lanes_count(int cnt);
@@ -232,6 +237,7 @@ void isp_csi2_isr(void);
 int isp_csi2_reset(void);
 void isp_csi2_enable(int enable);
 void isp_csi2_regdump(void);
+void isp_csia_isr(unsigned long status, void *arg1, void *arg2);
 
 #endif	/* OMAP_ISP_CSI2_H */
 
diff --git a/drivers/media/video/oldisp/ispmmu.c b/drivers/media/video/oldisp/ispmmu.c
index c937bba..56ceef4 100644
--- a/drivers/media/video/oldisp/ispmmu.c
+++ b/drivers/media/video/oldisp/ispmmu.c
@@ -478,6 +478,7 @@ dma_addr_t ispmmu_map_pages(struct page **pages, int page_nr)
 	u32 pd, p_addr;
 	u32 *l2_table;
 	u32 page_index = 0;
+	dma_addr_t ret_addr;
 
 	DPRINTK_ISPMMU("map_pages: page_nr (number of pages) = %d\n", page_nr);
 
@@ -529,8 +530,11 @@ dma_addr_t ispmmu_map_pages(struct page **pages, int page_nr)
 	DPRINTK_ISPMMU("mapped to ISP virtual address 0x%x\n",
 		(u32)((idx << 20) + (p_addr & (PAGE_SIZE - 1))));
 
+	down(&ispmmu_mutex);
 	omap_writel(1, ISPMMU_GFLUSH);
-	return (dma_addr_t)((idx<<20) + (p_addr & (PAGE_SIZE - 1)));
+	up(&ispmmu_mutex);
+	ret_addr = (dma_addr_t)((idx<<20) + (p_addr & (PAGE_SIZE - 1)));
+	return ret_addr;
 
 release_mem:
 	for (; i >= 0; i--) {
@@ -576,6 +580,7 @@ int ispmmu_unmap(dma_addr_t v_addr)
 		return -EINVAL;
 	}
 
+	down(&ispmmu_mutex);
 	while (((*(ttb + idx)) & (ISPMMU_L1D_TYPE_MASK <<
 						ISPMMU_L1D_TYPE_SHIFT)) ==
 						(ISPMMU_L1D_TYPE_PAGE <<
@@ -583,13 +588,12 @@ int ispmmu_unmap(dma_addr_t v_addr)
 		*(ttb + idx) = (ISPMMU_L1D_TYPE_FAULT <<
 						ISPMMU_L1D_TYPE_SHIFT);
 		free_l2_page_table(l2p_table_addr[idx]);
-		l2p_table_addr[idx++] = 0;
-		if (!(idx % ISPMMU_REGION_ENTRIES_NR)) {
+		l2p_table_addr[idx] = 0;
+		if (!((++idx) % ISPMMU_REGION_ENTRIES_NR)) {
 			DPRINTK_ISPMMU("Do not exceed this 32M region\n");
 			break;
 		}
 	}
-	down(&ispmmu_mutex);
 	omap_writel(1, ISPMMU_GFLUSH);
 	up(&ispmmu_mutex);
 
diff --git a/drivers/media/video/oldisp/ispmmu.h b/drivers/media/video/oldisp/ispmmu.h
index 265ebb9..6560249 100644
--- a/drivers/media/video/oldisp/ispmmu.h
+++ b/drivers/media/video/oldisp/ispmmu.h
@@ -68,7 +68,7 @@
  * to keep track of these 16 L2 page table's status.
  */
 #define L2P_TABLE_SIZE			1024
-#define L2P_TABLE_NR 			62 /* Currently supports 4*5MP shots */
+#define L2P_TABLE_NR 			80
 #define L2P_TABLES_SIZE 		(L2P_TABLE_SIZE * L2P_TABLE_NR)
 
 /* Extra memory allocated to get ttb aligned on 16KB */
diff --git a/drivers/media/video/oldisp/isppreview.c b/drivers/media/video/oldisp/isppreview.c
index ac47153..716d294 100644
--- a/drivers/media/video/oldisp/isppreview.c
+++ b/drivers/media/video/oldisp/isppreview.c
@@ -460,30 +460,29 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 {
 	int ctr;
 
+	mutex_lock(&ispprev_obj.ispprev_mutex);
 	if ((ISP_ABS_TBL_NF & isptables_struct->flag) == ISP_ABS_TBL_NF) {
 		NF_enable = 1;
 		params->features |= (PREV_NOISE_FILTER);
 		if ((ISP_ABS_TBL_NF & isptables_struct->update) ==
 							ISP_ABS_TBL_NF) {
-			mutex_lock(&ispprev_obj.ispprev_mutex);
+			spin_lock(&ispprev_obj.ispprev_lock);
+
 			if (copy_from_user(&prev_nf_t, (struct ispprev_nf *)
 						(isptables_struct->prev_nf),
 						sizeof(struct ispprev_nf))) {
-				mutex_unlock(&ispprev_obj.ispprev_mutex);
+				spin_unlock(&ispprev_obj.ispprev_lock);
 				goto err_copy_from_user;
 			}
 
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 
-			spin_lock(&ispprev_obj.ispprev_lock);
 			if (ispprev_obj.stream_on == 0) {
 				NF_update = 0;
 				isppreview_config_noisefilter(prev_nf_t);
 				isppreview_enable_noisefilter(NF_enable);
 			} else
 				NF_update = 1;
-
-			spin_unlock(&ispprev_obj.ispprev_lock);
 		} else
 			NF_update = 0;
 	} else {
@@ -498,15 +497,16 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 
 	if ((ISP_ABS_TBL_REDGAMMA & isptables_struct->update) ==
 							ISP_ABS_TBL_REDGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
-		if (copy_from_user(redgamma_table, isptables_struct->red_gamma,
+		spin_lock(&ispprev_obj.ispprev_lock);
+
+		if (copy_from_user(redgamma_table,
+						isptables_struct->red_gamma,
 						sizeof(redgamma_table))) {
 			RG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_RED_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -517,24 +517,20 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			RG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		RG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
 	if ((ISP_ABS_TBL_GREENGAMMA & isptables_struct->update) ==
 						ISP_ABS_TBL_GREENGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
+		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (copy_from_user(greengamma_table,
 						isptables_struct->green_gamma,
 						sizeof(greengamma_table))) {
 			GG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_GREEN_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -545,24 +541,20 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			GG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		GG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
 	if ((ISP_ABS_TBL_BLUEGAMMA & isptables_struct->update) ==
 					ISP_ABS_TBL_BLUEGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
-		if (copy_from_user(bluegamma_table, (isptables_struct->
-						blue_gamma),
+		spin_lock(&ispprev_obj.ispprev_lock);
+
+		if (copy_from_user(bluegamma_table,
+						(isptables_struct->blue_gamma),
 						sizeof(bluegamma_table))) {
 			BG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_BLUE_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -573,15 +565,14 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			BG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		BG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
+	mutex_unlock(&ispprev_obj.ispprev_mutex);
 	return 0;
 
 err_copy_from_user:
+	mutex_unlock(&ispprev_obj.ispprev_mutex);
+
 	printk(KERN_ERR "Preview Tables:Copy From User Error");
 	return -EINVAL;
 }
@@ -632,29 +623,29 @@ void isppreview_config_shadow_registers()
 	}
 
 	if (GG_update) {
+		GG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_GREEN_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
 			omap_writel(greengamma_table[ctr],
 							ISPPRV_SET_TBL_DATA);
 		}
-		GG_update = 0;
 	}
 
 	if (RG_update) {
+		RG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_RED_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++)
 			omap_writel(redgamma_table[ctr], ISPPRV_SET_TBL_DATA);
-		RG_update = 0;
 	}
 
 	if (BG_update) {
+		BG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_BLUE_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++)
 			omap_writel(bluegamma_table[ctr], ISPPRV_SET_TBL_DATA);
-		BG_update = 0;
 	}
 
 	if (NF_update && NF_enable) {
@@ -756,6 +747,8 @@ int isppreview_config_datapath(enum preview_input input,
 		pcr &= ~(ISPPRV_PCR_SOURCE);
 		pcr &= ~(ISPPRV_PCR_ONESHOT);
 		ispprev_obj.prev_inpfmt = PRV_RAW_CCDC;
+		isppreview_set_inaddr(0);
+		isppreview_config_inlineoffset(0);
 		break;
 	case PRV_RAW_MEM:
 		pcr |= ISPPRV_PCR_SOURCE;
@@ -1001,14 +994,10 @@ void isppreview_config_hmed(struct ispprev_hmed prev_hmed)
 	u32 odddist = 0;
 	u32 evendist = 0;
 
-	if (prev_hmed.odddist == 1)
-		odddist = ~ISPPRV_HMED_ODDDIST;
-	else
+	if (prev_hmed.odddist == 2)
 		odddist = ISPPRV_HMED_ODDDIST;
 
-	if (prev_hmed.evendist == 1)
-		evendist = ~ISPPRV_HMED_EVENDIST;
-	else
+	if (prev_hmed.evendist == 2)
 		evendist = ISPPRV_HMED_EVENDIST;
 
 	spin_lock(&ispprev_obj.ispprev_lock);
diff --git a/drivers/media/video/oldisp/ispreg.h b/drivers/media/video/oldisp/ispreg.h
index f7622d8..1b973a6 100644
--- a/drivers/media/video/oldisp/ispreg.h
+++ b/drivers/media/video/oldisp/ispreg.h
@@ -125,7 +125,7 @@
 #define CM_ICLKEN_CAM_EN		0x1
 #define CM_FCLKEN_CAM_EN		0x1
 
-#define CM_CAM_MCLK_HZ			432000000
+#define CM_CAM_MCLK_HZ		(OMAP_MCAM_SRC_CLK/OMAP_MCAM_SRC_DIV)
 
 /* ISP Submodules offset */
 
@@ -304,6 +304,8 @@
 #define ISPCCDC_PRGODD1			0x480BC690
 #define ISPCCDC_VP_OUT			0x480BC694
 
+#define ISPCCDC_HORZ_INFO_RESET		0x00000100
+
 #define ISPCCDC_LSC_CONFIG		0x480BC698
 #define ISPCCDC_LSC_INITIAL		0x480BC69C
 #define ISPCCDC_LSC_TABLE_BASE		0x480BC6A0
@@ -933,8 +935,9 @@
 #define ISPRSZ_PID_CID_SHIFT			8
 #define ISPRSZ_PID_TID_SHIFT			16
 
-#define ISPRSZ_PCR_ENABLE			0x5
+#define ISPRSZ_PCR_ENABLE			1
 #define ISPRSZ_PCR_BUSY				(1 << 1)
+#define ISPRSZ_PCR_ONESHOT			(1 << 2)
 
 #define ISPRSZ_CNT_HRSZ_SHIFT			0
 #define ISPRSZ_CNT_HRSZ_MASK			0x3FF
diff --git a/drivers/media/video/oldisp/ispresizer.c b/drivers/media/video/oldisp/ispresizer.c
index 221a21c..a8b3428 100644
--- a/drivers/media/video/oldisp/ispresizer.c
+++ b/drivers/media/video/oldisp/ispresizer.c
@@ -29,9 +29,7 @@
 #include "ispreg.h"
 #include "ispresizer.h"
 
-#if ISP_WORKAROUND
 dma_addr_t buff_addr_lsc_wa;
-#endif
 
 static u8 need_to_write_filter_coefs = {0};
 
@@ -262,6 +260,9 @@ int ispresizer_config_datapath(enum ispresizer_input input)
 	u32 cnt = 0;
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()+\n");
 	ispres_obj.resinput = input;
+
+	mutex_lock(&ispres_obj.ispres_mutex);
+	cnt = omap_readl(ISPRSZ_CNT);
 	switch (input) {
 	case RSZ_OTFLY_YUV:
 		cnt &= ~ISPRSZ_CNT_INPTYP;
@@ -282,13 +283,17 @@ int ispresizer_config_datapath(enum ispresizer_input input)
 		return -EINVAL;
 	}
 
-	mutex_lock(&ispres_obj.ispres_mutex);
-	omap_writel(omap_readl(ISPRSZ_CNT) | cnt, ISPRSZ_CNT);
+	omap_writel(cnt, ISPRSZ_CNT);
 	mutex_unlock(&ispres_obj.ispres_mutex);
 
+	/* Use bilinear interpolation for upsampling per TRM */
+	if (ispres_obj.outputwidth > ispres_obj.inputwidth)
+		ispresizer_enable_cbilin(1);
+	else
+		ispresizer_enable_cbilin(0);
+
 	ispresizer_config_ycpos(0);
 	ispresizer_config_filter_coef(&ispreszdefcoef);
-	ispresizer_enable_cbilin(0);
 	ispresizer_config_luma_enhance(&ispreszdefaultyenh);
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()-\n");
 	return 0;
@@ -341,7 +346,7 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 	input_h = *input_height;
 
 	if (input_w < 32 || input_h < 32) {
-		DPRINTK_ISPCCDC("ISP_ERR: RESIZER cannot handle input width"
+		DPRINTK_ISPRESZ("ISP_ERR: RESIZER cannot handle input width"
 				" less than 32 pixels or height less than"
 				" 32\n");
 		return -EINVAL;
@@ -387,8 +392,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 		if (rsz < MINIMUM_RESIZE_VALUE) {
 			rsz = MINIMUM_RESIZE_VALUE;
 			*output_h = (((input_h - 4) * 256) / rsz) + 1;
-			printk(KERN_INFO "%s: using output_h %d instead\n",
-			       __func__, *output_h);
 		}
 	} else {
 		rsz = rsz_7;
@@ -397,8 +400,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 		if (rsz > MAXIMUM_RESIZE_VALUE) {
 			rsz = MAXIMUM_RESIZE_VALUE;
 			*output_h = (((input_h - 7) * 256) / rsz) + 1;
-			printk(KERN_INFO "%s: using output_h %d instead\n",
-			       __func__, *output_h);
 		}
 	}
 
@@ -428,8 +429,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 			rsz = MAXIMUM_RESIZE_VALUE;
 			*output_w = (((input_w - 7) * 256) / rsz) + 1;
 			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			printk(KERN_INFO "%s: using output_w %d instead\n",
-			       __func__, *output_w);
 		}
 	} else {
 		rsz = rsz_4;
@@ -437,8 +436,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 			rsz = MINIMUM_RESIZE_VALUE;
 			*output_w = (((input_w - 4) * 256) / rsz) + 1;
 			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			printk(KERN_INFO "%s: using output_w %d instead\n",
-			       __func__, *output_w);
 		}
 	}
 
@@ -504,14 +501,15 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 		return -EINVAL;
 	}
 
-#if ISP_WORKAROUND
-	buff_addr_lsc_wa = isp_buf_get();
-	if (buff_addr_lsc_wa) {
-		/* Set Resizer input address and offset adderss */
-		ispresizer_set_inaddr(buff_addr_lsc_wa);
-		ispresizer_config_inlineoffset(omap_readl(ISPPRV_WADD_OFFSET));
+	if (isp_lsc_workaround_enabled()) {
+		buff_addr_lsc_wa = isp_buf_get();
+		if (buff_addr_lsc_wa) {
+			/* Set Resizer input address and offset adderss */
+			ispresizer_set_inaddr(buff_addr_lsc_wa);
+			ispresizer_config_inlineoffset
+				(omap_readl(ISPPRV_WADD_OFFSET));
+		}
 	}
-#endif
 
 	/* mutex_lock(&ispres_obj.ispres_mutex); */
 
@@ -522,19 +520,18 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 						ISPRSZ_CNT_VSTPH_SHIFT),
 						ISPRSZ_CNT);
 
-#if ISP_WORKAROUND
-	omap_writel((0x00 <<	ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-					(0x00 <<
-					ISPRSZ_IN_START_VERT_ST_SHIFT),
-					ISPRSZ_IN_START);
-
-#else
-	omap_writel(((ispres_obj.ipwd_crop * 2) <<
-					ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-					(ispres_obj.ipht_crop <<
-					ISPRSZ_IN_START_VERT_ST_SHIFT),
-					ISPRSZ_IN_START);
-#endif
+	if (isp_lsc_workaround_enabled()) {
+		omap_writel((0x00 <<	ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+						(0x00 <<
+						ISPRSZ_IN_START_VERT_ST_SHIFT),
+						ISPRSZ_IN_START);
+	} else {
+		omap_writel(((ispres_obj.ipwd_crop * 2) <<
+						ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+						(ispres_obj.ipht_crop <<
+						ISPRSZ_IN_START_VERT_ST_SHIFT),
+						ISPRSZ_IN_START);
+	}
 
 	omap_writel((ispres_obj.inputwidth << ISPRSZ_IN_SIZE_HORZ_SHIFT) |
 						(ispres_obj.inputheight <<
@@ -560,8 +557,8 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 						ISPRSZ_CNT);
 
 	/* mutex_unlock(&ispres_obj.ispres_mutex); */
-
-    ispresizer_write_filter_coef();
+	if (!ispresizer_busy())
+		ispresizer_write_filter_coef();
 
     ispresizer_config_outlineoffset(output_w*2);
     DPRINTK_ISPRESZ("ispresizer_config_size()-\n");
@@ -577,13 +574,22 @@ EXPORT_SYMBOL(ispresizer_config_size);
  **/
 void ispresizer_enable(u8 enable)
 {
-	int val;
+	u32 val;
 	DPRINTK_ISPRESZ("+ispresizer_enable()+\n");
-	if (enable)
-		val = (((omap_readl(ISPRSZ_PCR)) & 0x2) | ISPRSZ_PCR_ENABLE);
-	else
-		val = (omap_readl(ISPRSZ_PCR) & ~ISPRSZ_PCR_ENABLE);
-	omap_writel(val, ISPRSZ_PCR);
+	val = omap_readl(ISPRSZ_PCR);
+	if (enable) {
+		if (!(val & ISPRSZ_PCR_ENABLE)) {
+			omap_writel(RESZ_DONE, ISP_IRQ0STATUS);
+			omap_writel((val | ISPRSZ_PCR_ONESHOT |
+				ISPRSZ_PCR_ENABLE), ISPRSZ_PCR);
+			/* write sync */
+			omap_readl(ISPRSZ_PCR);
+		}
+	} else if (val & ISPRSZ_PCR_ENABLE) {
+		omap_writel((val & ~ISPRSZ_PCR_ENABLE), ISPRSZ_PCR);
+		/* write sync */
+		omap_readl(ISPRSZ_PCR);
+	}
 	DPRINTK_ISPRESZ("+ispresizer_enable()-\n");
 }
 EXPORT_SYMBOL(ispresizer_enable);
@@ -727,78 +733,74 @@ void ispresizer_write_filter_coef(void)
 	int i, j;
 	DPRINTK_ISPRESZ("ispresizer_write_filter_coef\n");
 
-	if (ispresizer_busy() == 0) {
-		if (ispres_obj.h_resz <= MID_RESIZE_VALUE) {
-			j = 0;
-			for (i = 0; i < 16; i++) {
+	if (ispres_obj.h_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			omap_writel((ispres_obj.coeflist.
+					h_filter_coef_4tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					h_filter_coef_4tap[j + 1] <<
+					ISPRSZ_HFILT10_COEF1_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
 				omap_writel((ispres_obj.coeflist.
-						h_filter_coef_4tap[j] <<
-						ISPRSZ_HFILT10_COEF0_SHIFT) |
-						(ispres_obj.coeflist.
-						h_filter_coef_4tap[j + 1] <<
-						ISPRSZ_HFILT10_COEF1_SHIFT),
-						ISPRSZ_HFILT10 + (i * 0x04));
+					h_filter_coef_7tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
+				j += 1;
+			} else {
+				omap_writel((ispres_obj.coeflist.
+					h_filter_coef_7tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					h_filter_coef_7tap[j+1] <<
+					ISPRSZ_HFILT10_COEF1_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
 				j += 2;
 			}
-		} else {
-			j = 0;
-			for (i = 0; i < 16; i++) {
-				if ((i + 1) % 4 == 0) {
-					omap_writel((ispres_obj.coeflist.
-							h_filter_coef_7tap[j] <<
-							ISPRSZ_HFILT10_COEF0_SHIFT),
-							ISPRSZ_HFILT10 + (i * 0x04));
-					j += 1;
-				} else {
-					omap_writel((ispres_obj.coeflist.
-							h_filter_coef_7tap[j] <<
-							ISPRSZ_HFILT10_COEF0_SHIFT) |
-							(ispres_obj.coeflist.
-							h_filter_coef_7tap[j+1] <<
-							ISPRSZ_HFILT10_COEF1_SHIFT),
-							ISPRSZ_HFILT10 + (i * 0x04));
-					j += 2;
-				}
-			}
 		}
-		if (ispres_obj.v_resz <= MID_RESIZE_VALUE) {
-			j = 0;
-			for (i = 0; i < 16; i++) {
+	}
+	if (ispres_obj.v_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			omap_writel((ispres_obj.coeflist.
+					v_filter_coef_4tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					v_filter_coef_4tap[j + 1] <<
+					ISPRSZ_VFILT10_COEF1_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
+				omap_writel((ispres_obj.coeflist.
+					v_filter_coef_7tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
+				j += 1;
+			} else {
 				omap_writel((ispres_obj.coeflist.
-						v_filter_coef_4tap[j] <<
-						ISPRSZ_VFILT10_COEF0_SHIFT) |
-						(ispres_obj.coeflist.
-						v_filter_coef_4tap[j + 1] <<
-						ISPRSZ_VFILT10_COEF1_SHIFT),
-						ISPRSZ_VFILT10 + (i * 0x04));
+					v_filter_coef_7tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					v_filter_coef_7tap[j+1] <<
+					ISPRSZ_VFILT10_COEF1_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
 				j += 2;
 			}
-		} else {
-			j = 0;
-			for (i = 0; i < 16; i++) {
-				if ((i + 1) % 4 == 0) {
-					omap_writel((ispres_obj.coeflist.
-							v_filter_coef_7tap[j] <<
-							ISPRSZ_VFILT10_COEF0_SHIFT),
-							ISPRSZ_VFILT10 + (i * 0x04));
-					j += 1;
-				} else {
-					omap_writel((ispres_obj.coeflist.
-							v_filter_coef_7tap[j] <<
-							ISPRSZ_VFILT10_COEF0_SHIFT) |
-							(ispres_obj.coeflist.
-							v_filter_coef_7tap[j+1] <<
-							ISPRSZ_VFILT10_COEF1_SHIFT),
-							ISPRSZ_VFILT10 + (i * 0x04));
-					j += 2;
-				}
-			}
 		}
-
-		need_to_write_filter_coefs = 0;
-	} else {
-		DPRINTK_ISPRESZ("Resizer busy when programming filter coefs\n");
 	}
+
+	need_to_write_filter_coefs = 0;
 }
 EXPORT_SYMBOL(ispresizer_write_filter_coef);
 
@@ -813,6 +815,7 @@ int ispresizer_config_inlineoffset(u32 offset)
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()+\n");
 	if (offset%32)
 		return -EINVAL;
+
 	omap_writel(offset << ISPRSZ_SDR_INOFF_OFFSET_SHIFT, ISPRSZ_SDR_INOFF);
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()-\n");
 	return 0;
@@ -830,6 +833,7 @@ int ispresizer_set_inaddr(u32 addr)
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()+\n");
 	if (addr%32)
 		return -EINVAL;
+
 	omap_writel(addr << ISPRSZ_SDR_INADD_ADDR_SHIFT, ISPRSZ_SDR_INADD);
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()-\n");
 	return 0;
diff --git a/drivers/media/video/oldomap34xxcam.c b/drivers/media/video/oldomap34xxcam.c
index 39d26db..3bb2e36 100644
--- a/drivers/media/video/oldomap34xxcam.c
+++ b/drivers/media/video/oldomap34xxcam.c
@@ -147,7 +147,10 @@ int omap34xxcam_update_vbq(struct videobuf_buffer *vb)
 	struct isp_af_xtrastats af_xtrastats;
 #endif
 
+#if !defined(CONFIG_VIDEO_OMAP3_HP3A)
 	do_gettimeofday(&vb->ts);
+#endif
+
 	vb->field_count = atomic_add_return(2, &fh->field_count);
 	vb->state = VIDEOBUF_DONE;
 #ifndef CONFIG_VIDEO_OMAP3_HP3A
@@ -376,9 +379,17 @@ static int vidioc_g_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct omap34xxcam_fh *ofh = fh;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_format sensor_format;
 
+	/* Get size_out */
 	mutex_lock(&vdev->mutex);
 	f->fmt.pix = ofh->pix;
+
+	/* Get size_in (sensor pixel format) & save in user defined raw_data
+	   after f->fmt.pix */
+	vidioc_int_g_fmt_cap(vdev->vdev_sensor, &sensor_format);
+	memcpy(f->fmt.raw_data + sizeof(sensor_format.fmt.pix),
+		&sensor_format.fmt.pix, sizeof(sensor_format.fmt.pix));
 	mutex_unlock(&vdev->mutex);
 
 	return 0;
@@ -496,7 +507,8 @@ static int try_pix_parm(struct omap34xxcam_videodev *vdev,
 			 * Select bigger resolution if it's available
 			 * at same fps.
 			 */
-			if (frmi.width > best_pix_in->width
+			if ((frmi.width > best_pix_in->width ||
+				frmi.height > best_pix_in->height)
 			    && FPS_ABS_DIFF(fps, frmi.discrete)
 			    <= FPS_ABS_DIFF(fps, *best_ival))
 				goto do_it_now;
@@ -515,7 +527,7 @@ do_it_now:
 	if (best_pix_in->width == 0)
 		return -EINVAL;
 
-	dev_info(vdev->cam->dev, "w %d, h %d -> w %d, h %d\n",
+	dev_dbg(vdev->cam->dev, "w %d, h %d -> w %d, h %d\n",
 		 best_pix_in->width, best_pix_in->height,
 		 best_pix_out.width, best_pix_out.height);
 
@@ -1040,6 +1052,12 @@ static int vidioc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 
 	mutex_lock(&vdev->mutex);
 
+	/* If streaming, just change fps, don't try to change resolution */
+	if (vdev->streaming) {
+		rval = vidioc_int_s_parm(vdev->vdev_sensor, a);
+		goto out;
+	}
+
 	vdev->want_timeperframe = a->parm.capture.timeperframe;
 
 	pix_tmp = vdev->want_pix;
@@ -1047,6 +1065,7 @@ static int vidioc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 	rval = s_pix_parm(vdev, &pix_tmp_sensor, &pix_tmp,
 			  &a->parm.capture.timeperframe);
 
+out:
 	mutex_unlock(&vdev->mutex);
 
 	return rval;
@@ -1196,7 +1215,7 @@ static int vidioc_enum_frameintervals(struct file *file, void *fh,
  * feedback. The request is then passed on to the ISP private IOCTL handler,
  * isp_handle_private()
  */
-static int vidioc_default(struct file *file, void *fh, int cmd, void *arg)
+static long vidioc_default(struct file *file, void *fh, int cmd, void *arg)
 {
 	struct omap34xxcam_fh *ofh = file->private_data;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
@@ -1287,9 +1306,9 @@ out:
  * @dev: numeric device identifier.
  * @settings: ptr to a sensor settings structure.
  *
- * This request is passed to the sensor driver based on the bit masked flags field of the
- * settings structure. If the sensor does not support the requested operation, an error is
- * returned.
+ * This request is passed to the sensor driver based on the bit masked flags
+ * field of the settings structure. If the sensor does not support the
+ * requested operation, an error is returned.
  *
  * If the requested device id is not valid, -ENODEV is returned.
  */
@@ -1298,6 +1317,7 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 	int err = -1;
 	struct omap34xxcam_videodev *vdev = NULL;
 	struct omap34xxcam_device *cam = omap34xxcam;
+	struct v4l2_streamparm a;
 	struct v4l2_control vc;
 	int i;
 
@@ -1313,6 +1333,14 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 
 	mutex_lock(&vdev->mutex);
 
+	if ((settings->flags & OMAP34XXCAM_SET_FPS) &&
+		  settings->fps != 0) {
+		a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		a.parm.capture.timeperframe.numerator = 1;
+		a.parm.capture.timeperframe.denominator = settings->fps;
+		err = vidioc_int_s_parm(vdev->vdev_sensor, &a);
+	}
+
 	if (settings->flags & OMAP34XXCAM_SET_EXPOSURE) {
 		vc.id = V4L2_CID_EXPOSURE;
 		vc.value = settings->exposure;
@@ -1328,7 +1356,13 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 	}
 
 update_sensor_exit:
-   vc.id = V4L2_CID_EXPOSURE;
+	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (vidioc_int_g_parm(vdev->vdev_sensor, &a) == 0) {
+		settings->fps = a.parm.capture.timeperframe.denominator /
+			a.parm.capture.timeperframe.numerator;
+	}
+
+	vc.id = V4L2_CID_EXPOSURE;
 	vc.value = 0;
 	if (vidioc_int_g_ctrl(vdev->vdev_sensor, &vc) == 0)
 		settings->exposure = (u32)vc.value;
diff --git a/drivers/media/video/oldomap34xxcam.h b/drivers/media/video/oldomap34xxcam.h
index 1c9c2fc..de6f16e 100644
--- a/drivers/media/video/oldomap34xxcam.h
+++ b/drivers/media/video/oldomap34xxcam.h
@@ -243,12 +243,14 @@ struct cam_sensor_settings{
 	u16 gain;
 	u16 regs;
 	void *reg_data;
+	u16 fps;
 };
 
 #define	OMAP34XXCAM_SET_EXPOSURE		0x1
 #define	OMAP34XXCAM_SET_GAIN			         0x2
 #define	OMAP34XXCAM_READ_REGS			   0x4
 #define	OMAP34XXCAM_WRITE_REGS			   0x8
+#define	OMAP34XXCAM_SET_FPS			   0x10
 
 #define	OMAP34XXCAM_REG_8BIT			         0x1
 #define	OMAP34XXCAM_REG_16BIT			      0x2
diff --git a/drivers/media/video/omap-vout/omapvout-dss.c b/drivers/media/video/omap-vout/omapvout-dss.c
index f8b420b..25ecc8a 100644
--- a/drivers/media/video/omap-vout/omapvout-dss.c
+++ b/drivers/media/video/omap-vout/omapvout-dss.c
@@ -468,19 +468,46 @@ static int omapvout_dss_perform_vrfb_dma(struct omapvout_device *vout,
 
 		w = vout->crop.width;
 		h = vout->crop.height;
+		if (vrfb->decimate_src) {
+			w = w / 2;
+			h = h / 2;
+		}
 
 		dss_fmt = omapvout_dss_color_mode(vout->pix.pixelformat);
+		bytespp = omapvout_dss_format_bytespp(vout->pix.pixelformat);
+
 		omap_vrfb_setup(&vrfb->ctx[0], vrfb->phy_addr[0],
 				w, h, dss_fmt, rot);
 		omap_vrfb_setup(&vrfb->ctx[1], vrfb->phy_addr[1],
 				w, h, dss_fmt, rot);
-
 		omapvout_dss_calc_offset(vout, vrfb->ctx[0].bytespp,
 				vrfb->ctx[0].xoffset, vrfb->ctx[0].yoffset);
 
-		bytespp = omapvout_dss_format_bytespp(vout->pix.pixelformat);
 		vrfb->en = (w * bytespp) / 4; /* 32 bit ES */
 		vrfb->fn = h;
+
+		if (!vrfb->decimate_src) {
+			/* Maintain the previous settings to reduce risk */
+			vrfb->src_mode = OMAP_DMA_AMODE_POST_INC;
+			vrfb->src_ei = 0;
+			vrfb->src_fi = 0;
+		} else {
+			/* Decimate source frame by 2 */
+
+			/* Need to use double indexed DMA */
+			vrfb->src_mode = OMAP_DMA_AMODE_DOUBLE_IDX;
+			/* Skip every other word */
+			vrfb->src_ei = 4 + 1;
+			/* Skip every other line.
+			 * - Mult width by 2 to get real input frame line
+			 *   width for the skip.
+			 * - Add 4 to account for the trailing word  of the
+			 *   previous line that needs still needs to be
+			 *   skipped.
+			 */
+			vrfb->src_fi = (w * bytespp * 2) + 4 + 1;
+		}
+
 		vrfb->dst_ei = 1;
 		if (fmt == V4L2_PIX_FMT_YUYV || fmt == V4L2_PIX_FMT_UYVY) {
 			vrfb->dst_fi = (OMAP_VRFB_LINE_LEN * bytespp * 2)
@@ -496,9 +523,9 @@ static int omapvout_dss_perform_vrfb_dma(struct omapvout_device *vout,
 
 	omap_set_dma_transfer_params(vrfb->dma_ch, OMAP_DMA_DATA_TYPE_S32,
 				vrfb->en, vrfb->fn, OMAP_DMA_SYNC_ELEMENT,
-				vrfb->dma_id, 0x0);
-	omap_set_dma_src_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
-				src_paddr, 0, 0);
+				vrfb->dma_id, 0);
+	omap_set_dma_src_params(vrfb->dma_ch, 0, vrfb->src_mode,
+				src_paddr, vrfb->src_ei, vrfb->src_fi);
 	omap_set_dma_src_burst_mode(vrfb->dma_ch, OMAP_DMA_DATA_BURST_16);
 	omap_set_dma_dest_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_DOUBLE_IDX,
 				dst_paddr, vrfb->dst_ei, vrfb->dst_fi);
@@ -549,6 +576,11 @@ static int omapvout_dss_update_overlay(struct omapvout_device *vout,
 		o_info.height = vout->crop.height;
 	}
 
+	if (vrfb->decimate_src) { /* Decimate source frame by 2 */
+		o_info.width = o_info.width / 2;
+		o_info.height = o_info.height / 2;
+	}
+
 	o_info.pos_x = vout->win.w.left & ~1;
 	o_info.pos_y = vout->win.w.top & ~1;
 	o_info.out_width = vout->win.w.width;
@@ -570,10 +602,12 @@ static int omapvout_dss_update_overlay(struct omapvout_device *vout,
 		return rc;
 	}
 
+	if (ovly->manager->device->update) {
 	rc = ovly->manager->device->update(ovly->manager->device, 0, 0,
 					vout->disp_width, vout->disp_height);
 	if (rc)
 		DBG("Overlay update failed %d\n", rc);
+	}
 
 	return rc;
 }
@@ -656,7 +690,7 @@ static void omapvout_dss_perform_update(struct work_struct *work)
 		 * is unlocked since the sync may take some time.
 		 */
 		dev = dss->overlay->manager->device;
-		if (dev->sync)
+		if (dev && dev->sync)
 			dev->sync(dev);
 
 		/* Since the mutex was unlocked, it is possible that the DSS
@@ -782,6 +816,7 @@ int omapvout_dss_open(struct omapvout_device *vout, u16 *disp_w, u16 *disp_h)
 	INIT_WORK(&vout->dss->work, omapvout_dss_perform_update);
 
 	vout->dss->enabled = false;
+	vout->dss->vrfb.decimate_src = false;
 
 failed:
 	return rc;
@@ -877,10 +912,12 @@ void omapvout_dss_disable(struct omapvout_device *vout)
 	if (rc)
 		DBG("Overlay manager apply failed %d\n", rc);
 
+	if (ovly->manager->device->update) {
 	rc = ovly->manager->device->update(ovly->manager->device,
 				0, 0, vout->disp_width, vout->disp_height);
 	if (rc)
 		DBG("Display update failed %d\n", rc);
+	}
 }
 
 int omapvout_dss_update(struct omapvout_device *vout)
@@ -906,3 +943,13 @@ int omapvout_dss_update(struct omapvout_device *vout)
 	return 0;
 }
 
+bool omapvout_dss_get_decimate(struct omapvout_device *vout)
+{
+	return vout->dss->vrfb.decimate_src;
+}
+
+void omapvout_dss_set_decimate(struct omapvout_device *vout, bool enable)
+{
+	vout->dss->vrfb.decimate_src = enable;
+}
+
diff --git a/drivers/media/video/omap-vout/omapvout-dss.h b/drivers/media/video/omap-vout/omapvout-dss.h
index dde8eff..b9345d5 100644
--- a/drivers/media/video/omap-vout/omapvout-dss.h
+++ b/drivers/media/video/omap-vout/omapvout-dss.h
@@ -26,8 +26,12 @@ struct omapvout_dss_vrfb {
 	/* VRFB dma config data */
 	u32 en;
 	u32 fn;
+	u32 src_mode;
+	u32 src_ei;
+	u32 src_fi;
 	u32 dst_ei;
 	u32 dst_fi;
+	bool decimate_src;
 
 	/* VRFB dma channel data */
 	int dma_id;
@@ -75,6 +79,8 @@ extern bool omapvout_dss_is_rotation_supported(struct omapvout_device *vout);
 extern int  omapvout_dss_enable(struct omapvout_device *vout);
 extern void omapvout_dss_disable(struct omapvout_device *vout);
 extern int  omapvout_dss_update(struct omapvout_device *vout);
+extern bool omapvout_dss_get_decimate(struct omapvout_device *vout);
+extern void omapvout_dss_set_decimate(struct omapvout_device *vout, bool en);
 
 #endif /* __OMAPVOUT_DSS_H__ */
 
diff --git a/drivers/media/video/omap-vout/omapvout.c b/drivers/media/video/omap-vout/omapvout.c
index a56718f..1b74b7d 100644
--- a/drivers/media/video/omap-vout/omapvout.c
+++ b/drivers/media/video/omap-vout/omapvout.c
@@ -35,6 +35,7 @@
 #include "omapvout-vbq.h"
 #include "omapvout-bp.h"
 
+#define V4L2_CID_PRIVATE_DECIMATE_BY_2		(V4L2_CID_PRIVATE_BASE + 0x921)
 #define MODULE_NAME "omapvout"
 
 /* list of image formats supported by OMAP2 video pipelines */
@@ -70,8 +71,81 @@ const static struct v4l2_fmtdesc omap2_formats[] = {
 
 #define NUM_OUTPUT_FORMATS (sizeof(omap2_formats)/sizeof(omap2_formats[0]))
 
+/* This is a way to allow other components to force a desired rotation.
+ * This will take effect when streaming is next enabled.
+ */
+struct omapvout_override {
+	int dirty;
+	int force_rotation_dirty;
+	int force_rotation_enable;
+	int forced_rotation;
+	int client_rotation;
+};
+
+#define NUM_PLANES (3)
+static struct omapvout_override gOverride[NUM_PLANES];
+
+
+int omapvout_force_rotation(int plane, int enable, int rotation)
+{
+	struct omapvout_override *ovr;
+	int en;
+
+	if (plane < 0 || plane >= NUM_PLANES) {
+		DBG("Invalid plane (%d)\n", plane);
+		return -1;
+	}
+
+	ovr = &gOverride[plane];
+	if (ovr->force_rotation_enable == enable &&
+	    ovr->forced_rotation == rotation)
+		return 0;
+
+	en = (enable) ? 1 : 0;
+	if (en) {
+		if (rotation < 0 || rotation > 3) {
+			DBG("Invalid rotation (%d)\n", rotation);
+			return -1;
+		}
+
+		ovr->forced_rotation = rotation;
+	}
+
+	ovr->force_rotation_dirty = 1;
+	ovr->force_rotation_enable = en;
+	ovr->dirty = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL(omapvout_force_rotation);
+
 /*=== Local Functions ==================================================*/
 
+static void omapvout_chk_overrides(struct omapvout_device *vout)
+{
+	struct omapvout_override *ovr;
+
+	ovr = &gOverride[vout->id];
+
+	if (!ovr->dirty)
+		return;
+
+	if (ovr->force_rotation_dirty) {
+		ovr->force_rotation_dirty = 0;
+		if (ovr->force_rotation_enable) {
+			ovr->client_rotation = vout->rotation;
+			vout->rotation = ovr->forced_rotation;
+		} else {
+			vout->rotation = ovr->client_rotation;
+		}
+		printk("omapvout_chk_overrides/%d/%d/%d\n", \
+			ovr->force_rotation_enable, \
+			ovr->forced_rotation, ovr->client_rotation);
+	}
+
+	ovr->dirty = 0;
+}
+
 static int omapvout_crop_to_size(struct v4l2_rect *rect, int w, int h)
 {
 	struct v4l2_rect try;
@@ -227,6 +301,17 @@ static void omapvout_free_resources(struct omapvout_device *vout)
 	kfree(vout);
 }
 
+#ifdef CONFIG_TVOUT_SHOLEST
+static int video_status;
+void set_video_status(int onoff)
+{
+  video_status = onoff;
+}
+int get_video_status(void)
+{
+  return video_status;
+}
+#endif
 /*=== V4L2 Interface Functions =========================================*/
 
 static int omapvout_open(struct file *file)
@@ -237,6 +322,9 @@ static int omapvout_open(struct file *file)
 
 	DBG("omapvout_open\n");
 
+#ifdef CONFIG_TVOUT_SHOLEST
+  set_video_status(1);
+#endif
 	vout = video_drvdata(file);
 
 	if (vout == NULL) {
@@ -298,6 +386,8 @@ static int omapvout_open(struct file *file)
 
 	vout->mmap_cnt = 0;
 
+	omapvout_chk_overrides(vout);
+
 	mutex_unlock(&vout->mtx);
 
 	file->private_data = vout;
@@ -314,7 +404,9 @@ static int omapvout_release(struct file *file)
 	struct omapvout_device *vout;
 
 	DBG("omapvout_release\n");
-
+#ifdef CONFIG_TVOUT_SHOLEST
+  set_video_status(0);
+#endif
 	vout = video_drvdata(file);
 
 	if (vout == NULL) {
@@ -564,6 +656,8 @@ static int omapvout_vidioc_s_fmt_vid_overlay(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_window(vout, win);
 	if (rc != 0)
 		goto failed;
@@ -602,6 +696,8 @@ static int omapvout_vidioc_s_fmt_vid_out(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_pixel_format(vout, pix);
 	if (rc != 0)
 		goto failed;
@@ -700,6 +796,8 @@ static int omapvout_vidioc_s_crop(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_crop(vout, &rect);
 	if (rc != 0)
 		goto failed;
@@ -785,7 +883,8 @@ static int omapvout_vidioc_qbuf(struct file *file, void *priv,
 	DBG("Q'ing Frame %d\n", b->index);
 
 	mutex_lock(&vout->mtx);
-        rc = videobuf_qbuf(&vout->queue, b);
+	omapvout_chk_overrides(vout);
+	rc = videobuf_qbuf(&vout->queue, b);
 	mutex_unlock(&vout->mtx);
 
 	return rc;
@@ -821,6 +920,8 @@ static int omapvout_vidioc_streamon(struct file *file, void *priv,
 
 	mutex_lock(&vout->mtx);
 
+	omapvout_chk_overrides(vout);
+
 	/* Not sure how else to do this.  We can't truly validate the
 	 * configuration until all of the pieces have been provided, like
 	 * input, output, crop sizes and rotation.  This is the only point
@@ -909,6 +1010,10 @@ static int omapvout_vidioc_g_ctrl(struct file *file, void *priv,
 	case V4L2_CID_BG_COLOR:
 		ctrl->value = vout->bg_color;
 		break;
+	case V4L2_CID_PRIVATE_DECIMATE_BY_2:
+		ctrl->value = (int) omapvout_dss_get_decimate(vout);
+		break;
+
 	default:
 		rc = -EINVAL;
 		break;
@@ -948,6 +1053,11 @@ static int omapvout_vidioc_s_ctrl(struct file *file, void *priv,
 			DBG("Invalid rotation %d\n", v);
 			rc = -ERANGE;
 		}
+		if (rc == 0 && gOverride[vout->id].force_rotation_enable) {
+			gOverride[vout->id].client_rotation = vout->rotation;
+			vout->rotation = gOverride[vout->id].forced_rotation;
+			gOverride[vout->id].force_rotation_dirty = 0;
+		}
 		break;
 	case V4L2_CID_BG_COLOR:
 		if (v < 0 || v > 0xFFFFFF) {
@@ -957,6 +1067,10 @@ static int omapvout_vidioc_s_ctrl(struct file *file, void *priv,
 			vout->bg_color = v;
 		}
 		break;
+	case V4L2_CID_PRIVATE_DECIMATE_BY_2:
+		omapvout_dss_set_decimate(vout, ((v) ? true : false));
+		break;
+
 	default:
 		rc = -EINVAL;
 		break;
@@ -1121,6 +1235,8 @@ static int __init omapvout_probe_device(struct omap_vout_config *cfg,
 
 	vout->id = plane;
 
+	memset(gOverride, 0, sizeof(gOverride));
+
 	return 0;
 
 cleanup:
diff --git a/drivers/media/video/videobuf-core.c b/drivers/media/video/videobuf-core.c
index b7b0584..efbe9f9 100644
--- a/drivers/media/video/videobuf-core.c
+++ b/drivers/media/video/videobuf-core.c
@@ -667,6 +667,7 @@ int videobuf_dqbuf(struct videobuf_queue *q,
 		buf->state = VIDEOBUF_IDLE;
 		break;
 	case VIDEOBUF_DONE:
+	case VIDEOBUF_IDLE:
 		dprintk(1, "dqbuf: state is done\n");
 		CALL(q, sync, q, buf);
 		buf->state = VIDEOBUF_IDLE;
diff --git a/drivers/mfd/cpcap-3mm5.c b/drivers/mfd/cpcap-3mm5.c
index 6579a4d..9d53634 100644
--- a/drivers/mfd/cpcap-3mm5.c
+++ b/drivers/mfd/cpcap-3mm5.c
@@ -88,6 +88,7 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 {
 	struct cpcap_3mm5_data *data_3mm5 = data;
 	int new_state = NO_DEVICE;
+	int cpcap_status_gpio_2, cpcap_status_gpio_4;
 
 	if (irq != CPCAP_IRQ_HS)
 		return;
@@ -109,13 +110,23 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_HS);
 
 		send_key_event(data_3mm5, 0);
+		cpcap_uc_stop(data_3mm5->cpcap, CPCAP_MACRO_5);
 	} else {
+		cpcap_status_gpio_2 = cpcap_regacc_write(data_3mm5->cpcap,
+                        CPCAP_REG_GPIO2, 0,
+                        CPCAP_BIT_GPIO2DRV);
+
+                cpcap_status_gpio_4 = cpcap_regacc_write(data_3mm5->cpcap,
+                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4DRV,
+                        CPCAP_BIT_GPIO4DRV);
+		if ((cpcap_status_gpio_2 < 0) || (cpcap_status_gpio_4 < 0)) {
+                	pr_err("Cpcap TV_out: %s: "
+                                "Control Analog Switch failed: \n", __func__);
+        	}
+		
 		cpcap_regacc_write(data_3mm5->cpcap, CPCAP_REG_TXI,
 				   (CPCAP_BIT_MB_ON2 | CPCAP_BIT_PTT_CMP_EN),
 				   (CPCAP_BIT_MB_ON2 | CPCAP_BIT_PTT_CMP_EN));
-		cpcap_regacc_write(data_3mm5->cpcap, CPCAP_REG_RXOA,
-				   CPCAP_BIT_ST_HS_CP_EN,
-				   CPCAP_BIT_ST_HS_CP_EN);
 		audio_low_power_clear(data_3mm5);
 
 		/* Give PTTS time to settle */
@@ -134,6 +145,9 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_HS);
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_MB2);
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_UC_PRIMACRO_5);
+
+		cpcap_uc_start(data_3mm5->cpcap, CPCAP_MACRO_5);
+                cpcap_uc_start(data_3mm5->cpcap, CPCAP_MACRO_4);
 	}
 
 	switch_set_state(&data_3mm5->sdev, new_state);
@@ -175,6 +189,51 @@ static void key_handler(enum cpcap_irqs irq, void *data)
 	cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_UC_PRIMACRO_5);
 }
 
+static int init_analog_switch(struct cpcap_3mm5_data *data)
+{
+        int cpcap_status = 0;
+        struct cpcap_3mm5_data *data_3mm5 = data;
+
+        /* set vlev = 2.775V for GPIO 2 */
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO2, CPCAP_BIT_GPIO2VLEV,
+                                        CPCAP_BIT_GPIO2VLEV);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO2 VLEV failed: \n", __func__);
+                return cpcap_status;
+        }
+
+        /* set vlev = 2.775V for GPIO 4 */
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4VLEV,
+                                        CPCAP_BIT_GPIO4VLEV);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO4 VLEV failed: \n", __func__);
+                return cpcap_status;
+        }
+
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO2, CPCAP_BIT_GPIO2DIR,
+                                        CPCAP_BIT_GPIO2DIR);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO2 failed: \n", __func__);
+                return cpcap_status;
+        }
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4DIR,
+                                        CPCAP_BIT_GPIO4DIR);
+
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO4 failed: \n", __func__);
+                return cpcap_status;
+        }
+        return 0;
+}
+
 static int __init cpcap_3mm5_probe(struct platform_device *pdev)
 {
 	int retval = 0;
@@ -195,7 +254,10 @@ static int __init cpcap_3mm5_probe(struct platform_device *pdev)
 	data->sdev.print_name = print_name;
 	switch_dev_register(&data->sdev);
 	platform_set_drvdata(pdev, data);
-
+	retval = init_analog_switch(data);
+        if (retval < 0)
+              return retval;
+	
 	data->regulator = regulator_get(NULL, "vaudio");
 	if (IS_ERR(data->regulator)) {
 		dev_err(&pdev->dev, "Could not get regulator for cpcap_3mm5\n");
diff --git a/drivers/mfd/cpcap-core.c b/drivers/mfd/cpcap-core.c
index c239e87..417cf85 100644
--- a/drivers/mfd/cpcap-core.c
+++ b/drivers/mfd/cpcap-core.c
@@ -147,8 +147,17 @@ static struct platform_device cpcap_rtc_device = {
 	.dev.platform_data = NULL,
 };
 
+#ifdef CONFIG_LEDS_AF_LED
+struct platform_device cpcap_af_led = {
+	.name		= LD_AF_LED_DEV,
+	.id		= -1,
+	.dev		= {
+		.platform_data  = NULL,
+	},
+};
+#endif
+
 static struct platform_device *cpcap_devices[] = {
-	&cpcap_uc_device,
 	&cpcap_adc_device,
 	&cpcap_key_device,
 	&cpcap_batt_device,
@@ -165,6 +174,10 @@ static struct platform_device *cpcap_devices[] = {
 #endif
 	&cpcap_3mm5_device,
 	&cpcap_rtc_device,
+	&cpcap_uc_device,
+#ifdef CONFIG_LEDS_AF_LED
+	&cpcap_af_led,
+#endif
 };
 
 static struct cpcap_device *misc_cpcap;
@@ -490,6 +503,18 @@ static int adc_ioctl(unsigned int cmd, unsigned long arg)
 	return retval;
 }
 
+#if defined(CONFIG_LEDS_FLASH_RESET)
+int cpcap_direct_misc_write(unsigned short reg, unsigned short value,\
+						unsigned short mask)
+{
+	int retval = -EINVAL;
+
+	retval = cpcap_regacc_write(misc_cpcap, reg, value, mask);
+
+	return retval;
+}
+#endif
+
 static int ioctl(struct inode *inode,
 		 struct file *file, unsigned int cmd, unsigned long arg)
 {
diff --git a/drivers/mfd/cpcap-regacc.c b/drivers/mfd/cpcap-regacc.c
index 2b8de54..d06cfb3 100644
--- a/drivers/mfd/cpcap-regacc.c
+++ b/drivers/mfd/cpcap-regacc.c
@@ -244,6 +244,11 @@ static const struct {
 	[CPCAP_REG_LMACE]     = {1183, 0xFFF8, 0xFFFF},
 };
 
+#ifdef CPCAP_AUDIO_REG_DEBUG
+static unsigned short
+CPCAP_AUD_CACHE[CPCAP_REG_LVAB-CPCAP_REG_VAUDIOC+1] = { 0 };
+#endif
+
 static int cpcap_spi_access(struct spi_device *spi, u8 *buf,
 			    size_t len)
 {
@@ -348,6 +353,13 @@ int cpcap_regacc_write(struct cpcap_device *cpcap,
 		old_value &= register_info_tbl[reg].rbw_mask;
 		old_value &= ~mask;
 		value |= old_value;
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+		if (reg >= CPCAP_REG_VAUDIOC && reg <= CPCAP_REG_LVAB)
+			CPCAP_AUD_CACHE[reg - CPCAP_REG_VAUDIOC] =
+					value & register_info_tbl[reg].rbw_mask;
+#endif
+
 		retval = cpcap_config_for_write(spi,
 						register_info_tbl[reg].address,
 						value);
@@ -381,3 +393,21 @@ int cpcap_regacc_init(struct cpcap_device *cpcap)
 
 	return retval;
 }
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+void cpcap_regacc_audio_reg_dump(void)
+{
+  printk(KERN_INFO
+	"CPCAP_aud:V:%04X C:%04X,%04X S:%04X,%04X In:%04X,%04X Out:%04X,%04X ",
+	CPCAP_AUD_CACHE[0], CPCAP_AUD_CACHE[1], CPCAP_AUD_CACHE[2],
+	CPCAP_AUD_CACHE[3], CPCAP_AUD_CACHE[4], CPCAP_AUD_CACHE[5],
+	CPCAP_AUD_CACHE[6], CPCAP_AUD_CACHE[7], CPCAP_AUD_CACHE[8]
+	);
+  printk(KERN_INFO
+	"Sw:%04X,%04X,%04X  %04X %04X %04X %04X %04X %04X\n",
+	CPCAP_AUD_CACHE[9], CPCAP_AUD_CACHE[10], CPCAP_AUD_CACHE[11],
+	CPCAP_AUD_CACHE[12], CPCAP_AUD_CACHE[13], CPCAP_AUD_CACHE[14],
+	CPCAP_AUD_CACHE[15], CPCAP_AUD_CACHE[16], CPCAP_AUD_CACHE[17]
+	);
+}
+#endif
diff --git a/drivers/misc/akm8973_akmd.c b/drivers/misc/akm8973_akmd.c
index b47cd19..0806cba 100755
--- a/drivers/misc/akm8973_akmd.c
+++ b/drivers/misc/akm8973_akmd.c
@@ -284,8 +284,8 @@ static void AKECS_Report_Value(short *rbuf)
 		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
 
 	if (atomic_read(&mv_flag)) {
-		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
-		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_HAT0X, 0 - rbuf[10]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[9]);
 		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
 	}
 
diff --git a/drivers/misc/lis331dlh.c b/drivers/misc/lis331dlh.c
index bab1fd9..a9b7e6e 100644
--- a/drivers/misc/lis331dlh.c
+++ b/drivers/misc/lis331dlh.c
@@ -202,7 +202,8 @@ static int lis331dlh_hw_init(struct lis331dlh_data *lis)
 static void lis331dlh_device_power_off(struct lis331dlh_data *lis)
 {
 	int err;
-	u8 buf[2] = { CTRL_REG4, PM_OFF };
+/*	u8 buf[2] = { CTRL_REG4, PM_OFF }; */
+	u8 buf[2] = { CTRL_REG1, PM_OFF };
 
 	err = lis331dlh_i2c_write(lis, buf, 1);
 	if (err < 0)
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
index 610dbd1..fcd1a80 100644
--- a/drivers/mmc/core/debugfs.c
+++ b/drivers/mmc/core/debugfs.c
@@ -289,4 +289,5 @@ err:
 void mmc_remove_card_debugfs(struct mmc_card *card)
 {
 	debugfs_remove_recursive(card->debugfs_root);
+	card->debugfs_root = NULL;
 }
diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c
old mode 100755
new mode 100644
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
index 0200f47..b9e1d93 100644
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -373,6 +373,7 @@ int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 				elapsed_realtime_alarm_time, rtc_delta).tv_sec;
 		rtc_time_to_tm(rtc_alarm_time, &rtc_alarm.time);
 		rtc_alarm.enabled = 1;
+		rtc_alarm_irq_enable(alarm_rtc_dev, 1);
 		rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
 		rtc_read_time(alarm_rtc_dev, &rtc_current_rtc_time);
 		rtc_tm_to_time(&rtc_current_rtc_time, &rtc_current_time);
@@ -383,6 +384,7 @@ int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 		if (rtc_current_time + 1 >= rtc_alarm_time) {
 			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
 					      "alarm about to go off\n");
+			memset(&rtc_alarm, 0, sizeof(rtc_alarm));
 			rtc_alarm.enabled = 0;
 			rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
 
@@ -403,13 +405,14 @@ err1:
 
 int alarm_resume(struct platform_device *pdev)
 {
-	struct rtc_wkalrm rtc_alarm;
+	struct rtc_wkalrm alarm;
 	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
 			      "alarm_resume(%p)\n", pdev);
 	if (alarm_enabled & ANDROID_ALARM_WAKEUP_MASK) {
-		rtc_read_alarm(alarm_rtc_dev, &rtc_alarm);
-		rtc_alarm.enabled = 0;
-		rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
+		memset(&alarm, 0, sizeof(alarm));
+		alarm.enabled = 0;
+		rtc_alarm_irq_enable(alarm_rtc_dev, 0);
+		rtc_set_alarm(alarm_rtc_dev, &alarm);
 		alarm_start_hrtimer(ANDROID_ALARM_RTC_WAKEUP);
 		alarm_start_hrtimer(ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP);
 	}
diff --git a/drivers/sim/sim_core.c b/drivers/sim/sim_core.c
index 75634d8..38dcac9 100644
--- a/drivers/sim/sim_core.c
+++ b/drivers/sim/sim_core.c
@@ -2103,7 +2103,7 @@ int sim_slim_status_handler()
 			sw1 = sim_module_card_data[0].buffer[bytes_recieved - 2];
 			sw2 = sim_module_card_data[0].buffer[bytes_recieved - 1];
 
-			if((((sw1 == 0x90) || (card_type == GSM_SIM && sw1==0x67)) && (sw2 == 0x00))||(sw1 == 0x91)){
+			if((((sw1 == 0x90) || (card_type == GSM_SIM && sw1==0x67)) && (sw2 == 0x00)) || (sw1 == 0x91)){
 				sim_low_power_enabled = TRUE;
       
 				/* Allow DMA to ACK idle requests */
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 643908b..d807583 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -25,6 +25,9 @@
 #include <linux/mutex.h>
 #include <linux/spi/spi.h>
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+static struct spi_device *spi_device_smsmdtv;
+#endif
 
 /* SPI bustype and spi_master class are registered after board init code
  * provides the SPI device tables, ensuring that both are present by the
@@ -381,6 +384,9 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 static void scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+	struct spi_device *spi;
+#endif
 
 	mutex_lock(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
@@ -393,7 +399,19 @@ static void scan_boardinfo(struct spi_master *master)
 			/* NOTE: this relies on spi_new_device to
 			 * issue diagnostics when given bogus inputs
 			 */
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+		spi = spi_new_device(master, chip);
+/* note: this macro is remove from include/linux/kobject.h */
+#define KOBJ_NAME_LEN 20
+
+	if (strncmp(chip->modalias, "smsspi", KOBJ_NAME_LEN) == 0) {
+		spi_device_smsmdtv = spi;
+
+		printk(KERN_INFO "smsspi device is added.\n");
+	}
+#else
 			(void) spi_new_device(master, chip);
+#endif
 		}
 	}
 	mutex_unlock(&board_lock);
@@ -699,6 +717,19 @@ int spi_write_then_read(struct spi_device *spi,
 }
 EXPORT_SYMBOL_GPL(spi_write_then_read);
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+struct spi_device *spi_get_spi_device(char *modalias)
+{
+#define KOBJ_NAME_LEN   20
+
+	if (strncmp(modalias, "smsspi", KOBJ_NAME_LEN) == 0)
+		return spi_device_smsmdtv;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_get_spi_device);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static int __init spi_init(void)
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 01c13a0..a7f4b42 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -1282,7 +1282,7 @@ static int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 #ifdef CONFIG_USB_MOT_ANDROID
 	u8 *vend_str = "Motorola";
-	u8 *prod_str = "A853";
+	u8 *prod_str = "XT701";
 
 	fsg->vendor = vend_str;
 	fsg->product = prod_str;
diff --git a/drivers/usb/gadget/mot_android.c b/drivers/usb/gadget/mot_android.c
index 8214441..0a07e1f 100644
--- a/drivers/usb/gadget/mot_android.c
+++ b/drivers/usb/gadget/mot_android.c
@@ -107,14 +107,16 @@ static struct device_pid_vid mot_android_vid_pid[MAX_DEVICE_TYPE_NUM] = {
 	 USB_CLASS_COMM, USB_CLASS_COMM, USB_CLASS_PER_INTERFACE},
 	{"eth_adb", ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8, 0x41d4,
 	 "Motorola Android Composite Device"},
-	{"acm_eth_mtp", ACM_TYPE_FLAG | ETH_TYPE_FLAG | MTP_TYPE_FLAG, 0x22b8,
+	/* remove MTP_TYPE_FLAG here to disable mtp function driver */
+	{"acm_eth_mtp", ACM_TYPE_FLAG | ETH_TYPE_FLAG, 0x22b8,
 	 0x41d8, "Motorola Config 30", USB_CLASS_VENDOR_SPEC,
 	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
 	{"mtp_adb", MTP_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8, 0x41dc,
 	 "Motorola Config 32", USB_CLASS_VENDOR_SPEC,
 	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
 	{"acm_eth_mtp_adb",
-	 ACM_TYPE_FLAG | ETH_TYPE_FLAG | MTP_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
+	/* remove MTP_TYPE_FLAG here to disable mtp function driver */
+	 ACM_TYPE_FLAG | ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
 	 0x41da, "Motorola Config 31", USB_CLASS_VENDOR_SPEC,
 	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
 	{"acm_eth_adb", ACM_TYPE_FLAG | ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
@@ -489,7 +491,16 @@ static void force_reenumeration(struct android_dev *dev, int dev_type)
 
 	temp_enabled = dev_type & ADB_TYPE_FLAG;
 	f = adb_function_enable_id(temp_enabled,
-				   android_config_driver.next_interface_id);
+	/*			   android_config_driver.next_interface_id);*/
+	/*
+	 * For acm_eth_mtp and acm_eth_mtp_adb modes, mtp is disabled.
+	 * The interface number have to be increased one to match PC driver.
+	 */
+				((dev_type & ACM_TYPE_FLAG) &&
+					(dev_type & ETH_TYPE_FLAG)) ?
+				(android_config_driver.next_interface_id + 1) :
+				android_config_driver.next_interface_id);
+
 	if (temp_enabled) {
 		android_config_driver.interface[android_config_driver.
 						next_interface_id] = f;
diff --git a/drivers/video/omap2/displays/Kconfig b/drivers/video/omap2/displays/Kconfig
index 55d85c1..7ec9e4d 100644
--- a/drivers/video/omap2/displays/Kconfig
+++ b/drivers/video/omap2/displays/Kconfig
@@ -51,4 +51,10 @@ config PANEL_SHOLES
         help
 	  LCD Panel used in sholes
 
+# charlotte adding to support HDMI 
+config PANEL_HDTV
+        tristate "HDTV Panel"
+        help
+	  HDTV Panel
+
 endmenu
diff --git a/drivers/video/omap2/displays/Makefile b/drivers/video/omap2/displays/Makefile
index 81ec8b8..5acdc4d 100644
--- a/drivers/video/omap2/displays/Makefile
+++ b/drivers/video/omap2/displays/Makefile
@@ -7,4 +7,6 @@ obj-$(CONFIG_PANEL_N800) += panel-n800.o
 
 obj-$(CONFIG_PANEL_ACX565AKM) += panel-acx565akm.o
 obj-$(CONFIG_PANEL_SHOLES) += panel-sholes.o
+# charlotte adding to support HDMI
+obj-$(CONFIG_PANEL_HDTV) += panel-hdtv.o
 obj-$(CONFIG_PANEL_ZOOM2) += panel-zoom2.o
diff --git a/drivers/video/omap2/displays/panel-sholes.c b/drivers/video/omap2/displays/panel-sholes.c
index ed08420..0275109 100644
--- a/drivers/video/omap2/displays/panel-sholes.c
+++ b/drivers/video/omap2/displays/panel-sholes.c
@@ -10,7 +10,6 @@
 #include <mach/dma.h>
 #include <asm/atomic.h>
 
-#define DEBUG
 #ifdef DEBUG
 #define DBG(format, ...) (printk(KERN_DEBUG "sholes-panel: " format, ## __VA_ARGS__))
 #else
@@ -25,7 +24,9 @@
 #define EDISCO_CMD_SET_COLUMN_ADDRESS	0x2A
 #define EDISCO_CMD_SET_PAGE_ADDRESS	0x2B
 #define EDISCO_CMD_SET_TEAR_ON		0x35
+#define EDISCO_CMD_SET_TEAR_OFF		0x34
 #define EDISCO_CMD_SET_TEAR_SCANLINE	0x44
+#define EDISCO_CMD_READ_DDB_START	0xA1
 
 #define EDISCO_CMD_VC   0
 #define EDISCO_VIDEO_VC 1
@@ -33,7 +34,9 @@
 #define EDISCO_LONG_WRITE	0x29
 #define EDISCO_SHORT_WRITE_1	0x23
 #define EDISCO_SHORT_WRITE_0	0x13
-
+#define SUPPLIER_ID_AUO 0x0186
+#define SUPPLIER_ID_TMD 0x0126
+#define SUPPLIER_ID_INVALID 0xFFFF
 #define PANEL_OFF	0x0
 #define PANEL_ON	0x1
 
@@ -72,11 +75,37 @@ static void sholes_panel_remove(struct omap_dss_device *dssdev)
 {
 	return;
 }
+static u16 sholes_panel_read_supplier_id(struct omap_dss_device *dssdev)
+{
+	static u16 id = SUPPLIER_ID_INVALID;
+	u8 data[2];
+
+	if (id == SUPPLIER_ID_AUO || id == SUPPLIER_ID_TMD)
+		goto end;
+
+	if (dsi_vc_set_max_rx_packet_size(EDISCO_CMD_VC, 2))
+		goto end;
+
+	if (dsi_vc_dcs_read(EDISCO_CMD_VC, EDISCO_CMD_READ_DDB_START, data, 2) != 2)
+		goto end;
+		
+	if (dsi_vc_set_max_rx_packet_size(EDISCO_CMD_VC, 1))
+		goto end;
+
+	id = (data[0] << 8) | data[1];
+	
+	if (id != SUPPLIER_ID_AUO && id != SUPPLIER_ID_TMD)
+		id = SUPPLIER_ID_INVALID;
+end:
+	return id;
+}
 
 static int sholes_panel_enable(struct omap_dss_device *dssdev)
 {
 	u8 data[7];
-	int ret;
+	u16 id = SUPPLIER_ID_INVALID;
+	
+	int ret = 0;
 
 	DBG("enable\n");
 	if (dssdev->platform_enable) {
@@ -85,65 +114,130 @@ static int sholes_panel_enable(struct omap_dss_device *dssdev)
 			return ret;
 	}
 
-	/* turn of mcs register acces protection */
-	data[0] = 0xb2;
-	data[1] = 0x00;
-	ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
-
-	/* enable lane setting and test registers*/
-	data[0] = 0xef;
-	data[1] = 0x01;
-	data[2] = 0x01;
-	ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
-
-	/* 2nd param 61 = 1 line; 63 = 2 lanes */
-	data[0] = 0xef;
-	data[1] = 0x60;
-	data[2] = 0x63;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 3);
+	id = sholes_panel_read_supplier_id(dssdev);
+
+	if (id == SUPPLIER_ID_AUO) {
+		/* turn of mcs register acces protection */
+		data[0] = 0xb2;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* enable lane setting and test registers*/
+		data[0] = 0xef;
+		data[1] = 0x01;
+		data[2] = 0x01;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* 2nd param 61 = 1 line; 63 = 2 lanes */
+		data[0] = 0xef;
+		data[1] = 0x60;
+		data[2] = 0x63;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* Set dynamic backlight control PWM; D[7:4] = PWM_DIV[3:0];*/
+		/* D[3]=0 (PWM OFF);
+		 * D[2]=0 (auto BL control OFF);
+		 * D[1]=0 (Grama correction On);
+		 * D[0]=0 (Enhanced Image Correction OFF) */
+		data[0] = 0xb4;
+		data[1] = (id == SUPPLIER_ID_AUO ? 0x0F : 0x1F);
+		data[2] = 0x03;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* set page, column address */
+		data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
+		data[5] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 6);
+
+		data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
+		data[5] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 6);
+
+		/* turn it on */
+		data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 4);
 
-	/* 2nd param 0 = WVGA; 1 = WQVGA */
-	data[0] = 0xb3;
-	data[1] = 0x00;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
+	}
+	else if (id == SUPPLIER_ID_TMD) {
+
+		/* turn of mcs register acces protection */
+		data[0] = 0xb2;
+		data[1] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
+		
+		/* enable lane setting and test registers*/
+		data[0] = 0xef;
+		data[1] = 0x01;
+		data[2] = 0x01;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
+
+		/* 2nd param 61 = 1 line; 63 = 2 lanes */
+		data[0] = 0xef;
+		data[1] = 0x60;
+		data[2] = 0x63;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
+
+		/* Set dynamic backlight control PWM; D[7:4] = PWM_DIV[3:0];*/
+		/* D[3]=0 (PWM OFF);
+		 * D[2]=0 (auto BL control OFF);
+		 * D[1]=0 (Grama correction On);
+		 * D[0]=0 (Enhanced Image Correction OFF) */
+		data[0] = 0xb4;
+		data[1] = (id == SUPPLIER_ID_AUO ? 0x0F : 0x1F);
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
+
+		/* set page, column address */
+		data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
+
+		data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
+
+		/* turn it on */
+		data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
 
-	/* Set dynamic backlight control and PWM; D[7:4] = PWM_DIV[3:0];*/
-	/* D[3]=0 (PWM OFF);
-	 * D[2]=0 (auto BL control OFF);
-	 * D[1]=0 (Grama correction On);
-	 * D[0]=0 (Enhanced Image Correction OFF) */
-	data[0] = 0xb4;
-	data[1] = 0x1f;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
+	}
+	else {
 
-	/* set page, column address */
-	data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
-	data[1] = 0x00;
-	data[2] = 0x00;
-	data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
-	data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
-	if (ret)
+		DBG("Panel not installed\n");
 		goto error;
+	}
 
-	data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
-	data[1] = 0x00;
-	data[2] = 0x00;
-	data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
-	data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
-	if (ret)
-		goto error;
+	mdelay(200);
 
-	/* turn it on */
-	data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
-	//ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_0, data, 1);
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
+	DBG("supplier id: 0x%04x\n", (unsigned int)id);
 
-	mdelay(200);
+	if (ret)
+		goto error;
 
 	return 0;
 error:
+	atomic_set(&state, PANEL_OFF);
 	return -EINVAL;
 }
 
@@ -211,6 +305,7 @@ static int sholes_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
 	u8 data[3];
 	int ret;
 
+	if (enable) {
 	data[0] = EDISCO_CMD_SET_TEAR_ON;
 	data[1] = 0x00;
 	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
@@ -223,6 +318,12 @@ static int sholes_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
 	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 3);
 	if (ret)
 		goto error;
+	} else {
+		data[0] = EDISCO_CMD_SET_TEAR_OFF;
+		ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
+		if (ret)
+			goto error;
+	}
 
 	DBG("edisco_ctrl_enable_te \n");
 	return 0;
diff --git a/drivers/video/omap2/dss/display.c b/drivers/video/omap2/dss/display.c
index fac6515..cd68868 100644
--- a/drivers/video/omap2/dss/display.c
+++ b/drivers/video/omap2/dss/display.c
@@ -277,16 +277,26 @@ static ssize_t display_wss_store(struct device *dev,
 	return size;
 }
 
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static DEVICE_ATTR(enabled, S_IRWXUGO|S_IWUSR,
+		display_enabled_show, display_enabled_store);
+#else
 static DEVICE_ATTR(enabled, S_IRUGO|S_IWUSR,
 		display_enabled_show, display_enabled_store);
+#endif
 static DEVICE_ATTR(update_mode, S_IRUGO|S_IWUSR,
 		display_upd_mode_show, display_upd_mode_store);
 static DEVICE_ATTR(tear_elim, S_IRUGO|S_IWUSR,
 		display_tear_show, display_tear_store);
 static DEVICE_ATTR(timings, S_IRUGO|S_IWUSR,
 		display_timings_show, display_timings_store);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static DEVICE_ATTR(rotate, S_IRWXUGO|S_IWUSR,
+		display_rotate_show, display_rotate_store);
+#else
 static DEVICE_ATTR(rotate, S_IRUGO|S_IWUSR,
 		display_rotate_show, display_rotate_store);
+#endif
 static DEVICE_ATTR(mirror, S_IRUGO|S_IWUSR,
 		display_mirror_show, display_mirror_store);
 static DEVICE_ATTR(wss, S_IRUGO|S_IWUSR,
diff --git a/drivers/video/omap2/dss/dsi.c b/drivers/video/omap2/dss/dsi.c
index c197129..eb4fc33 100644
--- a/drivers/video/omap2/dss/dsi.c
+++ b/drivers/video/omap2/dss/dsi.c
@@ -32,6 +32,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/kthread.h>
 #include <linux/wait.h>
+#include <linux/delay.h>
 
 #include <mach/board.h>
 #include <mach/display.h>
@@ -228,6 +229,8 @@ static struct
 	unsigned pll_locked;
 
 	struct completion bta_completion;
+	struct completion packet_sent_completion;
+	struct completion te_trigger_completion;
 
 	struct task_struct *thread;
 	wait_queue_head_t waitqueue;
@@ -552,6 +555,9 @@ void dsi_irq_handler(void)
 		print_irq_status(irqstatus);
 	}
 
+	if (irqstatus & DSI_IRQ_TE_TRIGGER)
+		complete(&dsi.te_trigger_completion);
+
 	for (i = 0; i < 4; ++i) {
 		if ((irqstatus & (1<<i)) == 0)
 			continue;
@@ -560,7 +566,8 @@ void dsi_irq_handler(void)
 
 		if (vcstatus & DSI_VC_IRQ_BTA)
 			complete(&dsi.bta_completion);
-
+		if (vcstatus & DSI_VC_IRQ_PACKET_SENT)
+			complete(&dsi.packet_sent_completion);
 		if (vcstatus & DSI_VC_IRQ_ERROR_MASK) {
 			DSSERR("DSI VC(%d) error, vc irqstatus %x\n",
 				       i, vcstatus);
@@ -637,6 +644,24 @@ static u32 dsi_get_errors(void)
 	return e;
 }
 
+static void dsi_enable_te_irq(void)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_IRQENABLE);
+	l |= DSI_IRQ_TE_TRIGGER;
+	dsi_write_reg(DSI_IRQENABLE, l);
+}
+
+static void dsi_disable_te_irq(int channel)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_IRQENABLE);
+	l &= ~DSI_IRQ_TE_TRIGGER;
+	dsi_write_reg(DSI_IRQENABLE, l);
+}
+
 static void dsi_vc_enable_bta_irq(int channel)
 {
 	u32 l;
@@ -654,7 +679,23 @@ static void dsi_vc_disable_bta_irq(int channel)
 	l &= ~DSI_VC_IRQ_BTA;
 	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
 }
+static void dsi_vc_enable_packet_sent_irq(int channel)
+{
+	u32 l;
 
+	l = dsi_read_reg(DSI_VC_IRQENABLE(channel));
+	l |= DSI_VC_IRQ_PACKET_SENT;
+	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
+}
+
+static void dsi_vc_disable_packet_sent_irq(int channel)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_VC_IRQENABLE(channel));
+	l &= ~DSI_VC_IRQ_PACKET_SENT;
+	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
+}
 /* DSI func clock. this could also be DSI2_PLL_FCLK */
 static inline void enable_clocks(bool enable)
 {
@@ -767,6 +808,8 @@ static int dsi_set_lp_clk_divisor(struct omap_dss_device *dssdev)
 	if (dsi_fclk > 30*1000*1000)
 		REG_FLD_MOD(DSI_CLK_CTRL, 1, 21, 21); /* LP_RX_SYNCHRO_ENABLE */
 
+	REG_FLD_MOD(DSI_CLK_CTRL, 0, 13, 13);	/* NON CONTINUOUS CLK MODE */
+
 	return 0;
 }
 
@@ -1431,13 +1474,13 @@ static void dsi_complexio_timings(void)
 
 	/* calculate timings */
 
-	/* 1 * DDR_CLK = 2 * UI */
+	/* DDR_CLK = 1 / (2 * UI) */
 
 	/* min 40ns + 4*UI	max 85ns + 6*UI */
 	ths_prepare = ns2ddr(70) + 2;
 
-	/* min 145ns + 10*UI */
-	ths_prepare_ths_zero = ns2ddr(175) + 2;
+	/* min 145ns + 10*UI for TMD, min 480ns for AUO */
+	ths_prepare_ths_zero = ns2ddr(175 + 425) + 2;
 
 	/* min max(8*UI, 60ns+4*UI) */
 	ths_trail = ns2ddr(60) + 5;
@@ -1446,7 +1489,10 @@ static void dsi_complexio_timings(void)
 	ths_exit = ns2ddr(145);
 
 	/* tlpx min 50n */
+	/* AUO experiment it's less than 50ns 
 	tlpx_half = ns2ddr(25);
+	*/
+	tlpx_half = ns2ddr(30);
 
 	/* min 60ns */
 	tclk_trail = ns2ddr(60) + 2;
@@ -1846,6 +1892,8 @@ static int dsi_vc_send_bta(int channel)
 		dsi_vc_flush_receive_data(channel);
 	}
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
 	REG_FLD_MOD(DSI_VC_CTRL(channel), 1, 6, 6); /* BTA_EN */
 
 	tmo = jiffies + msecs_to_jiffies(10);
@@ -1911,6 +1959,8 @@ static inline void dsi_vc_write_long_header(int channel, u8 data_type,
 	val = FLD_VAL(data_id, 7, 0) | FLD_VAL(len, 23, 8) |
 		FLD_VAL(ecc, 31, 24);
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
 	dsi_write_reg(DSI_VC_LONG_PACKET_HEADER(channel), val);
 }
 
@@ -1947,7 +1997,8 @@ static int dsi_vc_send_long(int channel, u8 data_type, u8 *data, u16 len,
 
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
-
+	INIT_COMPLETION(dsi.packet_sent_completion);
+	dsi_vc_enable_packet_sent_irq(channel);
 	dsi_vc_write_long_header(channel, data_type, len, ecc);
 
 	/*dsi_vc_print_status(0); */
@@ -1991,6 +2042,12 @@ static int dsi_vc_send_long(int channel, u8 data_type, u8 *data, u16 len,
 		dsi_vc_write_long_payload(channel, b1, b2, b3, 0);
 	}
 
+	if (wait_for_completion_timeout(&dsi.packet_sent_completion, msecs_to_jiffies(10)) == 0) {
+		DSSERR("Failed to send long packet\n");
+	}
+
+	dsi_vc_disable_packet_sent_irq(channel);
+
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
 
@@ -2008,6 +2065,7 @@ static int dsi_vc_send_short(int channel, u8 data_type, u16 data, u8 ecc)
 		DSSDBG("dsi_vc_send_short(ch%d, dt %#x, b1 %#x, b2 %#x)\n",
 				channel,
 				data_type, data & 0xff, (data >> 8) & 0xff);
+
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
 
@@ -2020,7 +2078,16 @@ static int dsi_vc_send_short(int channel, u8 data_type, u16 data, u8 ecc)
 
 	r = (data_id << 0) | (data << 8) | (ecc << 24);
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
+	INIT_COMPLETION(dsi.packet_sent_completion);
+	dsi_vc_enable_packet_sent_irq(channel);
 	dsi_write_reg(DSI_VC_SHORT_PACKET_HEADER(channel), r);
+	if (wait_for_completion_timeout(&dsi.packet_sent_completion, msecs_to_jiffies(10)) == 0) {
+		DSSERR("Failed to send short packet\n");
+	}
+
+	dsi_vc_disable_packet_sent_irq(channel);
 
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
@@ -2059,6 +2126,7 @@ int dsi_vc_write(int channel, u8 data_type, u8 *data, int len)
 	r = dsi_vc_write_nosync(channel, data_type, data, len);
 	if (r)
 		return r;
+
 	r = dsi_vc_send_bta_sync(channel);
 
 	return r;
@@ -2091,6 +2159,7 @@ int dsi_vc_dcs_write(int channel, u8 *data, int len)
 	if (r)
 		return r;
 
+
 	/* Some devices need time to process the msg in low power mode.
 	   This also makes the write synchronous, and checks that
 	   the peripheral is still alive */
@@ -2192,7 +2261,6 @@ int dsi_vc_dcs_read(int channel, u8 dcs_cmd, u8 *buf, int buflen)
 }
 EXPORT_SYMBOL(dsi_vc_dcs_read);
 
-
 int dsi_vc_set_max_rx_packet_size(int channel, u16 len)
 {
 	return dsi_vc_send_short(channel, DSI_DT_SET_MAX_RET_PKG_SIZE,
@@ -2483,6 +2551,22 @@ static void dsi_proto_timings(struct omap_dss_device *dssdev)
 			DSI_FLUSH(ch); \
 	} while (0)
 
+static int dsi_core_init(void)
+{
+	/* Autoidle */
+	REG_FLD_MOD(DSI_SYSCONFIG, 1, 0, 0);
+
+	/* ENWAKEUP */
+	REG_FLD_MOD(DSI_SYSCONFIG, 1, 2, 2);
+
+	/* SIDLEMODE smart-idle */
+	REG_FLD_MOD(DSI_SYSCONFIG, 2, 4, 3);
+
+	_dsi_initialize_irq();
+
+	return 0;
+}
+
 static int dsi_update_screen_l4(struct omap_dss_device *dssdev,
 			int x, int y, int w, int h)
 {
@@ -2664,8 +2748,21 @@ static void dsi_update_screen_dispc(struct omap_dss_device *dssdev,
 
 	dss_start_update(dssdev);
 
-	if (use_te_trigger)
+	if (use_te_trigger) {
+		dssdev->driver->enable_te(dssdev, 1);
+
+		INIT_COMPLETION(dsi.te_trigger_completion);
+		dsi_enable_te_irq();
+
 		dsi_vc_send_bta(1);
+
+		if (wait_for_completion_timeout(&dsi.te_trigger_completion,
+			msecs_to_jiffies(25)) == 0) {
+			dssdev->driver->enable_te(dssdev, 1);
+			dsi_vc_send_bta(1);
+			/* DSSERR("Retry sending TE trigger request\n"); */
+		}
+	}
 }
 
 static void dsi_framedone_irq_callback(void *data, u32 mask)
@@ -2975,9 +3072,15 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 {
 	struct dsi_clock_info cinfo;
 	int r;
+	int cnt = 0;
 
 	_dsi_print_reset_status();
 
+	/* disable interface first */
+	dsi_vc_enable(0, 0);
+	dsi_vc_enable(1, 0);
+	dsi_if_enable(0);
+
 #if CONFIG_OMAP2_DSS_USE_DSI_PLL
 	r = dsi_pll_init(1, 1);
 #else
@@ -3005,8 +3108,7 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 	dsi_proto_timings(dssdev);
 	dsi_set_lp_clk_divisor(dssdev);
 
-	if (1)
-		_dsi_print_reset_status();
+	_dsi_print_reset_status();
 
 	r = dsi_proto_config(dssdev);
 	if (r)
@@ -3019,9 +3121,57 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 	dsi_force_tx_stop_mode_io();
 
 	if (dssdev->driver->enable) {
-		r = dssdev->driver->enable(dssdev);
-		if (r)
+		while (1) {
+			r = dssdev->driver->enable(dssdev);
+			if((r == 0) || (cnt++ >= 2))
+				break;
+
+			DSSERR("Failed Init, 1. SW Rst DSI-block\n");
+
+			_dsi_reset();
+
+			dsi_core_init();
+
+#if CONFIG_OMAP2_DSS_USE_DSI_PLL
+			r = dsi_pll_init(1, 1);
+#else
+			r = dsi_pll_init(1, 0);
+#endif
+			if (r)
+				goto err0;
+
+			r = dsi_pll_calc_ddrfreq(dssdev, dssdev->phy.dsi.ddr_clk_hz, &cinfo);
+			if (r)
+				goto err1;
+
+			r = dsi_pll_program(&cinfo);
+			if (r)
+				goto err1;
+
+			r = dsi_complexio_init(dssdev);
+			if (r)
+				goto err1;
+
+			dsi_proto_timings(dssdev);
+			dsi_set_lp_clk_divisor(dssdev);
+
+			r = dsi_proto_config(dssdev);
+			if (r)
+				goto err2;
+
+			/* enable interface */
+			dsi_vc_enable(0, 1);
+			dsi_vc_enable(1, 1);
+			dsi_if_enable(1);
+			dsi_force_tx_stop_mode_io();
+
+			DSSERR("Failed Init, 2. Hard Rst Panel\n");
+
+		}
+		
+		if (cnt > 2)
 			goto err3;
+
 	}
 
 	/* enable high-speed after initial config */
@@ -3047,22 +3197,6 @@ static void dsi_display_uninit_dsi(struct omap_dss_device *dssdev)
 	dsi_pll_uninit();
 }
 
-static int dsi_core_init(void)
-{
-	/* Autoidle */
-	REG_FLD_MOD(DSI_SYSCONFIG, 1, 0, 0);
-
-	/* ENWAKEUP */
-	REG_FLD_MOD(DSI_SYSCONFIG, 1, 2, 2);
-
-	/* SIDLEMODE smart-idle */
-	REG_FLD_MOD(DSI_SYSCONFIG, 2, 4, 3);
-
-	_dsi_initialize_irq();
-
-	return 0;
-}
-
 static int dsi_display_enable(struct omap_dss_device *dssdev)
 {
 	int r = 0;
@@ -3086,11 +3220,11 @@ static int dsi_display_enable(struct omap_dss_device *dssdev)
 
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
-
+/* Skip to keep the DSI configuration of bootloader ==
 	r = _dsi_reset();
 	if (r)
 		goto err2;
-
+====================================================*/
 	dsi_core_init();
 
 	r = dsi_display_init_dispc(dssdev);
@@ -3104,7 +3238,19 @@ static int dsi_display_enable(struct omap_dss_device *dssdev)
 	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 
 	dsi.use_ext_te = dssdev->phy.dsi.ext_te;
+
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
 	dsi_set_te(dssdev, dsi.te_enabled);
+	*/
+	if (!dsi.use_ext_te) {
+		if (dsi.te_enabled) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
 
 	dsi.update_mode = dsi.user_update_mode;
 	if (dsi.update_mode == OMAP_DSS_UPDATE_AUTO)
@@ -3144,7 +3290,7 @@ static void dsi_display_disable(struct omap_dss_device *dssdev)
 	cancel_work_sync(&dsi.error_recovery.work);
 
 	complete_all(&dsi.update_completion);
-
+	complete_all(&dsi.packet_sent_completion);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED ||
 			dssdev->state == OMAP_DSS_DISPLAY_SUSPENDED)
 		goto end;
@@ -3179,7 +3325,7 @@ static int dsi_display_suspend(struct omap_dss_device *dssdev)
 	cancel_work_sync(&dsi.error_recovery.work);
 
 	complete_all(&dsi.update_completion);
-
+	complete_all(&dsi.packet_sent_completion);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED ||
 			dssdev->state == OMAP_DSS_DISPLAY_SUSPENDED)
 		goto end;
@@ -3237,8 +3383,19 @@ static int dsi_display_resume(struct omap_dss_device *dssdev)
 
 	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
 	dsi_set_te(dssdev, dsi.te_enabled);
-
+	*/
+	if (!dsi.use_ext_te) {
+		if (dsi.te_enabled) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
+	
 	dsi.update_mode = dsi.user_update_mode;
 	if (dsi.update_mode == OMAP_DSS_UPDATE_AUTO)
 		dsi_start_auto_update(dssdev);
@@ -3399,7 +3556,19 @@ static int dsi_display_enable_te(struct omap_dss_device *dssdev, bool enable)
 	if (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)
 		goto end;
 
-	dsi_set_te(dssdev, enable);
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
+ 	dsi_set_te(dssdev, enable);
+	*/
+	if (!dsi.use_ext_te) {
+		if (enable) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
+
 end:
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
@@ -3627,9 +3796,11 @@ int dsi_init(struct platform_device *pdev)
 	dsi.errors = 0;
 
 	/* XXX fail properly */
-
+	printk(KERN_INFO "ASK036 TEST\n");
 	init_completion(&dsi.bta_completion);
+	init_completion(&dsi.packet_sent_completion);
 	init_completion(&dsi.update_completion);
+	init_completion(&dsi.te_trigger_completion);
 
 	dsi.thread = kthread_create(dsi_update_thread, NULL, "dsi");
 	if (IS_ERR(dsi.thread)) {
diff --git a/drivers/video/omap2/dss/manager.c b/drivers/video/omap2/dss/manager.c
index 3e33898..f8d2aa3 100644
--- a/drivers/video/omap2/dss/manager.c
+++ b/drivers/video/omap2/dss/manager.c
@@ -284,8 +284,13 @@ struct manager_attribute {
 	__ATTR(_name, _mode, _show, _store)
 
 static MANAGER_ATTR(name, S_IRUGO, manager_name_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static MANAGER_ATTR(display, S_IRWXUGO|S_IWUSR,
+		manager_display_show, manager_display_store);
+#else
 static MANAGER_ATTR(display, S_IRUGO|S_IWUSR,
 		manager_display_show, manager_display_store);
+#endif
 static MANAGER_ATTR(default_color, S_IRUGO|S_IWUSR,
 		manager_default_color_show, manager_default_color_store);
 static MANAGER_ATTR(trans_key_type, S_IRUGO|S_IWUSR,
diff --git a/drivers/video/omap2/dss/overlay.c b/drivers/video/omap2/dss/overlay.c
index 3652106..4e67394 100644
--- a/drivers/video/omap2/dss/overlay.c
+++ b/drivers/video/omap2/dss/overlay.c
@@ -263,16 +263,30 @@ struct overlay_attribute {
 	__ATTR(_name, _mode, _show, _store)
 
 static OVERLAY_ATTR(name, S_IRUGO, overlay_name_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static OVERLAY_ATTR(manager, S_IRWXUGO|S_IWUSR,
+		overlay_manager_show, overlay_manager_store);
+#else
 static OVERLAY_ATTR(manager, S_IRUGO|S_IWUSR,
 		overlay_manager_show, overlay_manager_store);
+#endif
 static OVERLAY_ATTR(input_size, S_IRUGO, overlay_input_size_show, NULL);
 static OVERLAY_ATTR(screen_width, S_IRUGO, overlay_screen_width_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static OVERLAY_ATTR(position, S_IRWXUGO|S_IWUSR,
+		overlay_position_show, overlay_position_store);
+static OVERLAY_ATTR(output_size, S_IRWXUGO|S_IWUSR,
+		overlay_output_size_show, overlay_output_size_store);
+static OVERLAY_ATTR(enabled, S_IRWXUGO|S_IWUSR,
+		overlay_enabled_show, overlay_enabled_store);
+#else
 static OVERLAY_ATTR(position, S_IRUGO|S_IWUSR,
 		overlay_position_show, overlay_position_store);
 static OVERLAY_ATTR(output_size, S_IRUGO|S_IWUSR,
 		overlay_output_size_show, overlay_output_size_store);
 static OVERLAY_ATTR(enabled, S_IRUGO|S_IWUSR,
 		overlay_enabled_show, overlay_enabled_store);
+#endif
 static OVERLAY_ATTR(global_alpha, S_IRUGO|S_IWUSR,
 		overlay_global_alpha_show, overlay_global_alpha_store);
 
@@ -372,6 +386,28 @@ int dss_check_overlay(struct omap_overlay *ovl, struct omap_dss_device *dssdev)
 			outh = info->out_height;
 	}
 
+#ifdef CONFIG_PANEL_HDTV /* BANG Hacked start */
+	if (info->out_width > dw || info->out_height > dh || info->width > dw || info->height > dh) {
+		printk(" The panel is changed from prev_dw,prev_dh=%d,%d to dw,dh\ = %d, %d \n",
+			info->out_width, info->out_height, dw, dh);
+		/* we start to switch panel */
+		if (dw < info->out_width) {
+			printk(" Overwrite overlay info for width \n");
+			info->out_width = dw;
+			info->width = dw;
+			outw = dw;
+		} 
+
+
+		if (dh < info->out_height) {
+			printk(" Overwrite overlay info for height \n");
+                        info->out_height = dh;
+			info->height = dh;
+                        outh = dh;				
+		}
+	}
+#endif /* BANG Hacked end */
+
 	if (dw < info->pos_x + outw) {
 		DSSDBG("check_overlay failed 1: %d < %d + %d\n",
 				dw, info->pos_x, outw);
diff --git a/drivers/video/omap2/omapfb/omapfb-sysfs.c b/drivers/video/omap2/omapfb/omapfb-sysfs.c
index ef30e0e..288a98f 100644
--- a/drivers/video/omap2/omapfb/omapfb-sysfs.c
+++ b/drivers/video/omap2/omapfb/omapfb-sysfs.c
@@ -463,9 +463,15 @@ static struct device_attribute omapfb_attrs[] = {
 			store_rotate_type),
 	__ATTR(mirror, S_IRUGO | S_IWUSR, show_mirror, store_mirror),
 	__ATTR(size, S_IRUGO | S_IWUSR, show_size, store_size),
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+	__ATTR(overlays, S_IRWXUGO | S_IWUSR, show_overlays, store_overlays),
+	__ATTR(overlays_rotate, S_IRWXUGO | S_IWUSR, show_overlays_rotate,
+			store_overlays_rotate),
+#else
 	__ATTR(overlays, S_IRUGO | S_IWUSR, show_overlays, store_overlays),
 	__ATTR(overlays_rotate, S_IRUGO | S_IWUSR, show_overlays_rotate,
 			store_overlays_rotate),
+#endif
 	__ATTR(phys_addr, S_IRUGO, show_phys, NULL),
 	__ATTR(virt_addr, S_IRUGO, show_virt, NULL),
 };
diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c
index 2a673a2..8afd06d 100644
--- a/drivers/watchdog/omap_wdt.c
+++ b/drivers/watchdog/omap_wdt.c
@@ -469,7 +469,6 @@ static int __init omap_wdt_probe(struct platform_device *pdev)
 	omap_wdt_dev = pdev;
 
 #ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-	omap_wdt_ping(wdev);
 	setup_timer(&wdev->autopet_timer, autopet_handler,
 		    (unsigned long) wdev);
 	test_and_set_bit(1, (unsigned long *)&(wdev->omap_wdt_users));
@@ -576,9 +575,9 @@ static int omap_wdt_remove(struct platform_device *pdev)
  * may not play well enough with NOWAYOUT...
  */
 
-static int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)
+int omap_wdt_suspend(pm_message_t state)
 {
-	struct omap_wdt_dev *wdev = platform_get_drvdata(pdev);
+	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
 
 #ifdef CONFIG_OMAP_WATCHDOG_CONTROL
 	if (CLOSE_WDT == cntrl_flag)
@@ -598,9 +597,9 @@ static int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 
-static int omap_wdt_resume(struct platform_device *pdev)
+int omap_wdt_resume(void)
 {
-	struct omap_wdt_dev *wdev = platform_get_drvdata(pdev);
+	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
 
 #ifdef CONFIG_OMAP_WATCHDOG_CONTROL
 	if (CLOSE_WDT == cntrl_flag)
@@ -629,8 +628,10 @@ static struct platform_driver omap_wdt_driver = {
 	.probe		= omap_wdt_probe,
 	.remove		= omap_wdt_remove,
 	.shutdown	= omap_wdt_shutdown,
+/*
 	.suspend	= omap_wdt_suspend,
 	.resume		= omap_wdt_resume,
+*/
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "omap_wdt",
diff --git a/fs/yaffs2/yaffs_guts.h b/fs/yaffs2/yaffs_guts.h
index d995617..5240581 100644
--- a/fs/yaffs2/yaffs_guts.h
+++ b/fs/yaffs2/yaffs_guts.h
@@ -558,7 +558,9 @@ struct yaffs_DeviceStruct {
 
 	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
 
-	int emptyLostAndFound;  /* Flasg to determine if lst+found should be emptied on init */
+	int emptyLostAndFound;  /* Flasg to determine if lst+found should be
+				 * emptied on init
+				 */
 
 	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
 
diff --git a/include/linux/led-lm3530.h b/include/linux/led-lm3530.h
index 5f30b26..b9ef428 100755
--- a/include/linux/led-lm3530.h
+++ b/include/linux/led-lm3530.h
@@ -21,7 +21,7 @@
 
 #define	MANUAL		0
 #define	AUTOMATIC	1
-#define	MANUAL_SENSOR	2
+#define MANUAL_SENSOR   2
 
 
 #define LD_LM3530_LED_DEV "lcd-backlight"
@@ -56,7 +56,7 @@
 #define LM3530_GEN_CONF_MASK	0xE3
 #define LM3530_MAX_LED_VALUE	0xFF
 #define LM3530_MANUAL_VALUE		0x64
-#define LM3530_SENSOR_ENABLE	0x08
+#define LM3530_SENSOR_ENABLE    0x08
 
 #ifdef __KERNEL__
 struct lm3530_platform_data {
diff --git a/include/linux/leds-ld-cpcap.h b/include/linux/leds-ld-cpcap.h
index f2a9c2e..20d4073 100755
--- a/include/linux/leds-ld-cpcap.h
+++ b/include/linux/leds-ld-cpcap.h
@@ -22,27 +22,34 @@
 #define LD_MSG_IND_DEV "notification-led"
 #define LD_DISP_BUTTON_DEV "button-backlight"
 #define LD_KPAD_DEV "keyboard-backlight"
+#define LD_AF_LED_DEV "af-led"
 #define LD_SUPPLY "sw5"
 
-#define LD_MSG_IND_ON			0x1
-#define LD_MSG_IND_CURRENT		0x2
+#define LD_MSG_IND_ON               0x1
+#define LD_MSG_IND_CURRENT          0x2
+#define LD_MSG_IND_LO_CURRENT       0x0
 
-#define LD_MSG_IND_CPCAP_MASK		0x3FF
+#define LD_MSG_IND_CPCAP_MASK       0x3FF
 
-#define LD_MSG_IND_LOW			0x20
-#define LD_MSG_IND_LOW_MED		0x20
-#define LD_MSG_IND_MEDIUM		0x30
-#define LD_MSG_IND_MED_HIGH		0x40
-#define LD_MSG_IND_HIGH			0x50
+#define LD_MSG_IND_LOW              0x10
+#define LD_MSG_IND_LOW_MED          0x20
+#define LD_MSG_IND_MEDIUM           0x30
+#define LD_MSG_IND_MED_HIGH         0x40
+#define LD_MSG_IND_HIGH             0x50
 
-#define LD_LED_RED		0x01
-#define LD_LED_GREEN	0x02
-#define LD_LED_BLUE		0x04
-  
+#define LD_LED_RED                  0x01
+#define LD_LED_GREEN                0x02
+#define LD_LED_BLUE                 0x04
 
-#define LD_DISP_BUTTON_ON		0x1
-#define LD_DISP_BUTTON_CURRENT		0xa
-#define LD_DISP_BUTTON_DUTY_CYCLE	0x2a0
+#define LD_DISP_BUTTON_ON           0x1
+#define LD_DISP_BUTTON_CURRENT      0xA
+#define LD_DISP_BUTTON_DUTY_CYCLE	0x2A0
 #define LD_DISP_BUTTON_CPCAP_MASK	0x3FF
 
+#define LD_BLED_CPCAP_DUTY_CYCLE    0xB8
+#define LD_BLED_CPCAP_MASK          0x3FF
+#define LD_BLED_CPCAP_CURRENT       0x0
+
+#define LD_ALT_ADBL_CURRENT         0x4
+
 #endif  /* __LED_LD_CPCAP_H__ */
diff --git a/include/linux/qtouch_obp_ts.h b/include/linux/qtouch_obp_ts.h
index 1091b89..5a3e7e7 100644
--- a/include/linux/qtouch_obp_ts.h
+++ b/include/linux/qtouch_obp_ts.h
@@ -43,12 +43,23 @@ enum {
 	QTM_OBJ_TOUCH_KEYARRAY		= 15,
 	QTM_OBJ_PROCG_SIG_FILTER	= 16,
 	QTM_OBJ_PROCI_LINEAR_TBL	= 17,
-	QTM_OBJ_PROCI_GESTURES_PROC	= 18,
+	QTM_OBJ_SPT_COM_CONFIG		= 18,
+	QTM_OBJ_SPT_GPIO_PWM		= 19,
 	QTM_OBJ_PROCI_GRIPFACESUPPRESSION = 20,
-	QTM_OBJ_NOISESUPPRESSION_1 = 36,
+	QTM_OBJ_RESERVED3		= 21,
+	QTM_OBJ_PROCG_NOISE_SUPPRESSION	= 22,
+	QTM_OBJ_TOUCH_PROXIMITY		= 23,
+	QTM_OBJ_PROCI_ONE_TOUCH_GESTURE_PROC = 24,
+	QTM_OBJ_SPT_SELF_TEST		= 25,
+	QTM_OBJ_DEBUG_CTE_RANGE		= 26,
+	QTM_OBJ_PROCI_TWO_TOUCH_GESTURE_PROC = 27,
+	QTM_OBJ_SPT_CTE_CONFIG		= 28,
+	QTM_OBJ_NOISESUPPRESSION_1  = 36,
+	QTM_OBJ_DEBUG_DIAGNOSTIC         = 37,
+	QTM_OBJ_CPT_USERDATA             = 38,
 
 	/* Max number of objects currently defined */
-	QTM_OBP_MAX_OBJECT_NUM = QTM_OBJ_NOISESUPPRESSION_1 + 1,
+	QTM_OBP_MAX_OBJECT_NUM = QTM_OBJ_CPT_USERDATA + 1,
 };
 
 /* OBP structures as defined by the wire protocol. */
@@ -155,11 +166,13 @@ struct qtm_gen_power_cfg {
 /* GEN_ACQUIRECONFIG_T8 */
 struct qtm_gen_acquire_cfg {
 	uint8_t			charge_time;       /* in 250ns */
-	uint8_t			atouch_drift;      /* in 200ms */
+	uint8_t			reserve0;          /* Reserved */
 	uint8_t			touch_drift;       /* in 200ms */
 	uint8_t			drift_susp;        /* in 200ms */
 	uint8_t			touch_autocal;     /* in 200ms */
 	uint8_t			sync;
+	uint8_t			anti_cal_susp;
+	uint8_t			anti_cal_sthr;
 } __attribute__ ((packed));
 
 /* TOUCH_MULTITOUCHSCREEN_T9 */
@@ -173,22 +186,25 @@ struct qtm_touch_multi_cfg {
 	uint8_t			burst_len;
 	uint8_t			tch_det_thr;
 	uint8_t			tch_det_int;
-	uint8_t			rsvd1;
-	uint8_t			rsvd2;
+	uint8_t			orient;
+	uint8_t			mrg_to;
 	uint8_t			mov_hyst_init;
 	uint8_t			mov_hyst_next;
 	uint8_t			mov_filter;
 	uint8_t			num_touch;
 	uint8_t			merge_hyst;
 	uint8_t			merge_thresh;
-	uint8_t         amp_hyst;
+	uint8_t			amp_hyst;
 	uint16_t		x_res;
 	uint16_t		y_res;
 	uint8_t			x_low_clip;
 	uint8_t			x_high_clip;
 	uint8_t			y_low_clip;
 	uint8_t			y_high_clip;
-
+	uint8_t			x_edge_ori;
+	uint8_t			x_edge_cdist;
+	uint8_t			y_edge_ori;;
+	uint8_t			y_edge_cdist;
 } __attribute__ ((packed));
 
 /* TOUCH_KEYARRAY_T15 */
@@ -222,6 +238,32 @@ struct qtm_proci_linear_tbl_cfg {
 	uint8_t			y_segment[16];
 } __attribute__ ((packed));
 
+/* SPT_COM_CONFIG_T18 */
+struct qtm_spt_com_cfg {
+	uint8_t			ctrl;
+	uint8_t			cmd;
+} __attribute__ ((packed));
+
+/* SPT_GPIOPWM_T19*/
+struct qtm_spt_gpio_pwm_cfg {
+	uint8_t			ctrl;
+	uint8_t			report_mask;
+	uint8_t			pin_direction;
+	uint8_t			internal_pullup;
+	uint8_t			output_value;
+	uint8_t			wake_on_change;
+	uint8_t			pwm_enable;
+	uint8_t			pwm_period;
+	uint8_t			duty_cycle_0;
+	uint8_t			duty_cycle_1;
+	uint8_t			duty_cycle_2;
+	uint8_t			duty_cycle_3;
+	uint8_t			trigger_0;
+	uint8_t			trigger_1;
+	uint8_t			trigger_2;
+	uint8_t			trigger_3;
+} __attribute__ ((packed));
+
 /* PROCI_GRIPFACESUPPRESSION_T20 */
 struct qtm_proci_grip_suppression_cfg {
 	uint8_t			ctrl;
@@ -237,6 +279,72 @@ struct qtm_proci_grip_suppression_cfg {
 	uint8_t			shpthr2;
 } __attribute__ ((packed));
 
+/* PROCG_NOISESUPPRESSION_T22 */
+struct qtm_procg_noise_suppression_cfg {
+	uint8_t			ctrl;
+	uint16_t		reserve0;
+	uint16_t		gcaf_upper_limit;
+	uint16_t		gcaf_lower_limit;
+	uint8_t			gcaf_num_active;
+	uint8_t			noise_threshold;
+	uint8_t			reserve1;
+	uint8_t			freq_hop_scale;
+	uint8_t			burst_freq_0;
+	uint8_t			burst_freq_1;
+	uint8_t			burst_freq_2;
+	uint8_t			burst_freq_3;
+	uint8_t			burst_freq_4;
+	uint8_t			gcaf_num_idle;
+} __attribute__ ((packed));
+
+/* PROCI_ONETOUCHGESTUREPROCESSOR_T24 */
+struct qtm_proci_one_touch_gesture_proc_cfg {
+	uint8_t			ctrl;
+	uint8_t			reserve0;
+	uint16_t		gesture_enable;
+	uint8_t			pres_proc;
+	uint8_t			tap_time_out;
+	uint8_t			flick_time_out;
+	uint8_t			drag_time_out;
+	uint8_t			short_press_time_out;
+	uint8_t			long_press_time_out;
+	uint8_t			repeat_press_time_out;
+	uint16_t		flick_threshold;
+	uint16_t		drag_threshold;
+	uint16_t		tap_threshold;
+	uint16_t		throw_threshold;
+} __attribute__ ((packed));
+
+/* SPT_SELFTEST_T25 */
+struct qtm_spt_self_test_cfg {
+	uint8_t			ctrl;
+	uint8_t			command;
+	uint16_t		high_signal_limit_0;
+	uint16_t		low_signal_limit_0;
+	uint16_t		high_signal_limit_1;
+	uint16_t		low_signal_limit_1;
+} __attribute__ ((packed));
+
+/* PROCI_TWOTOUCHGESTUREPROCESSOR_T27 */
+struct qtm_proci_two_touch_gesture_proc_cfg {
+	uint8_t			ctrl;
+	uint8_t			reserved0;
+	uint8_t			reserved1;
+	uint8_t			gesture_enable;
+	uint8_t			rotate_threshold;
+	uint16_t		zoom_threshold;
+} __attribute__ ((packed));
+
+/* SPT_CTECONFIG_T28 */
+struct qtm_spt_cte_config_cfg {
+	uint8_t			ctrl;
+	uint8_t			command;
+	uint8_t			mode;
+	uint8_t			idle_gcaf_depth;
+	uint8_t			active_gcaf_depth;
+	uint8_t			voltage;
+} __attribute__ ((packed));
+
 /* QTM_OBJ_NOISESUPPRESSION_1 */
 struct qtm_proci_noise1_suppression_cfg {
 	uint8_t			ctrl;
@@ -245,14 +353,28 @@ struct qtm_proci_noise1_suppression_cfg {
 	uint8_t			duty_cycle;
 } __attribute__ ((packed));
 
+/* QTM_OBJ_CPT_USERDATA_T38 */
+struct qtm_spt_userdata {
+	uint8_t			data_0;
+	uint8_t			data_1;
+	uint8_t			data_2;
+	uint8_t			data_3;
+	uint8_t			data_4;
+	uint8_t			data_5;
+	uint8_t			data_6;
+	uint8_t			data_7;
+} __attribute__ ((packed));
+
 /*******************************/
 /******** platform data ********/
 /*******************************/
 
 struct vkey {
-	int	code;
-	int	min;
-	int	max;
+	int     code;
+	int     center_x;
+	int     center_y;
+	int     width;
+	int     height;
 };
 
 struct virt_keys {
@@ -293,8 +415,8 @@ struct qtouch_ts_platform_data {
 	uint32_t		abs_min_w;
 	uint32_t		abs_max_w;
 
-	uint32_t		x_delta;
-	uint32_t		y_delta;
+        uint32_t                x_delta;
+        uint32_t                y_delta;
 
 	uint16_t		nv_checksum;
 
@@ -317,8 +439,17 @@ struct qtouch_ts_platform_data {
 	struct qtm_touch_keyarray_cfg   key_array_cfg;
 	struct qtm_procg_sig_filter_cfg		sig_filter_cfg;
 	struct qtm_proci_linear_tbl_cfg		linear_tbl_cfg;
-	struct qtm_proci_grip_suppression_cfg	grip_suppression_cfg;
-	struct qtm_proci_noise1_suppression_cfg noise1_suppression_cfg;
+	struct qtm_proci_grip_suppression_cfg	    grip_suppression_cfg;
+	struct qtm_spt_com_cfg			        com_cfg;
+	struct qtm_spt_gpio_pwm_cfg			        gpio_pwm_cfg;
+	struct qtm_procg_noise_suppression_cfg	    noise_suppression_cfg;
+	struct qtm_proci_one_touch_gesture_proc_cfg	\
+					one_touch_gesture_proc_cfg;
+	struct qtm_spt_self_test_cfg			    self_test_cfg;
+	struct qtm_proci_two_touch_gesture_proc_cfg	two_touch_gesture_proc_cfg;
+	struct qtm_spt_cte_config_cfg			    cte_config_cfg;
+	struct qtm_proci_noise1_suppression_cfg     noise1_suppression_cfg;
+	struct qtm_spt_userdata     userdata;
 };
 
 #endif /* _LINUX_QTOUCH_OBP_TS_H */
diff --git a/include/linux/quickwakeup.h b/include/linux/quickwakeup.h
old mode 100755
new mode 100644
diff --git a/include/linux/soundcard.h b/include/linux/soundcard.h
index 1904afe..b682b84 100644
--- a/include/linux/soundcard.h
+++ b/include/linux/soundcard.h
@@ -954,6 +954,9 @@ typedef unsigned char mixer_record[128];
 #define SOUND_MIXER_PRIVATE4		_SIOWR('M', 114, int)
 #define SOUND_MIXER_PRIVATE5		_SIOWR('M', 115, int)
 
+#define SOUND_MIXER_FMON            _SIOR('M', 120, int)
+#define SOUND_MIXER_FMOFF           _SIOR('M', 121, int)
+#define SOUND_MIXER_FMPATH          _SIOR('M', 122, int)
 /*
  * SOUND_MIXER_GETLEVELS and SOUND_MIXER_SETLEVELS calls can be used
  * for querying current mixer settings from the driver and for loading
diff --git a/include/linux/spi/cpcap.h b/include/linux/spi/cpcap.h
index 50245d7..44e19c6 100644
--- a/include/linux/spi/cpcap.h
+++ b/include/linux/spi/cpcap.h
@@ -606,6 +606,8 @@ struct cpcap_regacc {
 #define CPCAP_IOCTL_UC_MACRO_START \
 	_IOWR(0, CPCAP_IOCTL_NUM_UC_MACRO_START, enum cpcap_macro)
 
+/*#define CPCAP_AUDIO_REG_DEBUG*/
+
 #ifdef __KERNEL__
 struct cpcap_device {
 	struct spi_device	*spi;
@@ -686,5 +688,15 @@ int cpcap_uc_stop(struct cpcap_device *cpcap, enum cpcap_macro macro);
 
 unsigned char cpcap_uc_status(struct cpcap_device *cpcap,
 			      enum cpcap_macro macro);
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+int cpcap_direct_misc_write(unsigned short reg, unsigned short value,\
+							unsigned short mask);
+#endif
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+void cpcap_regacc_audio_reg_dump(void);
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SPI_CPCAP_H */
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 68bb1c5..5026eed 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -803,4 +803,8 @@ spi_unregister_device(struct spi_device *spi)
 		device_unregister(&spi->dev);
 }
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+struct spi_device *spi_get_spi_device(char *modalias);
+#endif
+
 #endif /* __LINUX_SPI_H */
diff --git a/kernel/power/main.c b/kernel/power/main.c
index 99bfb52..17e941f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -27,6 +27,11 @@
 
 #include "power.h"
 
+#ifdef CONFIG_OMAP_WATCHDOG
+int omap_wdt_suspend(pm_message_t state);
+int omap_wdt_resume(void);
+#endif
+
 DEFINE_MUTEX(pm_mutex);
 
 unsigned int pm_flags;
@@ -292,6 +297,10 @@ static int _suspend_enter(suspend_state_t state)
 		goto Done;
 	}
 
+#ifdef CONFIG_OMAP_WATCHDOG
+	omap_wdt_suspend(PMSG_SUSPEND);
+#endif
+
 	error = sysdev_suspend(PMSG_SUSPEND);
 	if (!error) {
 		if (!suspend_test(TEST_CORE))
@@ -299,6 +308,10 @@ static int _suspend_enter(suspend_state_t state)
 		sysdev_resume();
 	}
 
+#ifdef CONFIG_OMAP_WATCHDOG
+	omap_wdt_resume();
+#endif
+
 	device_power_up(PMSG_RESUME);
  Done:
 
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c271728..7a1bc22 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -495,7 +495,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn)
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->mode != HCI_CM_SNIFF /* || !conn->power_save */)
+	if (conn->mode != HCI_CM_SNIFF /*|| !conn->power_save */)
 		goto timer;
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index da2c3b8..07402b1 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -34,11 +34,29 @@
  *
  */
 
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ */
+
+/*
+ * Author     Date          Comment
+ * =======   ===========   ====================================================
+ * Motorola  11/12/2009    Limit mss to be no bigger than 1372 to solve
+ *                         compatibility issue
+ */
+
+
 #include <net/tcp.h>
 
 #include <linux/compiler.h>
 #include <linux/module.h>
 
+/*
+ * Limit mss to be not bigger than 1372
+ * to solve compatibility issue
+ */
+#define TCP_MAX_SEGMENT_SIZE_LIMIT 1372
+
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse __read_mostly = 1;
 
@@ -113,6 +131,15 @@ static __u16 tcp_advertise_mss(struct sock *sk)
 	struct dst_entry *dst = __sk_dst_get(sk);
 	int mss = tp->advmss;
 
+	/*
+	 * Limit mss to be not bigger than 1372
+	 * to solve compatibility issue
+	 */
+	if (mss > TCP_MAX_SEGMENT_SIZE_LIMIT) {
+		mss = TCP_MAX_SEGMENT_SIZE_LIMIT;
+		tp->advmss = mss;
+	}
+
 	if (dst && dst_metric(dst, RTAX_ADVMSS) < mss) {
 		mss = dst_metric(dst, RTAX_ADVMSS);
 		tp->advmss = mss;
@@ -1021,6 +1048,13 @@ unsigned int tcp_sync_mss(struct sock *sk, u32 pmtu)
 	icsk->icsk_pmtu_cookie = pmtu;
 	if (icsk->icsk_mtup.enabled)
 		mss_now = min(mss_now, tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low));
+	/*
+	 * Limit mss to be not bigger than 1372
+	 * to solve compatiblity issue
+	 */
+	if (mss_now > TCP_MAX_SEGMENT_SIZE_LIMIT)
+		mss_now = TCP_MAX_SEGMENT_SIZE_LIMIT;
+
 	tp->mss_cache = mss_now;
 
 	return mss_now;
diff --git a/sound/oss/moto_audio/cpcap_audio_driver.c b/sound/oss/moto_audio/cpcap_audio_driver.c
index 65b83ce..1d2d945 100755
--- a/sound/oss/moto_audio/cpcap_audio_driver.c
+++ b/sound/oss/moto_audio/cpcap_audio_driver.c
@@ -509,6 +509,78 @@ static bool cpcap_audio_set_bits_for_speaker(int speaker, int balance,
 	return false; /* There is no external loudspeaker on this product */
 }
 
+static void cpcap_audio_set_output_amp(struct cpcap_audio_state *state)
+{
+  static unsigned int prev_aud_out_data;
+  bool activate_ext_loudspeaker = false;
+  struct cpcap_regacc reg_changes = { 0 };
+
+  activate_ext_loudspeaker = cpcap_audio_set_bits_for_speaker(
+					state->codec_primary_speaker,
+					state->codec_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->codec_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->stdac_primary_speaker,
+					state->stdac_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->stdac_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->ext_primary_speaker,
+					state->ext_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->ext_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  reg_changes.mask = reg_changes.value | prev_aud_out_data;
+
+  prev_aud_out_data = reg_changes.value;
+
+  /* Charge pump should be enabled first and wait a minimum of 750 uSec
+		to allow for settling of the negative supply.
+  */
+	if ((reg_changes.mask & (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+		if (reg_changes.value
+			& (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN)) {
+			cpcap_regacc_write(state->cpcap, CPCAP_REG_RXOA,
+			CPCAP_BIT_ST_HS_CP_EN, CPCAP_BIT_ST_HS_CP_EN);
+			mdelay(1);
+		}
+	}
+
+  logged_cpcap_write(state->cpcap, CPCAP_REG_RXOA,
+      reg_changes.value, reg_changes.mask);
+
+  /* When disabling HS output amp, HS_CP should be turned off after output
+		amp goes down. */
+	if ((reg_changes.mask & (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+		if (!(reg_changes.value
+			& (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+			mdelay(1);
+			cpcap_regacc_write(state->cpcap, CPCAP_REG_RXOA,
+				0, CPCAP_BIT_ST_HS_CP_EN);
+		}
+	}
+}
+
 static void cpcap_audio_configure_aud_mute(struct cpcap_audio_state *state,
 				struct cpcap_audio_state *prev_state)
 {
@@ -815,10 +887,55 @@ static void cpcap_audio_configure_input_gains(
 	}
 }
 
+/* In case of sholes tablet, FM radio use external pga.
+   FM radio have a different gain table. So we should set gain separately
+*/
+
+#define EXT_PGA_SPEAKER_OUT_GAIN         0x12
+#define EXT_PGA_HEADSET_OUT_GAIN         0x08
+
+
 static void cpcap_audio_configure_output_gains(
 	struct cpcap_audio_state *state,
 	struct cpcap_audio_state *previous_state)
 {
+/*	FM radio volume gain control routine is added by w21558
+*/
+#if 1
+	if (state->output_gain != previous_state->output_gain) {
+		struct cpcap_regacc reg_changes = { 0 };
+		unsigned int temp_output_gain = state->output_gain & 0x0000000F;
+		unsigned int ext_pag_output_gain = EXT_PGA_HEADSET_OUT_GAIN;
+		unsigned short prev_output_gain = 0;
+
+		if (state->output_gain == 0xFF) {
+			/* Only external PGA gain is changed */
+			int ret_val = 0;
+
+			ret_val = cpcap_regacc_read(state->cpcap,
+				CPCAP_REG_RXVC, &prev_output_gain);
+			prev_output_gain = (prev_output_gain & 0x00000F00) >> 8;
+
+			reg_changes.value |=
+			    ((prev_output_gain << 2) | (prev_output_gain << 8) |
+			     (ext_pag_output_gain << 12));
+		} else {
+
+			ext_pag_output_gain = (state->output_gain) ? \
+						EXT_PGA_HEADSET_OUT_GAIN : 0x00;
+
+		reg_changes.value |=
+		    ((temp_output_gain << 2) | (temp_output_gain << 8) |
+		     (ext_pag_output_gain << 12));
+		}
+
+		reg_changes.mask = 0xFF3C;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_RXVC,
+				reg_changes.value, reg_changes.mask);
+	}
+#else
+
 	if (state->output_gain != previous_state->output_gain) {
 		struct cpcap_regacc reg_changes = { 0 };
 		unsigned int temp_output_gain = state->output_gain & 0x0000000F;
@@ -832,63 +949,29 @@ static void cpcap_audio_configure_output_gains(
 		logged_cpcap_write(state->cpcap, CPCAP_REG_RXVC,
 				reg_changes.value, reg_changes.mask);
 	}
+#endif
 }
 
 static void cpcap_audio_configure_output(
 	struct cpcap_audio_state *state,
-	struct cpcap_audio_state *previous_state)
+	struct cpcap_audio_state *previous_state,
+	bool speaker_off)
 {
-	static unsigned int prev_aud_out_data;
-
 	if (is_output_changed(previous_state, state) ||
 	    is_codec_changed(previous_state, state) ||
 	    is_stdac_changed(previous_state, state)) {
-		bool activate_ext_loudspeaker = false;
-		struct cpcap_regacc reg_changes = { 0 };
-
-		cpcap_audio_set_output_amp_switches(state);
-
-		activate_ext_loudspeaker = cpcap_audio_set_bits_for_speaker(
-						state->codec_primary_speaker,
-						 state->codec_primary_balance,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->codec_secondary_speaker,
-						 CPCAP_AUDIO_BALANCE_NEUTRAL,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					 cpcap_audio_set_bits_for_speaker(
-						state->stdac_primary_speaker,
-						 state->stdac_primary_balance,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->stdac_secondary_speaker,
-						 CPCAP_AUDIO_BALANCE_NEUTRAL,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->ext_primary_speaker,
-						 state->ext_primary_balance,
-						 &(reg_changes.value));
-
-		activate_ext_loudspeaker = activate_ext_loudspeaker ||
-					cpcap_audio_set_bits_for_speaker(
-						state->ext_secondary_speaker,
-						 CPCAP_AUDIO_BALANCE_NEUTRAL,
-						 &(reg_changes.value));
 
-		reg_changes.mask = reg_changes.value | prev_aud_out_data;
+		/* In case of turning on speaker, output amp switches should be
+			configured ahead of amp */
+		if (!speaker_off)
+			cpcap_audio_set_output_amp_switches(state);
 
-		prev_aud_out_data = reg_changes.value;
+		cpcap_audio_set_output_amp(state);
 
-		logged_cpcap_write(state->cpcap, CPCAP_REG_RXOA,
-				reg_changes.value, reg_changes.mask);
+		/* In case of turning off speaker, output amp should be turned
+			off ahead of amp switches */
+		if (speaker_off)
+			cpcap_audio_set_output_amp_switches(state);
 	}
 }
 
@@ -909,11 +992,13 @@ static void cpcap_audio_configure_input(
 		if (state->codec_mode == CPCAP_AUDIO_CODEC_LOOPBACK)
 			reg_changes.value |= CPCAP_BIT_DLM;
 
+#ifndef CONFIG_MACH_SHOLEST 
 		if (previous_state->microphone
 		    == CPCAP_AUDIO_IN_HEADSET) {
 			logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
 				     0, CPCAP_BIT_GPIO4DRV);
 		}
+#endif
 		switch (state->microphone) {
 		case CPCAP_AUDIO_IN_HANDSET:
 			reg_changes.value |= CPCAP_BIT_MB_ON1R
@@ -923,9 +1008,11 @@ static void cpcap_audio_configure_input(
 		case CPCAP_AUDIO_IN_HEADSET:
 			reg_changes.value |= CPCAP_BIT_HS_MIC_MUX
 				| CPCAP_BIT_MIC1_PGA_EN;
+#ifndef CONFIG_MACH_SHOLEST
 			logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
 					   CPCAP_BIT_GPIO4DRV,
 					   CPCAP_BIT_GPIO4DRV);
+#endif
 			break;
 
 		case CPCAP_AUDIO_IN_EXT_BUS:
@@ -994,39 +1081,10 @@ static void cpcap_audio_configure_power(int power)
 	}
 }
 
-static void cpcap_audio_register_dump(struct cpcap_audio_state *state)
-{
-	unsigned short reg_val = 0;
-
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_VAUDIOC, &reg_val);
-	printk(KERN_INFO "0x200 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_CC, &reg_val);
-	printk(KERN_INFO "0x201 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_CDI, &reg_val);
-	printk(KERN_INFO "0x202 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_SDAC, &reg_val);
-	printk(KERN_INFO "0x203 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_SDACDI, &reg_val);
-	printk(KERN_INFO "0x204 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_TXI, &reg_val);
-	printk(KERN_INFO "0x205 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_TXMP, &reg_val);
-	printk(KERN_INFO "0x206 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXOA, &reg_val);
-	printk(KERN_INFO "0x207 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXVC, &reg_val);
-	printk(KERN_INFO "0x208 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXCOA, &reg_val);
-	printk(KERN_INFO "0x209 = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXSDOA, &reg_val);
-	printk(KERN_INFO "0x20A = %x\n", reg_val);
-	cpcap_regacc_read(state->cpcap, CPCAP_REG_RXEPOA, &reg_val);
-	printk(KERN_INFO "0x20B = %x\n", reg_val);
-}
-
 void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 {
 	struct cpcap_audio_state *previous_state = &previous_state_struct;
+	bool is_speaker_off = false;
 
 	if (state->codec_mute == CPCAP_AUDIO_CODEC_BYPASS_LOOP)
 		state->codec_mode = CPCAP_AUDIO_CODEC_ON;
@@ -1056,8 +1114,10 @@ void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 		state->microphone != CPCAP_AUDIO_IN_BT_MONO))
 		cpcap_audio_configure_power(1);
 
-	if (is_speaker_turning_off(state, previous_state))
-		cpcap_audio_configure_output(state, previous_state);
+	is_speaker_off = is_speaker_turning_off(state, previous_state);
+	if (is_speaker_off)
+		cpcap_audio_configure_output(state, previous_state,
+						is_speaker_off);
 
 	if (is_codec_changed(state, previous_state)) {
 		int codec_mute = state->codec_mute;
@@ -1093,7 +1153,7 @@ void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 
 	cpcap_audio_configure_input_gains(state, previous_state);
 
-	cpcap_audio_configure_output(state, previous_state);
+	cpcap_audio_configure_output(state, previous_state, is_speaker_off);
 
 	cpcap_audio_configure_output_gains(state, previous_state);
 
@@ -1111,8 +1171,6 @@ void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
 		cpcap_audio_configure_power(0);
 
 	previous_state_struct = *state;
-
-	cpcap_audio_register_dump(state);
 }
 
 void cpcap_audio_init(struct cpcap_audio_state *state)
@@ -1131,6 +1189,11 @@ void cpcap_audio_init(struct cpcap_audio_state *state)
 	logged_cpcap_write(state->cpcap, CPCAP_REG_RXSDOA, 0, 0x1FFF);
 	logged_cpcap_write(state->cpcap, CPCAP_REG_RXEPOA, 0, 0x7FFF);
 
+	/* Use free running clock for amplifiers */
+	logged_cpcap_write(state->cpcap, CPCAP_REG_A2LA,
+		CPCAP_BIT_A2_FREE_RUN,
+		CPCAP_BIT_A2_FREE_RUN);
+
 	logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
 			   CPCAP_BIT_GPIO4DIR, CPCAP_BIT_GPIO4DIR);
 
diff --git a/sound/oss/moto_audio/cpcap_audio_driver.h b/sound/oss/moto_audio/cpcap_audio_driver.h
index 0b567c7..063f7a6 100644
--- a/sound/oss/moto_audio/cpcap_audio_driver.h
+++ b/sound/oss/moto_audio/cpcap_audio_driver.h
@@ -24,7 +24,7 @@
 #include <linux/spi/cpcap-regbits.h>
 #include <linux/spi/cpcap.h>
 
-/*#define AUDIO_I2S_MODE*/
+#define AUDIO_I2S_MODE
 
 enum {
 	CPCAP_AUDIO_MODE_NORMAL,	/* mode of normal audio operation */
diff --git a/sound/oss/moto_audio/omap34xx_audio_driver.c b/sound/oss/moto_audio/omap34xx_audio_driver.c
index 9d53dce..938bd79 100755
--- a/sound/oss/moto_audio/omap34xx_audio_driver.c
+++ b/sound/oss/moto_audio/omap34xx_audio_driver.c
@@ -291,7 +291,6 @@ static const struct sample_rate_info_t valid_sample_rates[] = {
 	{.rate = 48000, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_48000_HZ},
 };
 
-static unsigned long flags;
 static int read_buf_full;
 static int primary_spkr_setting = CPCAP_AUDIO_OUT_NONE;
 static int secondary_spkr_setting = CPCAP_AUDIO_OUT_NONE;
@@ -1470,8 +1469,8 @@ static int audio_configure_ssi(struct inode *inode, struct file *file)
 		tx_params.word_length1 = OMAP_MCBSP_WORD_32;
 		ssi = STDAC_SSI;
 #ifdef AUDIO_I2S_MODE
-		tx_cfg_params.fs_polarity  = OMAP_MCBSP_FS_ACTIVE_LOW;
-		tx_cfg_params.phase = OMAP_MCBSP_FRAME_DUALPHASE;
+		/*tx_cfg_params.fs_polarity  = OMAP_MCBSP_FS_ACTIVE_LOW;*/
+		/*tx_cfg_params.phase = OMAP_MCBSP_FRAME_DUALPHASE;*/
 #endif
 		omap_ctrl_writel(omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) |
 					(1 << OMAP2_CONTROL_DEVCONF0_BIT6),
@@ -1786,6 +1785,41 @@ static int audio_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
+	case SOUND_MIXER_FMPATH:
+		{
+			int spkr;
+			TRY(copy_from_user(&spkr, (int *)arg, sizeof(int)))
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMPATH with spkr = %#x\n", spkr);
+			cpcap_audio_state.ext_primary_speaker = spkr;
+/* 	FM radio output gain is controlled by cpcap_audio_driver.c
+	So, this value should not be changed here.
+	This value should be synced other output gain value.
+*/
+			cpcap_audio_state.output_gain = 0xFF;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
+	case SOUND_MIXER_FMON:
+		{
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMON\n");
+			cpcap_audio_state.ext_primary_speaker = CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_state.analog_source =
+				CPCAP_AUDIO_ANALOG_SOURCE_STEREO;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
+	case SOUND_MIXER_FMOFF:
+		{
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMOFF\n");
+			cpcap_audio_state.ext_primary_speaker =	CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_state.ext_secondary_speaker =
+				CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
 	case SOUND_MIXER_RECSRC:
 	{
 		int mic;
@@ -1877,6 +1911,7 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 								loff_t *nouse)
 {
 	int chunksize, ret = 0;
+	unsigned long flags;
 	const char *buffer0 = buffer;
 	struct inode *inode = (struct inode *)file->private_data;
 	int minor = MINOR(inode->i_rdev);
@@ -1993,6 +2028,7 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 
 	if (buffer - buffer0)
 		ret = buffer - buffer0;
+
 out:
 	mutex_unlock(&audio_lock);
 	return ret;
diff --git a/sound/oss/omap34xx_audio_driver.c b/sound/oss/omap34xx_audio_driver.c
index 76b6173..7a87d44 100755
--- a/sound/oss/omap34xx_audio_driver.c
+++ b/sound/oss/omap34xx_audio_driver.c
@@ -1886,7 +1886,6 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 	int minor = MINOR(inode->i_rdev);
 	struct audio_stream *str = (minor == state.dev_dsp) ?
 			state.stdac_out_stream : state.codec_out_stream;
-	unsigned long flags;
 
 	mutex_lock(&audio_lock);
 
@@ -1982,23 +1981,12 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 
 		buf->offset = 0;
 
-		/*
-		 * HACKHACKHACK
-		 *
-		 * Disabling IRQs works around a race accessing str between the
-		 * following code and the interrupt handler.  This should be
-		 * replaced with propper locking around access to any
-		 * audio_stream throughout the dirver.
-		 */
-
-		local_irq_save(flags);
 		if (++str->usr_head >= str->nbfrags)
 			str->usr_head = 0;
 
 		str->pending_frags++;
 
 		ret = audio_process_buf(str, inode);
-		local_irq_restore(flags);
 	}
 
 	if (buffer - buffer0)
